<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="" lang=""><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Beej's Guide to Network Programming</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="Beej's%20Guide%20to%20Network%20Programming_files/css.css" rel="stylesheet"> 

  <!-- BG custom styling -->
  <style type="text/css">
  /* Fix for line numbers not visible */
  pre.numberSource code > span {
  	left: -1em;
  }
  pre.numberSource {
  	margin-left: initial;
  }

  /* Put some space after the section numbers */
  span.toc-section-number::after {
      content: "\a0\a0\a0";  /* non-breaking whitespace */
  }

  /* Hide underlines on code number links */
  pre > code.sourceCode > span > a:first-child::before {
      text-decoration: none;
  }

  /* Keep code tags from wrapping in tables */
  tbody code {
  	white-space: nowrap;
  }
  </style>
</head>
<body data-new-gr-c-s-check-loaded="8.904.0" data-gr-ext-installed="">
<header id="title-block-header">
<h1 class="title">Beej's Guide to Network Programming</h1>
<p class="subtitle">Using Internet Sockets</p>
<p class="author">Brian “Beej Jorgensen” Hall</p>
<p class="date">v3.1.5, Copyright © November 20, 2020</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#intro"><span class="toc-section-number">1</span> Intro</a>
<ul>
<li><a href="#audience"><span class="toc-section-number">1.1</span> Audience</a></li>
<li><a href="#platform-and-compiler"><span class="toc-section-number">1.2</span> Platform and Compiler</a></li>
<li><a href="#official-homepage-and-books-for-sale"><span class="toc-section-number">1.3</span> Official Homepage and Books For Sale</a></li>
<li><a href="#solaris"><span class="toc-section-number">1.4</span> Note for Solaris/SunOS Programmers</a></li>
<li><a href="#windows"><span class="toc-section-number">1.5</span> Note for Windows Programmers</a></li>
<li><a href="#email-policy"><span class="toc-section-number">1.6</span> Email Policy</a></li>
<li><a href="#mirroring"><span class="toc-section-number">1.7</span> Mirroring</a></li>
<li><a href="#note-for-translators"><span class="toc-section-number">1.8</span> Note for Translators</a></li>
<li><a href="#legal"><span class="toc-section-number">1.9</span> Copyright, Distribution, and Legal</a></li>
<li><a href="#dedication"><span class="toc-section-number">1.10</span> Dedication</a></li>
<li><a href="#publishing-information"><span class="toc-section-number">1.11</span> Publishing Information</a></li>
</ul></li>
<li><a href="#what-is-a-socket"><span class="toc-section-number">2</span> What is a socket?</a>
<ul>
<li><a href="#two-types-of-internet-sockets"><span class="toc-section-number">2.1</span> Two Types of Internet Sockets</a></li>
<li><a href="#lowlevel"><span class="toc-section-number">2.2</span> Low level Nonsense and Network Theory</a></li>
</ul></li>
<li><a href="#ip-addresses-structs-and-data-munging"><span class="toc-section-number">3</span> IP Addresses, <code>struct</code>s, and Data Munging</a>
<ul>
<li><a href="#ip-addresses-versions-4-and-6"><span class="toc-section-number">3.1</span> IP Addresses, versions 4 and 6</a>
<ul>
<li><a href="#subnets"><span class="toc-section-number">3.1.1</span> Subnets</a></li>
<li><a href="#port-numbers"><span class="toc-section-number">3.1.2</span> Port Numbers</a></li>
</ul></li>
<li><a href="#byte-order"><span class="toc-section-number">3.2</span> Byte Order</a></li>
<li><a href="#structs"><span class="toc-section-number">3.3</span> <code>struct</code>s</a></li>
<li><a href="#ip-addresses-part-deux"><span class="toc-section-number">3.4</span> IP Addresses, Part Deux</a>
<ul>
<li><a href="#private-or-disconnected-networks"><span class="toc-section-number">3.4.1</span> Private (Or Disconnected) Networks</a></li>
</ul></li>
</ul></li>
<li><a href="#jumping-from-ipv4-to-ipv6"><span class="toc-section-number">4</span> Jumping from IPv4 to IPv6</a></li>
<li><a href="#system-calls-or-bust"><span class="toc-section-number">5</span> System Calls or Bust</a>
<ul>
<li><a href="#getaddrinfoprepare-to-launch"><span class="toc-section-number">5.1</span> <code>getaddrinfo()</code>—Prepare to launch!</a></li>
<li><a href="#socket"><span class="toc-section-number">5.2</span> <code>socket()</code>—Get the File Descriptor!</a></li>
<li><a href="#bind"><span class="toc-section-number">5.3</span> <code>bind()</code>—What port am I on?</a></li>
<li><a href="#connect"><span class="toc-section-number">5.4</span> <code>connect()</code>—Hey, you!</a></li>
<li><a href="#listen"><span class="toc-section-number">5.5</span> <code>listen()</code>—Will somebody please call me?</a></li>
<li><a href="#acceptthank-you-for-calling-port-3490."><span class="toc-section-number">5.6</span> <code>accept()</code>—“Thank you for calling port 3490.”</a></li>
<li><a href="#sendrecv"><span class="toc-section-number">5.7</span> <code>send()</code> and <code>recv()</code>—Talk to me, baby!</a></li>
<li><a href="#sendtorecv"><span class="toc-section-number">5.8</span> <code>sendto()</code> and <code>recvfrom()</code>—Talk to me, DGRAM-style</a></li>
<li><a href="#close-and-shutdownget-outta-my-face"><span class="toc-section-number">5.9</span> <code>close()</code> and <code>shutdown()</code>—Get outta my face!</a></li>
<li><a href="#getpeernamewho-are-you"><span class="toc-section-number">5.10</span> <code>getpeername()</code>—Who are you?</a></li>
<li><a href="#gethostnamewho-am-i"><span class="toc-section-number">5.11</span> <code>gethostname()</code>—Who am I?</a></li>
</ul></li>
<li><a href="#client-server-background"><span class="toc-section-number">6</span> Client-Server Background</a>
<ul>
<li><a href="#a-simple-stream-server"><span class="toc-section-number">6.1</span> A Simple Stream Server</a></li>
<li><a href="#a-simple-stream-client"><span class="toc-section-number">6.2</span> A Simple Stream Client</a></li>
<li><a href="#datagram"><span class="toc-section-number">6.3</span> Datagram Sockets</a></li>
</ul></li>
<li><a href="#slightly-advanced-techniques"><span class="toc-section-number">7</span> Slightly Advanced Techniques</a>
<ul>
<li><a href="#blocking"><span class="toc-section-number">7.1</span> Blocking</a></li>
<li><a href="#poll"><span class="toc-section-number">7.2</span> <code>poll()</code>—Synchronous I/O Multiplexing</a></li>
<li><a href="#select"><span class="toc-section-number">7.3</span> <code>select()</code>—Synchronous I/O Multiplexing, Old School</a></li>
<li><a href="#sendall"><span class="toc-section-number">7.4</span> Handling Partial <code>send()</code>s</a></li>
<li><a href="#serialization"><span class="toc-section-number">7.5</span> Serialization—How to Pack Data</a></li>
<li><a href="#sonofdataencap"><span class="toc-section-number">7.6</span> Son of Data Encapsulation</a></li>
<li><a href="#broadcast-packetshello-world"><span class="toc-section-number">7.7</span> Broadcast Packets—Hello, World!</a></li>
</ul></li>
<li><a href="#common-questions"><span class="toc-section-number">8</span> Common Questions</a></li>
<li><a href="#man-pages"><span class="toc-section-number">9</span> Man Pages</a>
<ul>
<li><a href="#acceptman"><span class="toc-section-number">9.1</span> <code>accept()</code></a></li>
<li><a href="#bindman"><span class="toc-section-number">9.2</span> <code>bind()</code></a></li>
<li><a href="#connectman"><span class="toc-section-number">9.3</span> <code>connect()</code></a></li>
<li><a href="#closeman"><span class="toc-section-number">9.4</span> <code>close()</code></a></li>
<li><a href="#getaddrinfoman"><span class="toc-section-number">9.5</span> <code>getaddrinfo()</code>, <code>freeaddrinfo()</code>, <code>gai_strerror()</code></a></li>
<li><a href="#gethostnameman"><span class="toc-section-number">9.6</span> <code>gethostname()</code></a></li>
<li><a href="#gethostbynameman"><span class="toc-section-number">9.7</span> <code>gethostbyname()</code>, <code>gethostbyaddr()</code></a></li>
<li><a href="#getnameinfoman"><span class="toc-section-number">9.8</span> <code>getnameinfo()</code></a></li>
<li><a href="#getpeernameman"><span class="toc-section-number">9.9</span> <code>getpeername()</code></a></li>
<li><a href="#errnoman"><span class="toc-section-number">9.10</span> <code>errno</code></a></li>
<li><a href="#fcntlman"><span class="toc-section-number">9.11</span> <code>fcntl()</code></a></li>
<li><a href="#htonsman"><span class="toc-section-number">9.12</span> <code>htons()</code>, <code>htonl()</code>, <code>ntohs()</code>, <code>ntohl()</code></a></li>
<li><a href="#inet_ntoaman"><span class="toc-section-number">9.13</span> <code>inet_ntoa()</code>, <code>inet_aton()</code>, <code>inet_addr</code></a></li>
<li><a href="#inet_ntopman"><span class="toc-section-number">9.14</span> <code>inet_ntop()</code>, <code>inet_pton()</code></a></li>
<li><a href="#listenman"><span class="toc-section-number">9.15</span> <code>listen()</code></a></li>
<li><a href="#perrorman"><span class="toc-section-number">9.16</span> <code>perror()</code>, <code>strerror()</code></a></li>
<li><a href="#pollman"><span class="toc-section-number">9.17</span> <code>poll()</code></a></li>
<li><a href="#recvman"><span class="toc-section-number">9.18</span> <code>recv()</code>, <code>recvfrom()</code></a></li>
<li><a href="#selectman"><span class="toc-section-number">9.19</span> <code>select()</code></a></li>
<li><a href="#setsockoptman"><span class="toc-section-number">9.20</span> <code>setsockopt()</code>, <code>getsockopt()</code></a></li>
<li><a href="#sendman"><span class="toc-section-number">9.21</span> <code>send()</code>, <code>sendto()</code></a></li>
<li><a href="#shutdownman"><span class="toc-section-number">9.22</span> <code>shutdown()</code></a></li>
<li><a href="#socketman"><span class="toc-section-number">9.23</span> <code>socket()</code></a></li>
<li><a href="#structsockaddrman"><span class="toc-section-number">9.24</span> <code>struct sockaddr</code> and pals</a></li>
</ul></li>
<li><a href="#more-references"><span class="toc-section-number">10</span> More References</a>
<ul>
<li><a href="#books"><span class="toc-section-number">10.1</span> Books</a></li>
<li><a href="#web-references"><span class="toc-section-number">10.2</span> Web References</a></li>
<li><a href="#rfcs"><span class="toc-section-number">10.3</span> RFCs</a></li>
</ul></li>
</ul>
</nav>
<!--
Beej's Guide to Network Programming book source

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<!--
    History:

    2.3.2:        socket man page
    2.3.3:        sockaddr_in man page
    2.3.4:        bind, listen man page
    2.3.5:        connect man page
    2.3.6:        listen, perror man page
    2.3.7:        errno man page
    2.3.8:        htonl etc man page
    2.3.9:        close man page, expanded man page leader
    2.3.10:        inet_ntoa, setsockopt man pages
    2.3.11:        getpeername man page
    2.3.12:        send/sendto man pages
    2.3.13:        shutdown man pages
    2.3.14:        gethostname man pages, fix inet_aton links
    2.3.15:        fcntl man page
    2.3.16:        recv/recvfrom man page
    2.3.17:        gethostbyname/gethostbyaddr man page
    2.3.18:        changed GET / to GET / HTTP/1.0
    2.3.19:        added select() man page
    2.3.20:        added poll() man page
    2.3.21:        section on NAT and reserved networks
    2.3.22:        typo fixes in sects "man" and "privnet"
    2.3.23:        added broadcast packets section
    2.3.24:        manpage prototype changed to code, subtitle moved out of title
    2.4.0:        big overhaul, serialization stuff
    2.4.1:        minor text changes in intro
    2.4.2:        changed all sizeofs to use variable names instead of types
    2.4.3:        fix myaddr->my_addr in listener.c, sockaddr_inman example
    2.4.4:        fix myaddr->my_addr in server.c
    2.4.5:        fix 14->18 in son of data encap
    3.0.0:        IPv6 overhaul
    3.0.1:        sa-to-sa6 typo fix
    3.0.2:        typo fixes
    3.0.3:        typo fixes
    3.0.4:        cut-n-paste errors, selectserver hints fix
    3.0.5:        typo fixes
    3.0.6:        typo fixes
    3.0.7:        typo fixes, added front matter
    3.0.8:        getpeername() code fixes
    3.0.9:        getpeername() code fixes, this time fer sure
    3.0.10:        bind() man page code fix, comment changes
    3.0.11:        socket syscall section code fix, comment changes
    3.0.12:        typos in "IP Addresses, structs, and Data Munging"
    3.0.13:        amp removals, note about errno and multithreading
    3.0.14:        type changes to listener.c, pack2.c
    3.0.15:        fix inet_pton example
    3.0.16:        fix simple server output, optlen in getsockopt man page
    3.0.17:        fix small typo
    3.0.18:        reverse perror and close calls in getaddrinfo
    3.0.19:        add notes about O_NONBLOCK with select() under Linux
    3.0.20:        fix missing .fd in poll() example
    3.0.21:        change sizeof(int) to sizeof yes
    3.0.22:     C99 updates, bug fixes, markdown
    3.0.23:     Book reference and URL updates
    3.1.0:      Section on poll()
    3.1.1:      Add WSL note, telnot
    3.1.2:      pollserver.c bugfix
    3.1.3:      Fix freeaddrinfo memleak
    3.1.4:      Fix accept example header files
    3.1.5:      Fix dgram AF_UNSPEC
-->
<!-- prevent hyphenation of the following words: -->
<!--
Don't know how to make this work with underscores. I love
you, Knuth, but... daaahm.

\hyphenation{gai_strerr}
-->
<!--
\hyphenation{inet_ntoa}
\hyphenation{inet_aton}
\hyphenation{inet_addr}
\hyphenation{inet_ntop}
\hyphenation{inet_pton}
-->
<!--
\hyphenation{sockaddr_in}
\hyphenation{in_addr}
\hyphenation{sockaddr_in6}
\hyphenation{in6_addr}
-->
<h1 data-number="1" id="intro"><span class="header-section-number">1</span> Intro</h1>
<p>Hey! Socket programming got you down? Is this stuff just a little too difficult to figure out from the <code>man</code> pages? You want to do cool Internet programming, but you don’t have time to wade through a gob of <code>struct</code>s trying to figure out if you have to call <code>bind()</code> before you <code>connect()</code>, etc., etc.</p>
<p>Well, guess what! I’ve already done this nasty business, and I’m 
dying to share the information with everyone! You’ve come to the right 
place. This document should give the average competent C programmer the 
edge s/he needs to get a grip on this networking noise.</p>
<p>And check it out: I’ve finally caught up with the future (just in the
 nick of time, too!) and have updated the Guide for IPv6! Enjoy!</p>
<h2 data-number="1.1" id="audience"><span class="header-section-number">1.1</span> Audience</h2>
<p>This document has been written as a tutorial, not a complete 
reference. It is probably at its best when read by individuals who are 
just starting out with socket programming and are looking for a 
foothold. It is certainly not the <em>complete and total</em> guide to sockets programming, by any means.</p>
<p>Hopefully, though, it’ll be just enough for those man pages to start making sense… <code>:-)</code></p>
<h2 data-number="1.2" id="platform-and-compiler"><span class="header-section-number">1.2</span> Platform and Compiler</h2>
<p>The code contained within this document was compiled on a Linux PC using Gnu’s  <code>gcc</code> compiler. It should, however, build on just about any platform that uses <code>gcc</code>. Naturally, this doesn’t apply if you’re programming for Windows—see the <a href="#windows">section on Windows programming</a>, below.</p>
<h2 data-number="1.3" id="official-homepage-and-books-for-sale"><span class="header-section-number">1.3</span> Official Homepage and Books For Sale</h2>
<p>This official location of this document is:</p>
<ul>
<li><a href="https://beej.us/guide/bgnet/"><code>https://beej.us/guide/bgnet/</code></a></li>
</ul>
<p>There you will also find example code and translations of the guide into various languages.</p>
<p>To buy nicely bound print copies (some call them “books”), visit:</p>
<ul>
<li><a href="https://beej.us/guide/url/bgbuy"><code>https://beej.us/guide/url/bgbuy</code></a></li>
</ul>
<p>I’ll appreciate the purchase because it helps sustain my document-writing lifestyle!</p>
<h2 data-number="1.4" id="solaris"><span class="header-section-number">1.4</span> Note for Solaris/SunOS Programmers</h2>
<p>When compiling for  Solaris or  SunOS, you need to specify some extra
 command-line switches for linking in the proper libraries. In order to 
do this, simply add “<code>-lnsl -lsocket -lresolv</code>” to the end of the compile command, like so:</p>
<pre><code>    $ cc -o server server.c -lnsl -lsocket -lresolv</code></pre>
<p>If you still get errors, you could try further adding a <code>-lxnet</code> to the end of that command line. I don’t know what that does, exactly, but some people seem to need it.</p>
<p>Another place that you might find problems is in the call to <code>setsockopt()</code>. The prototype differs from that on my Linux box, so instead of:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> yes=<span class="dv">1</span>;</span></code></pre></div>
<p>enter this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> yes=<span class="ch">'1'</span>;</span></code></pre></div>
<p>As I don’t have a Sun box, I haven’t tested any of the above information—it’s just what people have told me through email.</p>
<h2 data-number="1.5" id="windows"><span class="header-section-number">1.5</span> Note for Windows Programmers</h2>
<p>At this point in the guide, historically, I’ve done a bit of bagging 
on  Windows, simply due to the fact that I don’t like it very much. But I
 should really be fair and tell you that Windows has a huge install base
 and is obviously a perfectly fine operating system.</p>
<p>They say absence makes the heart grow fonder, and in this case, I 
believe it to be true. (Or maybe it’s age.) But what I can say is that 
after a decade-plus of not using Microsoft OSes for my personal work, 
I’m much happier! As such, I can sit back and safely say, “Sure, feel 
free to use Windows!” …Ok yes, it does make me grit my teeth to say 
that.</p>
<p>So I still encourage you to try  <a href="https://www.linux.com/">Linux</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, <a href="https://bsd.org/">BSD</a><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, or some flavor of Unix, instead.</p>
<p>But people like what they like, and you Windows folk will be pleased 
to know that this information is generally applicable to you guys, with a
 few minor changes, if any.</p>
<p>One cool thing you can do is install  <a href="https://cygwin.com/">Cygwin</a><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>,
 which is a collection of Unix tools for Windows. I’ve heard on the 
grapevine that doing so allows all these programs to compile unmodified.</p>
<p>Another thing that you should consider is   the <a href="https://docs.microsoft.com/en-us/windows/wsl/about">Windows Subsystem for Linux</a><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. This basically allows you to install a Linux VM-ish thing on Windows 10. That will also definitely get you situated.</p>
<p>But some of you might want to do things the Pure Windows Way. That’s 
very gutsy of you, and this is what you have to do: run out and get Unix
 immediately! No, no—I’m kidding. I’m supposed to be 
Windows-friendly(er) these days…</p>
<p>This is what you’ll have to do (unless you install <a href="https://cygwin.com/">Cygwin</a>!): first, ignore pretty much all of the system header files I mention in here. All you need to include is:</p>
<p></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;winsock.h&gt;</span></span></code></pre></div>
<p>Wait! You also have to make a call to  <code>WSAStartup()</code> before doing anything else with the sockets library. The code to do that looks something like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1"></a><span class="pp">#include </span><span class="im">&lt;winsock.h&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a>{</span>
<span id="cb5-4"><a href="#cb5-4"></a>    WSADATA wsaData;   <span class="co">// if this doesn't work</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="co">//WSAData wsaData; // then try this instead</span></span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="co">// MAKEWORD(1,1) for Winsock 1.1, MAKEWORD(2,0) for Winsock 2.0:</span></span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span class="cf">if</span> (WSAStartup(MAKEWORD(<span class="dv">1</span>,<span class="dv">1</span>), &amp;wsaData) != <span class="dv">0</span>) {</span>
<span id="cb5-10"><a href="#cb5-10"></a>        fprintf(stderr, <span class="st">"WSAStartup failed.</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb5-11"><a href="#cb5-11"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb5-12"><a href="#cb5-12"></a>    }</span></code></pre></div>
<p>You also have to tell your compiler to link in the Winsock library, usually called <code>wsock32.lib</code> or <code>winsock32.lib</code>, or <code>ws2_32.lib</code> for Winsock 2.0. Under VC++, this can be done through the <code>Project</code> menu, under <code>Settings...</code>. Click the <code>Link</code>
 tab, and look for the box titled “Object/library modules”. Add 
“wsock32.lib” (or whichever lib is your preference) to that list.</p>
<p>Or so I hear.</p>
<p>Finally, you need to call  <code>WSACleanup()</code> when you’re all through with the sockets library. See your online help for details.</p>
<p>Once you do that, the rest of the examples in this tutorial should 
generally apply, with a few exceptions. For one thing, you can’t use <code>close()</code> to close a socket—you need to use  <code>closesocket()</code>, instead. Also,  <code>select()</code> only works with socket descriptors, not file descriptors (like <code>0</code> for <code>stdin</code>).</p>
<p>There is also a socket class that you can use,  <code>CSocket</code>. Check your compilers help pages for more information.</p>
<p>To get more information about Winsock, read the  <a href="https://tangentsoft.net/wskfaq/">Winsock FAQ</a><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> and go from there.</p>
<p>Finally, I hear that Windows has no  <code>fork()</code> system call 
which is, unfortunately, used in some of my examples. Maybe you have to 
link in a POSIX library or something to get it to work, or you can use  <code>CreateProcess()</code> instead. <code>fork()</code> takes no arguments, and <code>CreateProcess()</code> takes about 48 billion arguments. If you’re not up to that, the  <code>CreateThread()</code>
 is a little easier to digest…unfortunately a discussion about 
multithreading is beyond the scope of this document. I can only talk 
about so much, you know!</p>
<h2 data-number="1.6" id="email-policy"><span class="header-section-number">1.6</span> Email Policy</h2>
<p>I’m generally available to help out with  email questions so feel 
free to write in, but I can’t guarantee a response. I lead a pretty busy
 life and there are times when I just can’t answer a question you have. 
When that’s the case, I usually just delete the message. It’s nothing 
personal; I just won’t ever have the time to give the detailed answer 
you require.</p>
<p>As a rule, the more complex the question, the less likely I am to 
respond. If you can narrow down your question before mailing it and be 
sure to include any pertinent information (like platform, compiler, 
error messages you’re getting, and anything else you think might help me
 troubleshoot), you’re much more likely to get a response. For more 
pointers, read ESR’s document, <a href="http://www.catb.org/~esr/faqs/smart-questions.html">How To Ask Questions The Smart Way</a><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
<p>If you don’t get a response, hack on it some more, try to find the 
answer, and if it’s still elusive, then write me again with the 
information you’ve found and hopefully it will be enough for me to help 
out.</p>
<p>Now that I’ve badgered you about how to write and not write me, I’d just like to let you know that I <em>fully</em>
 appreciate all the praise the guide has received over the years. It’s a
 real morale boost, and it gladdens me to hear that it is being used for
 good! <code>:-)</code> Thank you!</p>
<h2 data-number="1.7" id="mirroring"><span class="header-section-number">1.7</span> Mirroring</h2>
<p> You are more than welcome to mirror this site, whether publicly or 
privately. If you publicly mirror the site and want me to link to it 
from the main page, drop me a line at <a href="https://beej.us/guide/bgnet/html/beej@beej.us"><code>beej@beej.us</code></a>.</p>
<h2 data-number="1.8" id="note-for-translators"><span class="header-section-number">1.8</span> Note for Translators</h2>
<p> If you want to translate the guide into another language, write me at <a href="https://beej.us/guide/bgnet/html/beej@beej.us"><code>beej@beej.us</code></a> and I’ll link to your translation from the main page. Feel free to add your name and contact info to the translation.</p>
<p>This source markdown document uses UTF-8 encoding.</p>
<p>Please note the license restrictions in the <a href="#legal">Copyright, Distribution, and Legal</a> section, below.</p>
<p>If you want me to host the translation, just ask. I’ll also link to it if you want to host it; either way is fine.</p>
<h2 data-number="1.9" id="legal"><span class="header-section-number">1.9</span> Copyright, Distribution, and Legal</h2>
<p>Beej’s Guide to Network Programming is Copyright © 2019 Brian “Beej Jorgensen” Hall.</p>
<p>With specific exceptions for source code and translations, below, 
this work is licensed under the Creative Commons Attribution- 
Noncommercial- No Derivative Works 3.0 License. To view a copy of this 
license, visit</p>
<p><a href="https://creativecommons.org/licenses/by-nc-nd/3.0/"><code>https://creativecommons.org/licenses/by-nc-nd/3.0/</code></a></p>
<p>or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.</p>
<p>One specific exception to the “No Derivative Works” portion of the 
license is as follows: this guide may be freely translated into any 
language, provided the translation is accurate, and the guide is 
reprinted in its entirety. The same license restrictions apply to the 
translation as to the original guide. The translation may also include 
the name and contact information for the translator.</p>
<p>The C source code presented in this document is hereby granted to the
 public domain, and is completely free of any license restriction.</p>
<p>Educators are freely encouraged to recommend or supply copies of this guide to their students.</p>
<p>Unless otherwise mutually agreed by the parties in writing, the 
author offers the work as-is and makes no representations or warranties 
of any kind concerning the work, express, implied, statutory or 
otherwise, including, without limitation, warranties of title, 
merchantibility, fitness for a particular purpose, noninfringement, or 
the absence of latent or other defects, accuracy, or the presence of 
absence of errors, whether or not discoverable.</p>
<p>Except to the extent required by applicable law, in no event will the
 author be liable to you on any legal theory for any special, 
incidental, consequential, punitive or exemplary damages arising out of 
the use of the work, even if the author has been advised of the 
possibility of such damages.</p>
<p>Contact <a href="mailto:beej@beej.us"><code>beej@beej.us</code></a> for more information.</p>
<h2 data-number="1.10" id="dedication"><span class="header-section-number">1.10</span> Dedication</h2>
<p>Thanks to everyone who has helped in the past and future with me 
getting this guide written. And thank you to all the people who produce 
the Free software and packages that I use to make the Guide: GNU, Linux,
 Slackware, vim, Python, Inkscape, pandoc, many others. And finally a 
big thank-you to the literally thousands of you who have written in with
 suggestions for improvements and words of encouragement.</p>
<p>I dedicate this guide to some of my biggest heroes and inpirators in 
the world of computers: Donald Knuth, Bruce Schneier, W. Richard 
Stevens, and The Woz, my Readership, and the entire Free and Open Source
 Software Community.</p>
<h2 data-number="1.11" id="publishing-information"><span class="header-section-number">1.11</span> Publishing Information</h2>
<p>This book is written in Markdown using the vim editor on an Arch 
Linux box loaded with GNU tools. The cover “art” and diagrams are 
produced with Inkscape. The Markdown is converted to HTML and LaTex/PDF 
by Python, Pandoc and XeLaTeX, using Liberation fonts. The toolchain is 
composed of 100% Free and Open Source Software.</p>
<h1 data-number="2" id="what-is-a-socket"><span class="header-section-number">2</span> What is a socket?</h1>
<p>You hear talk of  “sockets” all the time, and perhaps you are 
wondering just what they are exactly. Well, they’re this: a way to speak
 to other programs using standard Unix  file descriptors.</p>
<p>What?</p>
<p>Ok—you may have heard some Unix hacker state, “Jeez, <em>everything</em>
 in Unix is a file!” What that person may have been talking about is the
 fact that when Unix programs do any sort of I/O, they do it by reading 
or writing to a file descriptor. A file descriptor is simply an integer 
associated with an open file. But (and here’s the catch), that file can 
be a network connection, a FIFO, a pipe, a terminal, a real on-the-disk 
file, or just about anything else. Everything in Unix <em>is</em> a 
file! So when you want to communicate with another program over the 
Internet you’re gonna do it through a file descriptor, you’d better 
believe it.</p>
<p>“Where do I get this file descriptor for network communication, Mr. 
Smarty-Pants?” is probably the last question on your mind right now, but
 I’m going to answer it anyway: You make a call to the  <code>socket()</code> system routine. It returns the  socket descriptor, and you communicate through it using the specialized  <code>send()</code> and  <code>recv()</code> (<a href="#sendman"><code>man send</code></a>, <a href="#recvman"><code>man recv</code></a>) socket calls.</p>
<p>“But, hey!” you might be exclaiming right about now. “If it’s a file 
descriptor, why in the name of Neptune can’t I just use the normal  <code>read()</code> and  <code>write()</code> calls to communicate through the socket?” The short answer is, “You can!” The longer answer is, “You can, but  <code>send()</code> and  <code>recv()</code> offer much greater control over your data transmission.”</p>
<p>What next? How about this: there are all kinds of sockets. There are 
 DARPA Internet addresses (Internet Sockets), path names on a local node
 (Unix Sockets), CCITT X.25 addresses (X.25 Sockets that you can safely 
ignore), and probably many others depending on which Unix flavor you 
run. This document deals only with the first: Internet Sockets.</p>
<h2 data-number="2.1" id="two-types-of-internet-sockets"><span class="header-section-number">2.1</span> Two Types of Internet Sockets</h2>
<p>What’s this?  There are two types of Internet sockets? Yes. Well, no.
 I’m lying. There are more, but I didn’t want to scare you. I’m only 
going to talk about two types here. Except for this sentence, where I’m 
going to tell you that   “Raw Sockets” are also very powerful and you 
should look them up.</p>
<p>All right, already. What are the two types? One is  “Stream Sockets”;
 the other is  “Datagram Sockets”, which may hereafter be referred to as
 “<code>SOCK_STREAM</code>” and “<code>SOCK_DGRAM</code>”, respectively. Datagram sockets are sometimes called “connectionless sockets”. (Though they can be  <code>connect()</code>’d if you really want. See <a href="#connect"><code>connect()</code></a>, below.)</p>
<p>Stream sockets are reliable two-way connected communication streams. 
If you output two items into the socket in the order “1, 2”, they will 
arrive in the order “1, 2” at the opposite end. They will also be 
error-free. I’m so certain, in fact, they will be error-free, that I’m 
just going to put my fingers in my ears and chant <em>la la la la</em> if anyone tries to claim otherwise.</p>
<p>What uses  stream sockets? Well, you may have heard of the  <code>telnet</code>
 application, yes? It uses stream sockets. All the characters you type 
need to arrive in the same order you type them, right? Also, web 
browsers use the Hypertext Transfer Protocol  (HTTP) which uses stream 
sockets to get pages. Indeed, if you telnet to a web site on port 80, 
and type “<code>GET / HTTP/1.0</code>” and hit RETURN twice, it’ll dump the HTML back at you!</p>
<blockquote>
<p>If you don’t have <code>telnet</code> installed and don’t want to install it, or your <code>telnet</code> is being picky about connecting to clients, the guide comes with a <code>telnet</code>-like program called <a href="https://beej.us/guide/bgnet/examples/telnot.c"><code>telnot</code></a><a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>. This should work well for all the needs of the guide. (Note that telnet is actually a <a href="https://tools.ietf.org/html/rfc854">spec’d networking protocol</a><a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>, and <code>telnot</code> doesn’t implement this protocol at all.)</p>
</blockquote>
<p>How do stream sockets achieve this high level of data transmission 
quality? They use a protocol called “The Transmission Control Protocol”,
 otherwise known as  “TCP” (see <a href="https://tools.ietf.org/html/rfc793">RFC 793</a><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>
 for extremely detailed info on TCP). TCP makes sure your data arrives 
sequentially and error-free. You may have heard “TCP” before as the 
better half of “TCP/IP” where  “IP” stands for “Internet Protocol” (see <a href="https://tools.ietf.org/html/rfc791">RFC 791</a><a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>). IP deals primarily with Internet routing and is not generally responsible for data integrity.</p>
<p>Cool.  What about Datagram sockets? Why are they called 
connectionless? What is the deal, here, anyway? Why are they unreliable?
 Well, here are some facts: if you send a datagram, it may arrive. It 
may arrive out of order. If it arrives, the data within the packet will 
be error-free.</p>
<p>Datagram sockets also use IP for routing, but they don’t use TCP; they use the “User Datagram Protocol”, or  “UDP” (see <a href="https://tools.ietf.org/html/rfc768">RFC 768</a><a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>).</p>
<p>Why are they connectionless? Well, basically, it’s because you don’t 
have to maintain an open connection as you do with stream sockets. You 
just build a packet, slap an IP header on it with destination 
information, and send it out. No connection needed. They are generally 
used either when a TCP stack is unavailable or when a few dropped 
packets here and there don’t mean the end of the Universe. Sample 
applications: <code>tftp</code> (trivial file transfer protocol, a little brother to FTP), <code>dhcpcd</code> (a DHCP client), multiplayer games, streaming audio, video conferencing, etc.</p>
<p>“Wait a minute! <code>tftp</code> and <code>dhcpcd</code> are used to
 transfer binary applications from one host to another! Data can’t be 
lost if you expect the application to work when it arrives! What kind of
 dark magic is this?”</p>
<p>Well, my human friend, <code>tftp</code> and similar programs have 
their own protocol on top of UDP. For example, the tftp protocol says 
that for each packet that gets sent, the recipient has to send back a 
packet that says, “I got it!” (an “ACK” packet). If the sender of the 
original packet gets no reply in, say, five seconds, he’ll re-transmit 
the packet until he finally gets an ACK. This acknowledgment procedure 
is very important when implementing reliable <code>SOCK_DGRAM</code> applications.</p>
<p>For unreliable applications like games, audio, or video, you just 
ignore the dropped packets, or perhaps try to cleverly compensate for 
them. (Quake players will know the manifestation this effect by the 
technical term: <em>accursed lag</em>. The word “accursed”, in this case, represents any extremely profane utterance.)</p>
<p>Why would you use an unreliable underlying protocol? Two reasons: 
speed and speed. It’s way faster to fire-and-forget than it is to keep 
track of what has arrived safely and make sure it’s in order and all 
that. If you’re sending chat messages, TCP is great; if you’re sending 
40 positional updates per second of the players in the world, maybe it 
doesn’t matter so much if one or two get dropped, and UDP is a good 
choice.</p>
<h2 data-number="2.2" id="lowlevel"><span class="header-section-number">2.2</span> Low level Nonsense and Network Theory</h2>
<p>Since I just mentioned layering of protocols, it’s time to talk about
 how networks really work, and to show some examples of how  <code>SOCK_DGRAM</code> packets are built. Practically, you can probably skip this section. It’s good background, however.</p>
<figure>
<embed src="Beej's%20Guide%20to%20Network%20Programming_files/dataencap.svg" title="[Encapsulated Protocols Diagram]"><figcaption aria-hidden="true">Data Encapsulation.</figcaption>
</figure>
<p>Hey, kids, it’s time to learn about  <em>Data Encapsulation</em>! 
This is very very important. It’s so important that you might just learn
 about it if you take the networks course here at Chico State <code>;-)</code>.
 Basically, it says this: a packet is born, the packet is wrapped 
(“encapsulated”) in a  header (and rarely a  footer) by the first 
protocol (say, the  TFTP protocol), then the whole thing (TFTP header 
included) is encapsulated again by the next protocol (say,  UDP), then 
again by the next  (IP), then again by the final protocol on the 
hardware (physical) layer (say,  Ethernet).</p>
<p>When another computer receives the packet, the hardware strips the 
Ethernet header, the kernel strips the IP and UDP headers, the TFTP 
program strips the TFTP header, and it finally has the data.</p>
<p>Now I can finally talk about the infamous  <em>Layered Network Model</em>
 (aka “ISO/OSI”). This Network Model describes a system of network 
functionality that has many advantages over other models. For instance, 
you can write sockets programs that are exactly the same without caring 
how the data is physically transmitted (serial, thin Ethernet, AUI, 
whatever) because programs on lower levels deal with it for you. The 
actual network hardware and topology is transparent to the socket 
programmer.</p>
<p>Without any further ado, I’ll present the layers of the full-blown model. Remember this for network class exams:</p>
<ul>
<li>Application</li>
<li>Presentation</li>
<li>Session</li>
<li>Transport</li>
<li>Network</li>
<li>Data Link</li>
<li>Physical</li>
</ul>
<p>The Physical Layer is the hardware (serial, Ethernet, etc.). The 
Application Layer is just about as far from the physical layer as you 
can imagine—it’s the place where users interact with the network.</p>
<p>Now, this model is so general you could probably use it as an 
automobile repair guide if you really wanted to. A layered model more 
consistent with Unix might be:</p>
<ul>
<li>Application Layer (<em>telnet, ftp, etc.</em>)</li>
<li>Host-to-Host Transport Layer (<em>TCP, UDP</em>)</li>
<li>Internet Layer (<em>IP and routing</em>)</li>
<li>Network Access Layer (<em>Ethernet, wi-fi, or whatever</em>)</li>
</ul>
<p>At this point in time, you can probably see how these layers correspond to the encapsulation of the original data.</p>
<p>See how much work there is in building a simple packet? Jeez! And you have to type in the packet headers yourself using “<code>cat</code>”! Just kidding. All you have to do for stream sockets is  <code>send()</code> the data out. All you have to do for datagram sockets is encapsulate the packet in the method of your choosing and  <code>sendto()</code>
 it out. The kernel builds the Transport Layer and Internet Layer on for
 you and the hardware does the Network Access Layer. Ah, modern 
technology.</p>
<p>So ends our brief foray into network theory. Oh yes, I forgot to tell
 you everything I wanted to say about routing: nothing! That’s right, 
I’m not going to talk about it at all. The router strips the packet to 
the IP header, consults its routing table,  <em>blah blah blah</em>. Check out the <a href="https://tools.ietf.org/html/rfc791">IP RFC</a><a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> if you really really care. If you never learn about it, well, you’ll live.</p>
<h1 data-number="3" id="ip-addresses-structs-and-data-munging"><span class="header-section-number">3</span> IP Addresses, <code>struct</code>s, and Data Munging</h1>
<p>Here’s the part of the game where we get to talk code for a change.</p>
<p>But first, let’s discuss more non-code! Yay! First I want to talk 
about  IP addresses and ports for just a tad so we have that sorted out.
 Then we’ll talk about how the sockets API stores and manipulates IP 
addresses and other data.</p>
<h2 data-number="3.1" id="ip-addresses-versions-4-and-6"><span class="header-section-number">3.1</span> IP Addresses, versions 4 and 6</h2>
<p>In the good old days back when Ben Kenobi was still called Obi Wan 
Kenobi, there was a wonderful network routing system called The Internet
 Protocol Version 4, also called  IPv4. It had addresses made up of four
 bytes (A.K.A. four “octets”), and was commonly written in “dots and 
numbers” form, like so: <code>192.0.2.111</code>.</p>
<p>You’ve probably seen it around.</p>
<p>In fact, as of this writing, virtually every site on the Internet uses IPv4.</p>
<p>Everyone, including Obi Wan, was happy. Things were great, until some
 naysayer by the name of Vint Cerf warned everyone that we were about to
 run out of IPv4 addresses!</p>
<p>(Besides warning everyone of the Coming IPv4 Apocalypse Of Doom And Gloom,  <a href="https://en.wikipedia.org/wiki/Vint_Cerf">Vint Cerf</a><a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> is also well-known for being The Father Of The Internet. So I really am in no position to second-guess his judgment.)</p>
<p>Run out of addresses? How could this be? I mean, there are like 
billions of IP addresses in a 32-bit IPv4 address. Do we really have 
billions of computers out there?</p>
<p>Yes.</p>
<p>Also, in the beginning, when there were only a few computers and 
everyone thought a billion was an impossibly large number, some big 
organizations were generously allocated millions of IP addresses for 
their own use. (Such as Xerox, MIT, Ford, HP, IBM, GE, AT&amp;T, and 
some little company called Apple, to name a few.)</p>
<p>In fact, if it weren’t for several stopgap measures, we would have run out a long time ago.</p>
<p>But now we’re living in an era where we’re talking about every human 
having an IP address, every computer, every calculator, every phone, 
every parking meter, and (why not) every puppy dog, as well.</p>
<p>And so,  IPv6 was born. Since Vint Cerf is probably immortal (even if
 his physical form should pass on, heaven forbid, he is probably already
 existing as some kind of hyper-intelligent <a href="https://en.wikipedia.org/wiki/ELIZA">ELIZA</a><a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>
 program out in the depths of the Internet2), no one wants to have to 
hear him say again “I told you so” if we don’t have enough addresses in 
the next version of the Internet Protocol.</p>
<p>What does this suggest to you?</p>
<p>That we need a <em>lot</em> more addresses. That we need not just 
twice as many addresses, not a billion times as many, not a thousand 
trillion times as many, but <em>79 MILLION BILLION TRILLION times as many possible addresses!</em> That’ll show ’em!</p>
<p>You’re saying, “Beej, is that true? I have every reason to disbelieve
 large numbers.” Well, the difference between 32 bits and 128 bits might
 not sound like a lot; it’s only 96 more bits, right? But remember, 
we’re talking powers here: 32 bits represents some 4 billion numbers (2<sup>32</sup>), while 128 bits represents about 340 trillion trillion trillion numbers (for real, 2<sup>128</sup>). That’s like a million IPv4 Internets for <em>every single star in the Universe</em>.</p>
<p>Forget this dots-and-numbers look of IPv4, too; now we’ve got a 
hexadecimal representation, with each two-byte chunk separated by a 
colon, like this:</p>
<pre><code>    2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551</code></pre>
<p>That’s not all! Lots of times, you’ll have an IP address with lots of
 zeros in it, and you can compress them between two colons. And you can 
leave off leading zeros for each byte pair. For instance, each of these 
pairs of addresses are equivalent:</p>
<pre><code>    2001:0db8:c9d2:0012:0000:0000:0000:0051
    2001:db8:c9d2:12::51
    
    2001:0db8:ab00:0000:0000:0000:0000:0000
    2001:db8:ab00::
    
    0000:0000:0000:0000:0000:0000:0000:0001
    ::1</code></pre>
<p>The address <code>::1</code> is the <em>loopback address</em>. It always means “this machine I’m running on now”. In IPv4, the loopback address is <code>127.0.0.1</code>.</p>
<p>Finally, there’s an IPv4-compatibility mode for IPv6 addresses that 
you might come across. If you want, for example, to represent the IPv4 
address <code>192.0.2.33</code> as an IPv6 address, you use the following notation: “<code>::ffff:192.0.2.33</code>”.</p>
<p>We’re talking serious fun.</p>
<p>In fact, it’s such serious fun, that the Creators of IPv6 have quite 
cavalierly lopped off trillions and trillions of addresses for reserved 
use, but we have so many, frankly, who’s even counting anymore? There 
are plenty left over for every man, woman, child, puppy, and parking 
meter on every planet in the galaxy. And believe me, every planet in the
 galaxy has parking meters. You know it’s true.</p>
<h3 data-number="3.1.1" id="subnets"><span class="header-section-number">3.1.1</span> Subnets</h3>
<p>For organizational reasons, it’s sometimes convenient to declare that
 "this first part of this IP address up through this bit is the <em>network portion</em> of the IP address, and the remainder is the <em>host portion</em>.</p>
<p>For instance, with IPv4, you might have <code>192.0.2.12</code>, and 
we could say that the first three bytes are the network and the last 
byte was the host. Or, put another way, we’re talking about host <code>12</code> on network <code>192.0.2.0</code> (see how we zero out the byte that was the host).</p>
<p>And now for more outdated information! Ready? In the Ancient Times, 
there were “classes” of subnets, where the first one, two, or three 
bytes of the address was the network part. If you were lucky enough to 
have one byte for the network and three for the host, you could have 24 
bits-worth of hosts on your network (16 million or so). That was a 
“Class A” network. On the opposite end was a “Class C”, with three bytes
 of network, and one byte of host (256 hosts, minus a couple that were 
reserved).</p>
<p>So as you can see, there were just a few Class As, a huge pile of Class Cs, and some Class Bs in the middle.</p>
<p>The network portion of the IP address is described by something called the <em>netmask</em>, which you bitwise-AND with the IP address to get the network number out of it. The netmask usually looks something like <code>255.255.255.0</code>. (E.g. with that netmask, if your IP is <code>192.0.2.12</code>, then your network is <code>192.0.2.12</code> AND <code>255.255.255.0</code> which gives <code>192.0.2.0</code>.)</p>
<p>Unfortunately, it turned out that this wasn’t fine-grained enough for
 the eventual needs of the Internet; we were running out of Class C 
networks quite quickly, and we were most definitely out of Class As, so 
don’t even bother to ask. To remedy this, The Powers That Be allowed for
 the netmask to be an arbitrary number of bits, not just 8, 16, or 24. 
So you might have a netmask of, say <code>255.255.255.252</code>, which is 30 bits of network, and 2 bits of host allowing for four hosts on the network. (Note that the netmask is <em>ALWAYS</em> a bunch of 1-bits followed by a bunch of 0-bits.)</p>
<p>But it’s a bit unwieldy to use a big string of numbers like <code>255.192.0.0</code>
 as a netmask. First of all, people don’t have an intuitive idea of how 
many bits that is, and secondly, it’s really not compact. So the New 
Style came along, and it’s much nicer. You just put a slash after the IP
 address, and then follow that by the number of network bits in decimal.
 Like this: <code>192.0.2.12/30</code>.</p>
<p>Or, for IPv6, something like this: <code>2001:db8::/32</code> or <code>2001:db8:5413:4028::9db9/64</code>.</p>
<h3 data-number="3.1.2" id="port-numbers"><span class="header-section-number">3.1.2</span> Port Numbers</h3>
<p>If you’ll kindly remember, I presented you earlier with the <a href="#lowlevel">Layered Network Model</a>
 which had the Internet Layer (IP) split off from the Host-to-Host 
Transport Layer (TCP and UDP). Get up to speed on that before the next 
paragraph.</p>
<p>Turns out that besides an IP address (used by the IP layer), there is
 another address that is used by TCP (stream sockets) and, 
coincidentally, by UDP (datagram sockets). It is the <em>port number</em>. It’s a 16-bit number that’s like the local address for the connection.</p>
<p>Think of the IP address as the street address of a hotel, and the 
port number as the room number. That’s a decent analogy; maybe later 
I’ll come up with one involving the automobile industry.</p>
<p>Say you want to have a computer that handles incoming mail AND web 
services—how do you differentiate between the two on a computer with a 
single IP address?</p>
<p>Well, different services on the Internet have different well-known port numbers. You can see them all in <a href="https://www.iana.org/assignments/port-numbers">the Big IANA Port List</a><a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> or, if you’re on a Unix box, in your <code>/etc/services</code> file. HTTP (the web) is port 80, telnet is port 23, SMTP is port 25, the game <a href="https://en.wikipedia.org/wiki/Doom_(1993_video_game)">DOOM</a><a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a> used port 666, etc. and so on. Ports under 1024 are often considered special, and usually require special OS privileges to use.</p>
<p>And that’s about it!</p>
<h2 data-number="3.2" id="byte-order"><span class="header-section-number">3.2</span> Byte Order</h2>
<p> By Order of the Realm! There shall be two byte orderings, hereafter to be known as Lame and Magnificent!</p>
<p>I joke, but one really is better than the other. <code>:-)</code></p>
<p>There really is no easy way to say this, so I’ll just blurt it out: 
your computer might have been storing bytes in reverse order behind your
 back. I know! No one wanted to have to tell you.</p>
<p>The thing is, everyone in the Internet world has generally agreed that if you want to represent the two-byte hex number, say <code>b34f</code>, you’ll store it in two sequential bytes <code>b3</code> followed by <code>4f</code>. Makes sense, and, as <a href="https://en.wikipedia.org/wiki/Wilford_Brimley">Wilford Brimley</a><a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a> would tell you, it’s the Right Thing To Do. This number, stored with the big end first, is called <em>Big-Endian</em>.</p>
<p>Unfortunately, a <em>few</em> computers scattered here and there 
throughout the world, namely anything with an Intel or Intel-compatible 
processor, store the bytes reversed, so <code>b34f</code> would be stored in memory as the sequential bytes <code>4f</code> followed by <code>b3</code>. This storage method is called <em>Little-Endian</em>.</p>
<p>But wait, I’m not done with terminology yet! The more-sane <em>Big-Endian</em> is also called <em>Network Byte Order</em> because that’s the order us network types like.</p>
<p>Your computer stores numbers in <em>Host Byte Order</em>. If it’s an 
Intel 80x86, Host Byte Order is Little-Endian. If it’s a Motorola 68k, 
Host Byte Order is Big-Endian. If it’s a PowerPC, Host Byte Order is… 
well, it depends!</p>
<p>A lot of times when you’re building packets or filling out data 
structures you’ll need to make sure your two- and four-byte numbers are 
in Network Byte Order. But how can you do this if you don’t know the 
native Host Byte Order?</p>
<p>Good news! You just get to assume the Host Byte Order isn’t right, 
and you always run the value through a function to set it to Network 
Byte Order. The function will do the magic conversion if it has to, and 
this way your code is portable to machines of differing endianness.</p>
<p>All righty. There are two types of numbers that you can convert: <code>short</code> (two bytes) and <code>long</code> (four bytes). These functions work for the <code>unsigned</code> variations as well. Say you want to convert a <code>short</code>
 from Host Byte Order to Network Byte Order. Start with “h” for “host”, 
follow it with “to”, then “n” for “network”, and “s” for “short”: 
h-to-n-s, or <code>htons()</code> (read: “Host to Network Short”).</p>
<p>It’s almost too easy…</p>
<p>You can use every combination of “n”, “h”, “s”, and “l” you want, not
 counting the really stupid ones. For example, there is NOT a <code>stolh()</code> (“Short to Long Host”) function—not at this party, anyway. But there are:</p>
<p>   </p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>htons()</code></td>
<td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>s</code>hort</td>
</tr>
<tr class="even">
<td><code>htonl()</code></td>
<td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>l</code>ong</td>
</tr>
<tr class="odd">
<td><code>ntohs()</code></td>
<td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>s</code>hort</td>
</tr>
<tr class="even">
<td><code>ntohl()</code></td>
<td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>l</code>ong</td>
</tr>
</tbody>
</table>
<p>Basically, you’ll want to convert the numbers to Network Byte Order 
before they go out on the wire, and convert them to Host Byte Order as 
they come in off the wire.</p>
<p>I don’t know of a 64-bit variant, sorry. And if you want to do floating point, check out the section on <a href="#serialization">Serialization</a>, far below.</p>
<p>Assume the numbers in this document are in Host Byte Order unless I say otherwise.</p>
<h2 data-number="3.3" id="structs"><span class="header-section-number">3.3</span> <code>struct</code>s</h2>
<p>Well, we’re finally here. It’s time to talk about programming. In 
this section, I’ll cover various data types used by the sockets 
interface, since some of them are a real bear to figure out.</p>
<p>First the easy one: a  socket descriptor. A socket descriptor is the following type:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span></span></code></pre></div>
<p>Just a regular <code>int</code>.</p>
<p>Things get weird from here, so just read through and bear with me.</p>
<p>My First Struct™—<code>struct addrinfo</code>.  This structure is a 
more recent invention, and is used to prep the socket address structures
 for subsequent use. It’s also used in host name lookups, and service 
name lookups. That’ll make more sense later when we get to actual usage,
 but just know for now that it’s one of the first things you’ll call 
when making a connection.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> addrinfo {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>              ai_flags;     <span class="co">// AI_PASSIVE, AI_CANONNAME, etc.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>              ai_family;    <span class="co">// AF_INET, AF_INET6, AF_UNSPEC</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>              ai_socktype;  <span class="co">// SOCK_STREAM, SOCK_DGRAM</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>              ai_protocol;  <span class="co">// use 0 for "any"</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span>           ai_addrlen;   <span class="co">// size of ai_addr in bytes</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> sockaddr *ai_addr;      <span class="co">// struct sockaddr_in or _in6</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span>            *ai_canonname; <span class="co">// full canonical hostname</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> addrinfo *ai_next;      <span class="co">// linked list, next node</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    };</span></code></pre></div>
<p>You’ll load this struct up a bit, and then call  <code>getaddrinfo()</code>. It’ll return a pointer to a new linked list of these structures filled out with all the goodies you need.</p>
<p>You can force it to use IPv4 or IPv6 in the <code>ai_family</code> field, or leave it as <code>AF_UNSPEC</code> to use whatever. This is cool because your code can be IP version-agnostic.</p>
<p>Note that this is a linked list: <code>ai_next</code> points at the 
next element—there could be several results for you to choose from. I’d 
use the first result that worked, but you might have different business 
needs; I don’t know everything, man!</p>
<p>You’ll see that the <code>ai_addr</code> field in the <code>struct addrinfo</code> is a pointer to a  <code>struct sockaddr</code>. This is where we start getting into the nitty-gritty details of what’s inside an IP address structure.</p>
<p>You might not usually need to write to these structures; oftentimes, a call to <code>getaddrinfo()</code> to fill out your <code>struct addrinfo</code> for you is all you’ll need. You <em>will</em>, however, have to peer inside these <code>struct</code>s to get the values out, so I’m presenting them here.</p>
<p>(Also, all the code written before <code>struct addrinfo</code> was 
invented we packed all this stuff by hand, so you’ll see a lot of IPv4 
code out in the wild that does exactly that. You know, in old versions 
of this guide and so on.)</p>
<p>Some <code>struct</code>s are IPv4, some are IPv6, and some are both. I’ll make notes of which are what.</p>
<p>Anyway, the <code>struct sockaddr</code> holds socket address information for many types of sockets.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sockaddr {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">short</span>    sa_family;    <span class="co">// address family, AF_xxx</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span>              sa_data[<span class="dv">14</span>];  <span class="co">// 14 bytes of protocol address</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    }; </span></code></pre></div>
<p><code>sa_family</code> can be a variety of things, but it’ll be  <code>AF_INET</code> (IPv4) or  <code>AF_INET6</code> (IPv6) for everything we do in this document. <code>sa_data</code>
 contains a destination address and port number for the socket. This is 
rather unwieldy since you don’t want to tediously pack the address in 
the <code>sa_data</code> by hand.</p>
<p>To deal with <code>struct sockaddr</code>, programmers created a parallel structure:  <code>struct sockaddr_in</code> (“in” for “Internet”) to be used with IPv4.</p>
<p>And <em>this is the important</em> bit: a pointer to a <code>struct sockaddr_in</code> can be cast to a pointer to a <code>struct sockaddr</code> and vice-versa. So even though <code>connect()</code> wants a <code>struct sockaddr*</code>, you can still use a <code>struct sockaddr_in</code> and cast it at the last minute!</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// (IPv4 only--see struct sockaddr_in6 for IPv6)</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sockaddr_in {</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">short</span> <span class="dt">int</span>          sin_family;  <span class="co">// Address family, AF_INET</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">short</span> <span class="dt">int</span> sin_port;    <span class="co">// Port number</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> in_addr     sin_addr;    <span class="co">// Internet address</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">char</span>      sin_zero[<span class="dv">8</span>]; <span class="co">// Same size as struct sockaddr</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    };</span></code></pre></div>
<p>This structure makes it easy to reference elements of the socket address. Note that <code>sin_zero</code> (which is included to pad the structure to the length of a <code>struct sockaddr</code>) should be set to all zeros with the function <code>memset()</code>. Also, notice that <code>sin_family</code> corresponds to <code>sa_family</code> in a <code>struct sockaddr</code> and should be set to “<code>AF_INET</code>”. Finally, the <code>sin_port</code> must be in  <em>Network Byte Order</em> (by using  <code>htons()</code>!)</p>
<p>Let’s dig deeper! You see the <code>sin_addr</code> field is a <code>struct in_addr</code>. What is that thing? Well, not to be overly dramatic, but it’s one of the scariest unions of all time:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// (IPv4 only--see struct in6_addr for IPv6)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Internet address (a structure for historical reasons)</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> in_addr {</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span> s_addr; <span class="co">// that's a 32-bit int (4 bytes)</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    };</span></code></pre></div>
<p>Whoa! Well, it <em>used</em> to be a union, but now those days seem to be gone. Good riddance. So if you have declared <code>ina</code> to be of type <code>struct sockaddr_in</code>, then <code>ina.sin_addr.s_addr</code> references the 4-byte IP address (in Network Byte Order). Note that even if your system still uses the God-awful union for <code>struct in_addr</code>, you can still reference the 4-byte IP address in exactly the same way as I did above (this due to <code>#define</code>s).</p>
<p>What about  IPv6? Similar <code>struct</code>s exist for it, as well:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// (IPv6 only--see struct sockaddr_in and struct in_addr for IPv4)</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sockaddr_in6 {</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        u_int16_t       sin6_family;   <span class="co">// address family, AF_INET6</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        u_int16_t       sin6_port;     <span class="co">// port number, Network Byte Order</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        u_int32_t       sin6_flowinfo; <span class="co">// IPv6 flow information</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> in6_addr sin6_addr;     <span class="co">// IPv6 address</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        u_int32_t       sin6_scope_id; <span class="co">// Scope ID</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> in6_addr {</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">char</span>   s6_addr[<span class="dv">16</span>];   <span class="co">// IPv6 address</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    };</span></code></pre></div>
<p>Note that IPv6 has an IPv6 address and a port number, just like IPv4 has an IPv4 address and a port number.</p>
<p>Also note that I’m not going to talk about the IPv6 flow information 
or Scope ID fields for the moment… this is just a starter guide. <code>:-)</code></p>
<p>Last but not least, here is another simple structure, <code>struct sockaddr_storage</code>
 that is designed to be large enough to hold both IPv4 and IPv6 
structures. See, for some calls, sometimes you don’t know in advance if 
it’s going to fill out your <code>struct sockaddr</code> with an IPv4 or IPv6 address. So you pass in this parallel structure, very similar to <code>struct sockaddr</code> except larger, and then cast it to the type you need:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sockaddr_storage {</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>        sa_family_t  ss_family;     <span class="co">// address family</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// all this is padding, implementation specific, ignore it:</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span>      __ss_pad1[_SS_PAD1SIZE];</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int64_t</span>   __ss_align;</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span>      __ss_pad2[_SS_PAD2SIZE];</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    };</span></code></pre></div>
<p>What’s important is that you can see the address family in the <code>ss_family</code> field—check this to see if it’s <code>AF_INET</code> or <code>AF_INET6</code> (for IPv4 or IPv6). Then you can cast it to a <code>struct sockaddr_in</code> or <code>struct sockaddr_in6</code> if you wanna.</p>
<h2 data-number="3.4" id="ip-addresses-part-deux"><span class="header-section-number">3.4</span> IP Addresses, Part Deux</h2>
<p>Fortunately for you, there are a bunch of functions that allow you to
 manipulate  IP addresses. No need to figure them out by hand and stuff 
them in a <code>long</code> with the <code>&lt;&lt;</code> operator.</p>
<p>First, let’s say you have a <code>struct sockaddr_in ina</code>, and you have an IP address “<code>10.12.110.57</code>” or “<code>2001:db8:63b3:1::3490</code>” that you want to store into it. The function you want to use,  <code>inet_pton()</code>, converts an IP address in numbers-and-dots notation into either a <code>struct in_addr</code> or a <code>struct in6_addr</code> depending on whether you specify <code>AF_INET</code> or <code>AF_INET6</code>. (“<code>pton</code>”
 stands for “presentation to network”—you can call it “printable to 
network” if that’s easier to remember.) The conversion can be made as 
follows:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sockaddr_in sa; <span class="co">// IPv4</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sockaddr_in6 sa6; <span class="co">// IPv6</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    inet_pton(AF_INET, <span class="st">"10.12.110.57"</span>, &amp;(sa.sin_addr)); <span class="co">// IPv4</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    inet_pton(AF_INET6, <span class="st">"2001:db8:63b3:1::3490"</span>, &amp;(sa6.sin6_addr)); <span class="co">// IPv6</span></span></code></pre></div>
<p>(Quick note: the old way of doing things used a function called  <code>inet_addr()</code> or another function called  <code>inet_aton()</code>; these are now obsolete and don’t work with IPv6.)</p>
<p>Now, the above code snippet isn’t very robust because there is no error checking. See, <code>inet_pton()</code> returns <code>-1</code> on error, or 0 if the address is messed up. So check to make sure the result is greater than 0 before using!</p>
<p>All right, now you can convert string IP addresses to their binary 
representations. What about the other way around? What if you have a <code>struct in_addr</code> and you want to print it in numbers-and-dots notation? (Or a <code>struct in6_addr</code> that you want in, uh, “hex-and-colons” notation.) In this case, you’ll want to use the function  <code>inet_ntop()</code> (“ntop” means “network to presentation”—you can call it “network to printable” if that’s easier to remember), like this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1"></a><span class="co">// IPv4:</span></span>
<span id="cb16-2"><a href="#cb16-2"></a></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="dt">char</span> ip4[INET_ADDRSTRLEN];  <span class="co">// space to hold the IPv4 string</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="kw">struct</span> sockaddr_in sa;      <span class="co">// pretend this is loaded with something</span></span>
<span id="cb16-5"><a href="#cb16-5"></a></span>
<span id="cb16-6"><a href="#cb16-6"></a>inet_ntop(AF_INET, &amp;(sa.sin_addr), ip4, INET_ADDRSTRLEN);</span>
<span id="cb16-7"><a href="#cb16-7"></a></span>
<span id="cb16-8"><a href="#cb16-8"></a>printf(<span class="st">"The IPv4 address is: %s</span><span class="sc">\n</span><span class="st">"</span>, ip4);</span>
<span id="cb16-9"><a href="#cb16-9"></a></span>
<span id="cb16-10"><a href="#cb16-10"></a></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="co">// IPv6:</span></span>
<span id="cb16-12"><a href="#cb16-12"></a></span>
<span id="cb16-13"><a href="#cb16-13"></a><span class="dt">char</span> ip6[INET6_ADDRSTRLEN]; <span class="co">// space to hold the IPv6 string</span></span>
<span id="cb16-14"><a href="#cb16-14"></a><span class="kw">struct</span> sockaddr_in6 sa6;    <span class="co">// pretend this is loaded with something</span></span>
<span id="cb16-15"><a href="#cb16-15"></a></span>
<span id="cb16-16"><a href="#cb16-16"></a>inet_ntop(AF_INET6, &amp;(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN);</span>
<span id="cb16-17"><a href="#cb16-17"></a></span>
<span id="cb16-18"><a href="#cb16-18"></a>printf(<span class="st">"The address is: %s</span><span class="sc">\n</span><span class="st">"</span>, ip6);</span></code></pre></div>
<p>When you call it, you’ll pass the address type (IPv4 or IPv6), the 
address, a pointer to a string to hold the result, and the maximum 
length of that string. (Two macros conveniently hold the size of the 
string you’ll need to hold the largest IPv4 or IPv6 address: <code>INET_ADDRSTRLEN</code> and <code>INET6_ADDRSTRLEN</code>.)</p>
<p>(Another quick note to mention once again the old way of doing 
things: the historical function to do this conversion was called  <code>inet_ntoa()</code>. It’s also obsolete and won’t work with IPv6.)</p>
<p>Lastly, these functions only work with numeric IP addresses—they won’t do any nameserver DNS lookup on a hostname, like “<code>www.example.com</code>”. You will use <code>getaddrinfo()</code> to do that, as you’ll see later on.</p>
<h3 data-number="3.4.1" id="private-or-disconnected-networks"><span class="header-section-number">3.4.1</span> Private (Or Disconnected) Networks</h3>
<p> Lots of places have a  firewall that hides the network from the rest
 of the world for their own protection. And often times, the firewall 
translates “internal” IP addresses to “external” (that everyone else in 
the world knows) IP addresses using a process called <em>Network Address Translation</em>, or  NAT.</p>
<p>Are you getting nervous yet? “Where’s he going with all this weird stuff?”</p>
<p>Well, relax and buy yourself a non-alcoholic (or alcoholic) drink, 
because as a beginner, you don’t even have to worry about NAT, since 
it’s done for you transparently. But I wanted to talk about the network 
behind the firewall in case you started getting confused by the network 
numbers you were seeing.</p>
<p>For instance, I have a firewall at home. I have two static IPv4 
addresses allocated to me by the DSL company, and yet I have seven 
computers on the network. How is this possible? Two computers can’t 
share the same IP address, or else the data wouldn’t know which one to 
go to!</p>
<p>The answer is: they don’t share the same IP addresses. They are on a 
private network with 24 million IP addresses allocated to it. They are 
all just for me. Well, all for me as far as anyone else is concerned. 
Here’s what’s happening:</p>
<p>If I log into a remote computer, it tells me I’m logged in from 
192.0.2.33 which is the public IP address my ISP has provided to me. But
 if I ask my local computer what its IP address is, it says 10.0.0.5. 
Who is translating the IP address from one to the other? That’s right, 
the firewall! It’s doing NAT!</p>
<p><code>10.x.x.x</code> is one of a few reserved networks that are only
 to be used either on fully disconnected networks, or on networks that 
are behind firewalls. The details of which private network numbers are 
available for you to use are outlined in <a href="https://tools.ietf.org/html/rfc1918">RFC 1918</a><a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>, but some common ones you’ll see are  <code>10.x.x.x</code> and  <code>192.168.x.x</code>, where <code>x</code> is 0-255, generally. Less common is <code>172.y.x.x</code>, where <code>y</code> goes between 16 and 31.</p>
<p>Networks behind a NATing firewall don’t <em>need</em> to be on one of these reserved networks, but they commonly are.</p>
<p>(Fun fact! My external IP address isn’t really <code>192.0.2.33</code>. The <code>192.0.2.x</code> network is reserved for make-believe “real” IP addresses to be used in documentation, just like this guide! Wowzers!)</p>
<p> IPv6 has private networks, too, in a sense. They’ll start with <code>fdXX:</code> (or maybe in the future <code>fcXX:</code>), as per <a href="https://tools.ietf.org/html/rfc4193">RFC 4193</a><a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>.
 NAT and IPv6 don’t generally mix, however (unless you’re doing the IPv6
 to IPv4 gateway thing which is beyond the scope of this document)—in 
theory you’ll have so many addresses at your disposal that you won’t 
need to use NAT any longer. But if you want to allocate addresses for 
yourself on a network that won’t route outside, this is how to do it.</p>
<h1 data-number="4" id="jumping-from-ipv4-to-ipv6"><span class="header-section-number">4</span> Jumping from IPv4 to IPv6</h1>
<p> But I just want to know what to change in my code to get it going with IPv6! Tell me now!</p>
<p>Ok! Ok!</p>
<p>Almost everything in here is something I’ve gone over, above, but 
it’s the short version for the impatient. (Of course, there is more than
 this, but this is what applies to the guide.)</p>
<ol type="1">
<li><p>First of all, try to use  <a href="#structs"><code>getaddrinfo()</code></a> to get all the <code>struct sockaddr</code>
 info, instead of packing the structures by hand. This will keep you IP 
version-agnostic, and will eliminate many of the subsequent steps.</p></li>
<li><p>Any place that you find you’re hard-coding anything related to the IP version, try to wrap up in a helper function.</p></li>
<li><p>Change <code>AF_INET</code> to <code>AF_INET6</code>.</p></li>
<li><p>Change <code>PF_INET</code> to <code>PF_INET6</code>.</p></li>
<li><p>Change <code>INADDR_ANY</code> assignments to <code>in6addr_any</code> assignments, which are slightly different:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sockaddr_in sa;</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sockaddr_in6 sa6;</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    sa.sin_addr.s_addr = INADDR_ANY;  <span class="co">// use my IPv4 address</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    sa6.sin6_addr = in6addr_any; <span class="co">// use my IPv6 address</span></span></code></pre></div>
<p>Also, the value <code>IN6ADDR_ANY_INIT</code> can be used as an initializer when the <code>struct in6_addr</code> is declared, like so:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> in6_addr ia6 = IN6ADDR_ANY_INIT;</span></code></pre></div></li>
<li><p>Instead of <code>struct sockaddr_in</code> use <code>struct sockaddr_in6</code>, being sure to add “6” to the fields as appropriate (see <a href="#structs"><code>struct</code>s</a>, above). There is no <code>sin6_zero</code> field.</p></li>
<li><p>Instead of <code>struct in_addr</code> use <code>struct in6_addr</code>, being sure to add “6” to the fields as appropriate (see <a href="#structs"><code>struct</code>s</a>, above).</p></li>
<li><p>Instead of <code>inet_aton()</code> or <code>inet_addr()</code>, use <code>inet_pton()</code>.</p></li>
<li><p>Instead of <code>inet_ntoa()</code>, use <code>inet_ntop()</code>.</p></li>
<li><p>Instead of <code>gethostbyname()</code>, use the superior <code>getaddrinfo()</code>.</p></li>
<li><p>Instead of <code>gethostbyaddr()</code>, use the superior  <code>getnameinfo()</code> (although <code>gethostbyaddr()</code> can still work with IPv6).</p></li>
<li><p><code>INADDR_BROADCAST</code> no longer works. Use IPv6 multicast instead.</p></li>
</ol>
<p><em>Et voila</em>!</p>
<h1 data-number="5" id="system-calls-or-bust"><span class="header-section-number">5</span> System Calls or Bust</h1>
<p>This is the section where we get into the system calls (and other 
library calls) that allow you to access the network functionality of a 
Unix box, or any box that supports the sockets API for that matter (BSD,
 Windows, Linux, Mac, what-have-you.) When you call one of these 
functions, the kernel takes over and does all the work for you 
automagically.</p>
<p>The place most people get stuck around here is what order to call these things in. In that, the <code>man</code>
 pages are no use, as you’ve probably discovered. Well, to help with 
that dreadful situation, I’ve tried to lay out the system calls in the 
following sections in <em>exactly</em> (approximately) the same order that you’ll need to call them in your programs.</p>
<p>That, coupled with a few pieces of sample code here and there, some 
milk and cookies (which I fear you will have to supply yourself), and 
some raw guts and courage, and you’ll be beaming data around the 
Internet like the Son of Jon Postel!</p>
<p><em>(Please note that for brevity, many code snippets below do not 
include necessary error checking. And they very commonly assume that the
 result from calls to <code>getaddrinfo()</code> succeed and return a 
valid entry in the linked list. Both of these situations are properly 
addressed in the stand-alone programs, though, so use those as a model.)</em></p>
<h2 data-number="5.1" id="getaddrinfoprepare-to-launch"><span class="header-section-number">5.1</span> <code>getaddrinfo()</code>—Prepare to launch!</h2>
<p> This is a real workhorse of a function with a lot of options, but usage is actually pretty simple. It helps set up the <code>struct</code>s you need later on.</p>
<p>A tiny bit of history: it used to be that you would use a function called <code>gethostbyname()</code> to do DNS lookups. Then you’d load that information by hand into a <code>struct sockaddr_in</code>, and use that in your calls.</p>
<p>This is no longer necessary, thankfully. (Nor is it desirable, if you
 want to write code that works for both IPv4 and IPv6!) In these modern 
times, you now have the function <code>getaddrinfo()</code> that does all kinds of good stuff for you, including DNS and service name lookups, and fills out the <code>struct</code>s you need, besides!</p>
<p>Let’s take a look!</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> getaddrinfo(<span class="dt">const</span> <span class="dt">char</span> *node,     <span class="co">// e.g. "www.example.com" or IP</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">const</span> <span class="dt">char</span> *service,  <span class="co">// e.g. "http" or port number</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">const</span> <span class="kw">struct</span> addrinfo *hints,</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">struct</span> addrinfo **res);</span></code></pre></div>
<p>You give this function three input parameters, and it gives you a pointer to a linked-list, <code>res</code>, of results.</p>
<p>The <code>node</code> parameter is the host name to connect to, or an IP address.</p>
<p>Next is the parameter <code>service</code>, which can be a port number, like “80”, or the name of a particular service (found in <a href="https://www.iana.org/assignments/port-numbers">The IANA Port List</a><a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a> or the <code>/etc/services</code> file on your Unix machine) like “http” or “ftp” or “telnet” or “smtp” or whatever.</p>
<p>Finally, the <code>hints</code> parameter points to a <code>struct addrinfo</code> that you’ve already filled out with relevant information.</p>
<p>Here’s a sample call if you’re a server who wants to listen on your 
host’s IP address, port 3490. Note that this doesn’t actually do any 
listening or network setup; it merely sets up structures we’ll use 
later:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1"></a><span class="dt">int</span> status;</span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="kw">struct</span> addrinfo hints;</span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="kw">struct</span> addrinfo *servinfo;  <span class="co">// will point to the results</span></span>
<span id="cb20-4"><a href="#cb20-4"></a></span>
<span id="cb20-5"><a href="#cb20-5"></a>memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints); <span class="co">// make sure the struct is empty</span></span>
<span id="cb20-6"><a href="#cb20-6"></a>hints.ai_family = AF_UNSPEC;     <span class="co">// don't care IPv4 or IPv6</span></span>
<span id="cb20-7"><a href="#cb20-7"></a>hints.ai_socktype = SOCK_STREAM; <span class="co">// TCP stream sockets</span></span>
<span id="cb20-8"><a href="#cb20-8"></a>hints.ai_flags = AI_PASSIVE;     <span class="co">// fill in my IP for me</span></span>
<span id="cb20-9"><a href="#cb20-9"></a></span>
<span id="cb20-10"><a href="#cb20-10"></a><span class="cf">if</span> ((status = getaddrinfo(NULL, <span class="st">"3490"</span>, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</span>
<span id="cb20-11"><a href="#cb20-11"></a>    fprintf(stderr, <span class="st">"getaddrinfo error: %s</span><span class="sc">\n</span><span class="st">"</span>, gai_strerror(status));</span>
<span id="cb20-12"><a href="#cb20-12"></a>    exit(<span class="dv">1</span>);</span>
<span id="cb20-13"><a href="#cb20-13"></a>}</span>
<span id="cb20-14"><a href="#cb20-14"></a></span>
<span id="cb20-15"><a href="#cb20-15"></a><span class="co">// servinfo now points to a linked list of 1 or more struct addrinfos</span></span>
<span id="cb20-16"><a href="#cb20-16"></a></span>
<span id="cb20-17"><a href="#cb20-17"></a><span class="co">// ... do everything until you don't need servinfo anymore ....</span></span>
<span id="cb20-18"><a href="#cb20-18"></a></span>
<span id="cb20-19"><a href="#cb20-19"></a>freeaddrinfo(servinfo); <span class="co">// free the linked-list</span></span></code></pre></div>
<p>Notice that I set the <code>ai_family</code> to <code>AF_UNSPEC</code>, thereby saying that I don’t care if we use IPv4 or IPv6. You can set it to <code>AF_INET</code> or <code>AF_INET6</code> if you want one or the other specifically.</p>
<p>Also, you’ll see the <code>AI_PASSIVE</code> flag in there; this tells <code>getaddrinfo()</code>
 to assign the address of my local host to the socket structures. This 
is nice because then you don’t have to hardcode it. (Or you can put a 
specific address in as the first parameter to <code>getaddrinfo()</code> where I currently have <code>NULL</code>, up there.)</p>
<p>Then we make the call. If there’s an error (<code>getaddrinfo()</code> returns non-zero), we can print it out using the function <code>gai_strerror()</code>, as you see. If everything works properly, though, <code>servinfo</code> will point to a linked list of <code>struct addrinfo</code>s, each of which contains a <code>struct sockaddr</code> of some kind that we can use later! Nifty!</p>
<p>Finally, when we’re eventually all done with the linked list that <code>getaddrinfo()</code> so graciously allocated for us, we can (and should) free it all up with a call to <code>freeaddrinfo()</code>.</p>
<p>Here’s a sample call if you’re a client who wants to connect to a 
particular server, say “www.example.net” port 3490. Again, this doesn’t 
actually connect, but it sets up the structures we’ll use later:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1"></a><span class="dt">int</span> status;</span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="kw">struct</span> addrinfo hints;</span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="kw">struct</span> addrinfo *servinfo;  <span class="co">// will point to the results</span></span>
<span id="cb21-4"><a href="#cb21-4"></a></span>
<span id="cb21-5"><a href="#cb21-5"></a>memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints); <span class="co">// make sure the struct is empty</span></span>
<span id="cb21-6"><a href="#cb21-6"></a>hints.ai_family = AF_UNSPEC;     <span class="co">// don't care IPv4 or IPv6</span></span>
<span id="cb21-7"><a href="#cb21-7"></a>hints.ai_socktype = SOCK_STREAM; <span class="co">// TCP stream sockets</span></span>
<span id="cb21-8"><a href="#cb21-8"></a></span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="co">// get ready to connect</span></span>
<span id="cb21-10"><a href="#cb21-10"></a>status = getaddrinfo(<span class="st">"www.example.net"</span>, <span class="st">"3490"</span>, &amp;hints, &amp;servinfo);</span>
<span id="cb21-11"><a href="#cb21-11"></a></span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="co">// servinfo now points to a linked list of 1 or more struct addrinfos</span></span>
<span id="cb21-13"><a href="#cb21-13"></a></span>
<span id="cb21-14"><a href="#cb21-14"></a><span class="co">// etc.</span></span></code></pre></div>
<p>I keep saying that <code>servinfo</code> is a linked list with all kinds of address information. Let’s write a quick demo program to show off this information. <a href="https://beej.us/guide/bgnet/examples/showip.c">This short program</a><a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a> will print the IP addresses for whatever host you specify on the command line:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1"></a><span class="co">/*</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="co">** showip.c -- show IP addresses for a host given on the command line</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="co">*/</span></span>
<span id="cb22-4"><a href="#cb22-4"></a></span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb22-6"><a href="#cb22-6"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></span>
<span id="cb22-11"><a href="#cb22-11"></a><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></span>
<span id="cb22-12"><a href="#cb22-12"></a></span>
<span id="cb22-13"><a href="#cb22-13"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</span>
<span id="cb22-14"><a href="#cb22-14"></a>{</span>
<span id="cb22-15"><a href="#cb22-15"></a>    <span class="kw">struct</span> addrinfo hints, *res, *p;</span>
<span id="cb22-16"><a href="#cb22-16"></a>    <span class="dt">int</span> status;</span>
<span id="cb22-17"><a href="#cb22-17"></a>    <span class="dt">char</span> ipstr[INET6_ADDRSTRLEN];</span>
<span id="cb22-18"><a href="#cb22-18"></a></span>
<span id="cb22-19"><a href="#cb22-19"></a>    <span class="cf">if</span> (argc != <span class="dv">2</span>) {</span>
<span id="cb22-20"><a href="#cb22-20"></a>        fprintf(stderr,<span class="st">"usage: showip hostname</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb22-21"><a href="#cb22-21"></a>        <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb22-22"><a href="#cb22-22"></a>    }</span>
<span id="cb22-23"><a href="#cb22-23"></a></span>
<span id="cb22-24"><a href="#cb22-24"></a>    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb22-25"><a href="#cb22-25"></a>    hints.ai_family = AF_UNSPEC; <span class="co">// AF_INET or AF_INET6 to force version</span></span>
<span id="cb22-26"><a href="#cb22-26"></a>    hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb22-27"><a href="#cb22-27"></a></span>
<span id="cb22-28"><a href="#cb22-28"></a>    <span class="cf">if</span> ((status = getaddrinfo(argv[<span class="dv">1</span>], NULL, &amp;hints, &amp;res)) != <span class="dv">0</span>) {</span>
<span id="cb22-29"><a href="#cb22-29"></a>        fprintf(stderr, <span class="st">"getaddrinfo: %s</span><span class="sc">\n</span><span class="st">"</span>, gai_strerror(status));</span>
<span id="cb22-30"><a href="#cb22-30"></a>        <span class="cf">return</span> <span class="dv">2</span>;</span>
<span id="cb22-31"><a href="#cb22-31"></a>    }</span>
<span id="cb22-32"><a href="#cb22-32"></a></span>
<span id="cb22-33"><a href="#cb22-33"></a>    printf(<span class="st">"IP addresses for %s:</span><span class="sc">\n\n</span><span class="st">"</span>, argv[<span class="dv">1</span>]);</span>
<span id="cb22-34"><a href="#cb22-34"></a></span>
<span id="cb22-35"><a href="#cb22-35"></a>    <span class="cf">for</span>(p = res;p != NULL; p = p-&gt;ai_next) {</span>
<span id="cb22-36"><a href="#cb22-36"></a>        <span class="dt">void</span> *addr;</span>
<span id="cb22-37"><a href="#cb22-37"></a>        <span class="dt">char</span> *ipver;</span>
<span id="cb22-38"><a href="#cb22-38"></a></span>
<span id="cb22-39"><a href="#cb22-39"></a>        <span class="co">// get the pointer to the address itself,</span></span>
<span id="cb22-40"><a href="#cb22-40"></a>        <span class="co">// different fields in IPv4 and IPv6:</span></span>
<span id="cb22-41"><a href="#cb22-41"></a>        <span class="cf">if</span> (p-&gt;ai_family == AF_INET) { <span class="co">// IPv4</span></span>
<span id="cb22-42"><a href="#cb22-42"></a>            <span class="kw">struct</span> sockaddr_in *ipv4 = (<span class="kw">struct</span> sockaddr_in *)p-&gt;ai_addr;</span>
<span id="cb22-43"><a href="#cb22-43"></a>            addr = &amp;(ipv4-&gt;sin_addr);</span>
<span id="cb22-44"><a href="#cb22-44"></a>            ipver = <span class="st">"IPv4"</span>;</span>
<span id="cb22-45"><a href="#cb22-45"></a>        } <span class="cf">else</span> { <span class="co">// IPv6</span></span>
<span id="cb22-46"><a href="#cb22-46"></a>            <span class="kw">struct</span> sockaddr_in6 *ipv6 = (<span class="kw">struct</span> sockaddr_in6 *)p-&gt;ai_addr;</span>
<span id="cb22-47"><a href="#cb22-47"></a>            addr = &amp;(ipv6-&gt;sin6_addr);</span>
<span id="cb22-48"><a href="#cb22-48"></a>            ipver = <span class="st">"IPv6"</span>;</span>
<span id="cb22-49"><a href="#cb22-49"></a>        }</span>
<span id="cb22-50"><a href="#cb22-50"></a></span>
<span id="cb22-51"><a href="#cb22-51"></a>        <span class="co">// convert the IP to a string and print it:</span></span>
<span id="cb22-52"><a href="#cb22-52"></a>        inet_ntop(p-&gt;ai_family, addr, ipstr, <span class="kw">sizeof</span> ipstr);</span>
<span id="cb22-53"><a href="#cb22-53"></a>        printf(<span class="st">"  %s: %s</span><span class="sc">\n</span><span class="st">"</span>, ipver, ipstr);</span>
<span id="cb22-54"><a href="#cb22-54"></a>    }</span>
<span id="cb22-55"><a href="#cb22-55"></a></span>
<span id="cb22-56"><a href="#cb22-56"></a>    freeaddrinfo(res); <span class="co">// free the linked list</span></span>
<span id="cb22-57"><a href="#cb22-57"></a></span>
<span id="cb22-58"><a href="#cb22-58"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb22-59"><a href="#cb22-59"></a>}</span></code></pre></div>
<p>As you see, the code calls <code>getaddrinfo()</code> on whatever you pass on the command line, that fills out the linked list pointed to by <code>res</code>, and then we can iterate over the list and print stuff out or do whatever.</p>
<p>(There’s a little bit of ugliness there where we have to dig into the different types of <code>struct sockaddr</code>s depending on the IP version. Sorry about that! I’m not sure of a better way around it.)</p>
<p>Sample run! Everyone loves screenshots:</p>
<pre><code>    $ showip www.example.net
    IP addresses for www.example.net:
    
      IPv4: 192.0.2.88
    
    $ showip ipv6.example.com
    IP addresses for ipv6.example.com:
    
      IPv4: 192.0.2.101
      IPv6: 2001:db8:8c00:22::171</code></pre>
<p>Now that we have that under control, we’ll use the results we get from <code>getaddrinfo()</code> to pass to other socket functions and, at long last, get our network connection established! Keep reading!</p>
<h2 data-number="5.2" id="socket"><span class="header-section-number">5.2</span> <code>socket()</code>—Get the File Descriptor!</h2>
<p>I guess I can put it off no longer—I have to talk about the  <code>socket()</code> system call. Here’s the breakdown:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> socket(<span class="dt">int</span> domain, <span class="dt">int</span> type, <span class="dt">int</span> protocol); </span></code></pre></div>
<p>But what are these arguments? They allow you to say what kind of 
socket you want (IPv4 or IPv6, stream or datagram, and TCP or UDP).</p>
<p>It used to be people would hardcode these values, and you can absolutely still do that. (<code>domain</code> is <code>PF_INET</code> or <code>PF_INET6</code>, <code>type</code> is <code>SOCK_STREAM</code> or <code>SOCK_DGRAM</code>, and <code>protocol</code> can be set to <code>0</code> to choose the proper protocol for the given <code>type</code>. Or you can call <code>getprotobyname()</code> to look up the protocol you want, “tcp” or “udp”.)</p>
<p>(This <code>PF_INET</code> thing is a close relative of the  <code>AF_INET</code> that you can use when initializing the <code>sin_family</code> field in your <code>struct sockaddr_in</code>. In fact, they’re so closely related that they actually have the same value, and many programmers will call <code>socket()</code> and pass <code>AF_INET</code> as the first argument instead of <code>PF_INET</code>.
 Now, get some milk and cookies, because it’s time for a story. Once 
upon a time, a long time ago, it was thought that maybe an address 
family (what the “AF” in “<code>AF_INET</code>” stands for) might support several protocols that were referred to by their protocol family (what the “PF” in “<code>PF_INET</code>” stands for). That didn’t happen. And they all lived happily ever after, The End. So the most correct thing to do is to use <code>AF_INET</code> in your <code>struct sockaddr_in</code> and <code>PF_INET</code> in your call to <code>socket()</code>.)</p>
<p>Anyway, enough of that. What you really want to do is use the values from the results of the call to <code>getaddrinfo()</code>, and feed them into <code>socket()</code> directly like this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1"></a><span class="dt">int</span> s;</span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="kw">struct</span> addrinfo hints, *res;</span>
<span id="cb25-3"><a href="#cb25-3"></a></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="co">// do the lookup</span></span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="co">// [pretend we already filled out the "hints" struct]</span></span>
<span id="cb25-6"><a href="#cb25-6"></a>getaddrinfo(<span class="st">"www.example.com"</span>, <span class="st">"http"</span>, &amp;hints, &amp;res);</span>
<span id="cb25-7"><a href="#cb25-7"></a></span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="co">// again, you should do error-checking on getaddrinfo(), and walk</span></span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="co">// the "res" linked list looking for valid entries instead of just</span></span>
<span id="cb25-10"><a href="#cb25-10"></a><span class="co">// assuming the first one is good (like many of these examples do).</span></span>
<span id="cb25-11"><a href="#cb25-11"></a><span class="co">// See the section on client/server for real examples.</span></span>
<span id="cb25-12"><a href="#cb25-12"></a></span>
<span id="cb25-13"><a href="#cb25-13"></a>s = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span></code></pre></div>
<p><code>socket()</code> simply returns to you a <em>socket descriptor</em> that you can use in later system calls, or <code>-1</code> on error. The global variable <code>errno</code> is set to the error’s value (see the <a href="#errnoman"><code>errno</code></a> man page for more details, and a quick note on using <code>errno</code> in multithreaded programs).</p>
<p>Fine, fine, fine, but what good is this socket? The answer is that 
it’s really no good by itself, and you need to read on and make more 
system calls for it to make any sense.</p>
<h2 data-number="5.3" id="bind"><span class="header-section-number">5.3</span> <code>bind()</code>—What port am I on?</h2>
<p> Once you have a socket, you might have to associate that socket with
 a  port on your local machine. (This is commonly done if you’re going 
to  <code>listen()</code> for incoming connections on a specific 
port—multiplayer network games do this when they tell you to “connect to
 192.168.5.10 port 3490”.) The port number is used by the kernel to 
match an incoming packet to a certain process’s socket descriptor. If 
you’re going to only be doing a  <code>connect()</code> (because you’re the client, not the server), this is probably be unnecessary. Read it anyway, just for kicks.</p>
<p>Here is the synopsis for the <code>bind()</code> system call:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> bind(<span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *my_addr, <span class="dt">int</span> addrlen);</span></code></pre></div>
<p><code>sockfd</code> is the socket file descriptor returned by <code>socket()</code>. <code>my_addr</code> is a pointer to a <code>struct sockaddr</code> that contains information about your address, namely, port and  IP address. <code>addrlen</code> is the length in bytes of that address.</p>
<p>Whew. That’s a bit to absorb in one chunk. Let’s have an example that
 binds the socket to the host the program is running on, port 3490:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">struct</span> addrinfo hints, *res;</span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="dt">int</span> sockfd;</span>
<span id="cb27-3"><a href="#cb27-3"></a></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="co">// first, load up address structs with getaddrinfo():</span></span>
<span id="cb27-5"><a href="#cb27-5"></a></span>
<span id="cb27-6"><a href="#cb27-6"></a>memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb27-7"><a href="#cb27-7"></a>hints.ai_family = AF_UNSPEC;  <span class="co">// use IPv4 or IPv6, whichever</span></span>
<span id="cb27-8"><a href="#cb27-8"></a>hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb27-9"><a href="#cb27-9"></a>hints.ai_flags = AI_PASSIVE;     <span class="co">// fill in my IP for me</span></span>
<span id="cb27-10"><a href="#cb27-10"></a></span>
<span id="cb27-11"><a href="#cb27-11"></a>getaddrinfo(NULL, <span class="st">"3490"</span>, &amp;hints, &amp;res);</span>
<span id="cb27-12"><a href="#cb27-12"></a></span>
<span id="cb27-13"><a href="#cb27-13"></a><span class="co">// make a socket:</span></span>
<span id="cb27-14"><a href="#cb27-14"></a></span>
<span id="cb27-15"><a href="#cb27-15"></a>sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span>
<span id="cb27-16"><a href="#cb27-16"></a></span>
<span id="cb27-17"><a href="#cb27-17"></a><span class="co">// bind it to the port we passed in to getaddrinfo():</span></span>
<span id="cb27-18"><a href="#cb27-18"></a></span>
<span id="cb27-19"><a href="#cb27-19"></a>bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</span></code></pre></div>
<p>By using the <code>AI_PASSIVE</code> flag, I’m telling the program to
 bind to the IP of the host it’s running on. If you want to bind to a 
specific local IP address, drop the <code>AI_PASSIVE</code> and put an IP address in for the first argument to <code>getaddrinfo()</code>.</p>
<p><code>bind()</code> also returns <code>-1</code> on error and sets <code>errno</code> to the error’s value.</p>
<p>Lots of old code manually packs the <code>struct sockaddr_in</code> before calling <code>bind()</code>.
 Obviously this is IPv4-specific, but there’s really nothing stopping 
you from doing the same thing with IPv6, except that using <code>getaddrinfo()</code> is going to be easier, generally. Anyway, the old code looks something like this:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1"></a><span class="co">// !!! THIS IS THE OLD WAY !!!</span></span>
<span id="cb28-2"><a href="#cb28-2"></a></span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="dt">int</span> sockfd;</span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="kw">struct</span> sockaddr_in my_addr;</span>
<span id="cb28-5"><a href="#cb28-5"></a></span>
<span id="cb28-6"><a href="#cb28-6"></a>sockfd = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</span>
<span id="cb28-7"><a href="#cb28-7"></a></span>
<span id="cb28-8"><a href="#cb28-8"></a>my_addr.sin_family = AF_INET;</span>
<span id="cb28-9"><a href="#cb28-9"></a>my_addr.sin_port = htons(MYPORT);     <span class="co">// short, network byte order</span></span>
<span id="cb28-10"><a href="#cb28-10"></a>my_addr.sin_addr.s_addr = inet_addr(<span class="st">"10.12.110.57"</span>);</span>
<span id="cb28-11"><a href="#cb28-11"></a>memset(my_addr.sin_zero, <span class="ch">'\0'</span>, <span class="kw">sizeof</span> my_addr.sin_zero);</span>
<span id="cb28-12"><a href="#cb28-12"></a></span>
<span id="cb28-13"><a href="#cb28-13"></a>bind(sockfd, (<span class="kw">struct</span> sockaddr *)&amp;my_addr, <span class="kw">sizeof</span> my_addr);</span></code></pre></div>
<p>In the above code, you could also assign <code>INADDR_ANY</code> to the <code>s_addr</code> field if you wanted to bind to your local IP address (like the <code>AI_PASSIVE</code> flag, above). The IPv6 version of <code>INADDR_ANY</code> is a global variable <code>in6addr_any</code> that is assigned into the <code>sin6_addr</code> field of your <code>struct sockaddr_in6</code>. (There is also a macro <code>IN6ADDR_ANY_INIT</code> that you can use in a variable initializer.)</p>
<p>Another thing to watch out for when calling <code>bind()</code>: 
don’t go underboard with your port numbers.  All ports below 1024 are 
RESERVED (unless you’re the superuser)! You can have any port number 
above that, right up to 65535 (provided they aren’t already being used 
by another program).</p>
<p>Sometimes, you might notice, you try to rerun a server and <code>bind()</code>
 fails, claiming  “Address already in use.” What does that mean? Well, a
 little bit of a socket that was connected is still hanging around in 
the kernel, and it’s hogging the port. You can either wait for it to 
clear (a minute or so), or add code to your program allowing it to reuse
 the port, like this:</p>
<p> </p>
<div class="sourceCode" id="cb29"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1"></a><span class="dt">int</span> yes=<span class="dv">1</span>;</span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="co">//char yes='1'; // Solaris people use this</span></span>
<span id="cb29-3"><a href="#cb29-3"></a></span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="co">// lose the pesky "Address already in use" error message</span></span>
<span id="cb29-5"><a href="#cb29-5"></a><span class="cf">if</span> (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,&amp;yes,<span class="kw">sizeof</span> yes) == -<span class="dv">1</span>) {</span>
<span id="cb29-6"><a href="#cb29-6"></a>    perror(<span class="st">"setsockopt"</span>);</span>
<span id="cb29-7"><a href="#cb29-7"></a>    exit(<span class="dv">1</span>);</span>
<span id="cb29-8"><a href="#cb29-8"></a>} </span></code></pre></div>
<p> One small extra final note about <code>bind()</code>: there are times when you won’t absolutely have to call it. If you are  <code>connect()</code>ing to a remote machine and you don’t care what your local port is (as is the case with <code>telnet</code> where you only care about the remote port), you can simply call <code>connect()</code>, it’ll check to see if the socket is unbound, and will <code>bind()</code> it to an unused local port if necessary.</p>
<h2 data-number="5.4" id="connect"><span class="header-section-number">5.4</span> <code>connect()</code>—Hey, you!</h2>
<p> Let’s just pretend for a few minutes that you’re a telnet application. Your user commands you (just like in the movie  <em>TRON</em>) to get a socket file descriptor. You comply and call <code>socket()</code>. Next, the user tells you to connect to “<code>10.12.110.57</code>” on port “<code>23</code>” (the standard telnet port). Yow! What do you do now?</p>
<p>Lucky for you, program, you’re now perusing the section on <code>connect()</code>—how to connect to a remote host. So read furiously onward! No time to lose!</p>
<p>The <code>connect()</code> call is as follows:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> connect(<span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *serv_addr, <span class="dt">int</span> addrlen); </span></code></pre></div>
<p><code>sockfd</code> is our friendly neighborhood socket file descriptor, as returned by the <code>socket()</code> call, <code>serv_addr</code> is a <code>struct sockaddr</code> containing the destination port and IP address, and <code>addrlen</code> is the length in bytes of the server address structure.</p>
<p>All of this information can be gleaned from the results of the <code>getaddrinfo()</code> call, which rocks.</p>
<p>Is this starting to make more sense? I can’t hear you from here, so 
I’ll just have to hope that it is. Let’s have an example where we make a
 socket connection to “<code>www.example.com</code>”, port <code>3490</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">struct</span> addrinfo hints, *res;</span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="dt">int</span> sockfd;</span>
<span id="cb31-3"><a href="#cb31-3"></a></span>
<span id="cb31-4"><a href="#cb31-4"></a><span class="co">// first, load up address structs with getaddrinfo():</span></span>
<span id="cb31-5"><a href="#cb31-5"></a></span>
<span id="cb31-6"><a href="#cb31-6"></a>memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb31-7"><a href="#cb31-7"></a>hints.ai_family = AF_UNSPEC;</span>
<span id="cb31-8"><a href="#cb31-8"></a>hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb31-9"><a href="#cb31-9"></a></span>
<span id="cb31-10"><a href="#cb31-10"></a>getaddrinfo(<span class="st">"www.example.com"</span>, <span class="st">"3490"</span>, &amp;hints, &amp;res);</span>
<span id="cb31-11"><a href="#cb31-11"></a></span>
<span id="cb31-12"><a href="#cb31-12"></a><span class="co">// make a socket:</span></span>
<span id="cb31-13"><a href="#cb31-13"></a></span>
<span id="cb31-14"><a href="#cb31-14"></a>sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span>
<span id="cb31-15"><a href="#cb31-15"></a></span>
<span id="cb31-16"><a href="#cb31-16"></a><span class="co">// connect!</span></span>
<span id="cb31-17"><a href="#cb31-17"></a></span>
<span id="cb31-18"><a href="#cb31-18"></a>connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</span></code></pre></div>
<p>Again, old-school programs filled out their own <code>struct sockaddr_in</code>s to pass to <code>connect()</code>. You can do that if you want to. See the similar note in the <a href="#bind"><code>bind()</code> section</a>, above.</p>
<p>Be sure to check the return value from <code>connect()</code>—it’ll return <code>-1</code> on error and set the variable <code>errno</code>.</p>
<!-- latex index here so we can get the subindex entry after the tt -->
<p></p>
<p>Also, notice that we didn’t call <code>bind()</code>. Basically, we 
don’t care about our local port number; we only care where we’re going 
(the remote port). The kernel will choose a local port for us, and the 
site we connect to will automatically get this information from us. No 
worries.</p>
<h2 data-number="5.5" id="listen"><span class="header-section-number">5.5</span> <code>listen()</code>—Will somebody please call me?</h2>
<p> Ok, time for a change of pace. What if you don’t want to connect to a
 remote host. Say, just for kicks, that you want to wait for incoming 
connections and handle them in some way. The process is two step: first 
you <code>listen()</code>, then you  <code>accept()</code> (see below).</p>
<p>The <code>listen()</code> call is fairly simple, but requires a bit of explanation:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> listen(<span class="dt">int</span> sockfd, <span class="dt">int</span> backlog); </span></code></pre></div>
<p><code>sockfd</code> is the usual socket file descriptor from the <code>socket()</code> system call.  <code>backlog</code>
 is the number of connections allowed on the incoming queue. What does 
that mean? Well, incoming connections are going to wait in this queue 
until you <code>accept()</code> them (see below) and this is the limit 
on how many can queue up. Most systems silently limit this number to 
about 20; you can probably get away with setting it to <code>5</code> or <code>10</code>.</p>
<p>Again, as per usual, <code>listen()</code> returns <code>-1</code> and sets <code>errno</code> on error.</p>
<p>Well, as you can probably imagine, we need to call <code>bind()</code> before we call <code>listen()</code>
 so that the server is running on a specific port. (You have to be able 
to tell your buddies which port to connect to!) So if you’re going to be
 listening for incoming connections, the sequence of system calls you’ll
 make is:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1"></a>getaddrinfo();</span>
<span id="cb33-2"><a href="#cb33-2"></a>socket();</span>
<span id="cb33-3"><a href="#cb33-3"></a>bind();</span>
<span id="cb33-4"><a href="#cb33-4"></a>listen();</span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="co">/* accept() goes here */</span> </span></code></pre></div>
<p>I’ll just leave that in the place of sample code, since it’s fairly self-explanatory. (The code in the <code>accept()</code> section, below, is more complete.) The really tricky part of this whole sha-bang is the call to <code>accept()</code>.</p>
<h2 data-number="5.6" id="acceptthank-you-for-calling-port-3490."><span class="header-section-number">5.6</span> <code>accept()</code>—“Thank you for calling port 3490.”</h2>
<p> Get ready—the <code>accept()</code> call is kinda weird! What’s going to happen is this: someone far far away will try to <code>connect()</code> to your machine on a port that you are <code>listen()</code>ing on. Their connection will be queued up waiting to be <code>accept()</code>ed.&nbsp;You call <code>accept()</code> and you tell it to get the pending connection. It’ll return to you a <em>brand new socket file descriptor</em> to use for this single connection! That’s right, suddenly you have <em>two socket file descriptors</em>
 for the price of one! The original one is still listening for more new 
connections, and the newly created one is finally ready to <code>send()</code> and <code>recv()</code>. We’re there!</p>
<p>The call is as follows:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> accept(<span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *addr, socklen_t *addrlen); </span></code></pre></div>
<p><code>sockfd</code> is the <code>listen()</code>ing socket descriptor. Easy enough. <code>addr</code> will usually be a pointer to a local <code>struct sockaddr_storage</code>.
 This is where the information about the incoming connection will go 
(and with it you can determine which host is calling you from which 
port). <code>addrlen</code> is a local integer variable that should be set to <code>sizeof(struct sockaddr_storage)</code> before its address is passed to <code>accept()</code>. <code>accept()</code> will not put more than that many bytes into <code>addr</code>. If it puts fewer in, it’ll change the value of <code>addrlen</code> to reflect that.</p>
<p>Guess what? <code>accept()</code> returns <code>-1</code> and sets <code>errno</code> if an error occurs. Betcha didn’t figure that.</p>
<p>Like before, this is a bunch to absorb in one chunk, so here’s a sample code fragment for your perusal:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb35-3"><a href="#cb35-3"></a><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb35-4"><a href="#cb35-4"></a><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></span>
<span id="cb35-5"><a href="#cb35-5"></a></span>
<span id="cb35-6"><a href="#cb35-6"></a><span class="pp">#define MYPORT "3490"  </span><span class="co">// the port users will be connecting to</span></span>
<span id="cb35-7"><a href="#cb35-7"></a><span class="pp">#define BACKLOG 10     </span><span class="co">// how many pending connections queue will hold</span></span>
<span id="cb35-8"><a href="#cb35-8"></a></span>
<span id="cb35-9"><a href="#cb35-9"></a><span class="dt">int</span> main(<span class="dt">void</span>)</span>
<span id="cb35-10"><a href="#cb35-10"></a>{</span>
<span id="cb35-11"><a href="#cb35-11"></a>    <span class="kw">struct</span> sockaddr_storage their_addr;</span>
<span id="cb35-12"><a href="#cb35-12"></a>    socklen_t addr_size;</span>
<span id="cb35-13"><a href="#cb35-13"></a>    <span class="kw">struct</span> addrinfo hints, *res;</span>
<span id="cb35-14"><a href="#cb35-14"></a>    <span class="dt">int</span> sockfd, new_fd;</span>
<span id="cb35-15"><a href="#cb35-15"></a></span>
<span id="cb35-16"><a href="#cb35-16"></a>    <span class="co">// !! don't forget your error checking for these calls !!</span></span>
<span id="cb35-17"><a href="#cb35-17"></a></span>
<span id="cb35-18"><a href="#cb35-18"></a>    <span class="co">// first, load up address structs with getaddrinfo():</span></span>
<span id="cb35-19"><a href="#cb35-19"></a></span>
<span id="cb35-20"><a href="#cb35-20"></a>    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb35-21"><a href="#cb35-21"></a>    hints.ai_family = AF_UNSPEC;  <span class="co">// use IPv4 or IPv6, whichever</span></span>
<span id="cb35-22"><a href="#cb35-22"></a>    hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb35-23"><a href="#cb35-23"></a>    hints.ai_flags = AI_PASSIVE;     <span class="co">// fill in my IP for me</span></span>
<span id="cb35-24"><a href="#cb35-24"></a></span>
<span id="cb35-25"><a href="#cb35-25"></a>    getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);</span>
<span id="cb35-26"><a href="#cb35-26"></a></span>
<span id="cb35-27"><a href="#cb35-27"></a>    <span class="co">// make a socket, bind it, and listen on it:</span></span>
<span id="cb35-28"><a href="#cb35-28"></a></span>
<span id="cb35-29"><a href="#cb35-29"></a>    sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span>
<span id="cb35-30"><a href="#cb35-30"></a>    bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</span>
<span id="cb35-31"><a href="#cb35-31"></a>    listen(sockfd, BACKLOG);</span>
<span id="cb35-32"><a href="#cb35-32"></a></span>
<span id="cb35-33"><a href="#cb35-33"></a>    <span class="co">// now accept an incoming connection:</span></span>
<span id="cb35-34"><a href="#cb35-34"></a></span>
<span id="cb35-35"><a href="#cb35-35"></a>    addr_size = <span class="kw">sizeof</span> their_addr;</span>
<span id="cb35-36"><a href="#cb35-36"></a>    new_fd = accept(sockfd, (<span class="kw">struct</span> sockaddr *)&amp;their_addr, &amp;addr_size);</span>
<span id="cb35-37"><a href="#cb35-37"></a></span>
<span id="cb35-38"><a href="#cb35-38"></a>    <span class="co">// ready to communicate on socket descriptor new_fd!</span></span>
<span id="cb35-39"><a href="#cb35-39"></a>    .</span>
<span id="cb35-40"><a href="#cb35-40"></a>    .</span>
<span id="cb35-41"><a href="#cb35-41"></a>    .</span></code></pre></div>
<p>Again, note that we will use the socket descriptor <code>new_fd</code> for all <code>send()</code> and <code>recv()</code> calls. If you’re only getting one single connection ever, you can <code>close()</code> the listening <code>sockfd</code> in order to prevent more incoming connections on the same port, if you so desire.</p>
<h2 data-number="5.7" id="sendrecv"><span class="header-section-number">5.7</span> <code>send()</code> and <code>recv()</code>—Talk to me, baby!</h2>
<p>These two functions are for communicating over stream sockets or 
connected datagram sockets. If you want to use regular unconnected 
datagram sockets, you’ll need to see the section on <a href="#sendtorecv"><code>sendto()</code> and <code>recvfrom()</code></a>, below.</p>
<p> The <code>send()</code> call:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> send(<span class="dt">int</span> sockfd, <span class="dt">const</span> <span class="dt">void</span> *msg, <span class="dt">int</span> len, <span class="dt">int</span> flags); </span></code></pre></div>
<p><code>sockfd</code> is the socket descriptor you want to send data to (whether it’s the one returned by <code>socket()</code> or the one you got with <code>accept()</code>). <code>msg</code> is a pointer to the data you want to send, and <code>len</code> is the length of that data in bytes. Just set <code>flags</code> to <code>0</code>. (See the <code>send()</code> man page for more information concerning flags.)</p>
<p>Some sample code might be:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1"></a><span class="dt">char</span> *msg = <span class="st">"Beej was here!"</span>;</span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="dt">int</span> len, bytes_sent;</span>
<span id="cb37-3"><a href="#cb37-3"></a>.</span>
<span id="cb37-4"><a href="#cb37-4"></a>.</span>
<span id="cb37-5"><a href="#cb37-5"></a>.</span>
<span id="cb37-6"><a href="#cb37-6"></a>len = strlen(msg);</span>
<span id="cb37-7"><a href="#cb37-7"></a>bytes_sent = send(sockfd, msg, len, <span class="dv">0</span>);</span>
<span id="cb37-8"><a href="#cb37-8"></a>.</span>
<span id="cb37-9"><a href="#cb37-9"></a>.</span>
<span id="cb37-10"><a href="#cb37-10"></a>. </span></code></pre></div>
<p><code>send()</code> returns the number of bytes actually sent out—<em>this might be less than the number you told it to send!</em>
 See, sometimes you tell it to send a whole gob of data and it just 
can’t handle it. It’ll fire off as much of the data as it can, and trust
 you to send the rest later. Remember, if the value returned by <code>send()</code> doesn’t match the value in <code>len</code>, it’s up to you to send the rest of the string. The good news is this: if the packet is small (less than 1K or so) it will <em>probably</em> manage to send the whole thing all in one go. Again, <code>-1</code> is returned on error, and <code>errno</code> is set to the error number.</p>
<p> The <code>recv()</code> call is similar in many respects:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> recv(<span class="dt">int</span> sockfd, <span class="dt">void</span> *buf, <span class="dt">int</span> len, <span class="dt">int</span> flags);</span></code></pre></div>
<p><code>sockfd</code> is the socket descriptor to read from, <code>buf</code> is the buffer to read the information into, <code>len</code> is the maximum length of the buffer, and <code>flags</code> can again be set to <code>0</code>. (See the <code>recv()</code> man page for flag information.)</p>
<p><code>recv()</code> returns the number of bytes actually read into the buffer, or <code>-1</code> on error (with <code>errno</code> set, accordingly).</p>
<p>Wait! <code>recv()</code> can return <code>0</code>. This can mean only one thing: the remote side has closed the connection on you! A return value of <code>0</code> is <code>recv()</code>’s way of letting you know this has occurred.</p>
<p>There, that was easy, wasn’t it? You can now pass data back and forth on stream sockets! Whee! You’re a Unix Network Programmer!</p>
<h2 data-number="5.8" id="sendtorecv"><span class="header-section-number">5.8</span> <code>sendto()</code> and <code>recvfrom()</code>—Talk to me, DGRAM-style</h2>
<p> “This is all fine and dandy,” I hear you saying, “but where does 
this leave me with unconnected datagram sockets?” No problemo, amigo. We
 have just the thing.</p>
<p>Since datagram sockets aren’t connected to a remote host, guess which
 piece of information we need to give before we send a packet? That’s 
right! The destination address! Here’s the scoop:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sendto(<span class="dt">int</span> sockfd, <span class="dt">const</span> <span class="dt">void</span> *msg, <span class="dt">int</span> len, <span class="dt">unsigned</span> <span class="dt">int</span> flags,</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>               <span class="dt">const</span> <span class="kw">struct</span> sockaddr *to, socklen_t tolen); </span></code></pre></div>
<p>As you can see, this call is basically the same as the call to <code>send()</code> with the addition of two other pieces of information. <code>to</code> is a pointer to a <code>struct sockaddr</code> (which will probably be another <code>struct sockaddr_in</code> or <code>struct sockaddr_in6</code> or <code>struct sockaddr_storage</code> that you cast at the last minute) which contains the destination  IP address and  port. <code>tolen</code>, an <code>int</code> deep-down, can simply be set to <code>sizeof *to</code> or <code>sizeof(struct sockaddr_storage)</code>.</p>
<p>To get your hands on the destination address structure, you’ll probably either get it from <code>getaddrinfo()</code>, or from <code>recvfrom()</code>, below, or you’ll fill it out by hand.</p>
<p>Just like with <code>send()</code>, <code>sendto()</code> returns the number of bytes actually sent (which, again, might be less than the number of bytes you told it to send!), or <code>-1</code> on error.</p>
<p>Equally similar are <code>recv()</code> and  <code>recvfrom()</code>. The synopsis of <code>recvfrom()</code> is:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> recvfrom(<span class="dt">int</span> sockfd, <span class="dt">void</span> *buf, <span class="dt">int</span> len, <span class="dt">unsigned</span> <span class="dt">int</span> flags,</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">struct</span> sockaddr *from, <span class="dt">int</span> *fromlen); </span></code></pre></div>
<p>Again, this is just like <code>recv()</code> with the addition of a couple fields. <code>from</code> is a pointer to a local  <code>struct sockaddr_storage</code> that will be filled with the IP address and port of the originating machine. <code>fromlen</code> is a pointer to a local <code>int</code> that should be initialized to <code>sizeof *from</code> or <code>sizeof(struct sockaddr_storage)</code>. When the function returns, <code>fromlen</code> will contain the length of the address actually stored in <code>from</code>.</p>
<p><code>recvfrom()</code> returns the number of bytes received, or <code>-1</code> on error (with <code>errno</code> set accordingly).</p>
<p>So, here’s a question: why do we use <code>struct sockaddr_storage</code> as the socket type? Why not <code>struct sockaddr_in</code>? Because, you see, we want to not tie ourselves down to IPv4 or IPv6. So we use the generic <code>struct sockaddr_storage</code> which we know will be big enough for either.</p>
<p>(So… here’s another question: why isn’t <code>struct sockaddr</code> itself big enough for any address? We even cast the general-purpose <code>struct sockaddr_storage</code> to the general-purpose <code>struct sockaddr</code>!
 Seems extraneous and redundant, huh. The answer is, it just isn’t big 
enough, and I’d guess that changing it at this point would be 
Problematic. So they made a new one.)</p>
<p>Remember, if you  <code>connect()</code> a datagram socket, you can then simply use <code>send()</code> and <code>recv()</code>
 for all your transactions. The socket itself is still a datagram socket
 and the packets still use UDP, but the socket interface will 
automatically add the destination and source information for you.</p>
<h2 data-number="5.9" id="close-and-shutdownget-outta-my-face"><span class="header-section-number">5.9</span> <code>close()</code> and <code>shutdown()</code>—Get outta my face!</h2>
<p>Whew! You’ve been <code>send()</code>ing and <code>recv()</code>ing 
data all day long, and you’ve had it. You’re ready to close the 
connection on your socket descriptor. This is easy. You can just use the
 regular Unix file descriptor  <code>close()</code> function:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>    close(sockfd); </span></code></pre></div>
<p>This will prevent any more reads and writes to the socket. Anyone 
attempting to read or write the socket on the remote end will receive an
 error.</p>
<p>Just in case you want a little more control over how the socket closes, you can use the  <code>shutdown()</code> function. It allows you to cut off communication in a certain direction, or both ways (just like <code>close()</code> does). Synopsis:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> shutdown(<span class="dt">int</span> sockfd, <span class="dt">int</span> how); </span></code></pre></div>
<p><code>sockfd</code> is the socket file descriptor you want to shutdown, and <code>how</code> is one of the following:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><code>how</code></th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>0</code></td>
<td>Further receives are disallowed</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>1</code></td>
<td>Further sends are disallowed</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>2</code></td>
<td>Further sends and receives are disallowed (like <code>close()</code>)</td>
</tr>
</tbody>
</table>
<p><code>shutdown()</code> returns <code>0</code> on success, and <code>-1</code> on error (with <code>errno</code> set accordingly).</p>
<p>If you deign to use <code>shutdown()</code> on unconnected datagram sockets, it will simply make the socket unavailable for further <code>send()</code> and <code>recv()</code> calls (remember that you can use these if you <code>connect()</code> your datagram socket).</p>
<p>It’s important to note that <code>shutdown()</code> doesn’t actually close the file descriptor—it just changes its usability. To free a socket descriptor, you need to use <code>close()</code>.</p>
<p>Nothing to it.</p>
<p>(Except to remember that if you’re using  Windows and  Winsock that you should call  <code>closesocket()</code> instead of <code>close()</code>.)</p>
<h2 data-number="5.10" id="getpeernamewho-are-you"><span class="header-section-number">5.10</span> <code>getpeername()</code>—Who are you?</h2>
<p> This function is so easy.</p>
<p>It’s so easy, I almost didn’t give it its own section. But here it is anyway.</p>
<p>The function <code>getpeername()</code> will tell you who is at the other end of a connected stream socket. The synopsis:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> getpeername(<span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *addr, <span class="dt">int</span> *addrlen); </span></code></pre></div>
<p><code>sockfd</code> is the descriptor of the connected stream socket, <code>addr</code> is a pointer to a <code>struct sockaddr</code> (or a <code>struct sockaddr_in</code>) that will hold the information about the other side of the connection, and <code>addrlen</code> is a pointer to an <code>int</code>, that should be initialized to <code>sizeof *addr</code> or <code>sizeof(struct sockaddr)</code>.</p>
<p>The function returns <code>-1</code> on error and sets <code>errno</code> accordingly.</p>
<p>Once you have their address, you can use  <code>inet_ntop()</code>,  <code>getnameinfo()</code>, or  <code>gethostbyaddr()</code>
 to print or get more information. No, you can’t get their login name. 
(Ok, ok. If the other computer is running an ident daemon, this is 
possible. This, however, is beyond the scope of this document. Check out
 <a href="https://tools.ietf.org/html/rfc1413">RFC 1413</a><a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> for more info.)</p>
<h2 data-number="5.11" id="gethostnamewho-am-i"><span class="header-section-number">5.11</span> <code>gethostname()</code>—Who am I?</h2>
<p> Even easier than <code>getpeername()</code> is the function <code>gethostname()</code>. It returns the name of the computer that your program is running on. The name can then be used by  <code>gethostbyname()</code>, below, to determine the  IP address of your local machine.</p>
<p>What could be more fun? I could think of a few things, but they don’t
 pertain to socket programming. Anyway, here’s the breakdown:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> gethostname(<span class="dt">char</span> *hostname, <span class="dt">size_t</span> size); </span></code></pre></div>
<p>The arguments are simple: <code>hostname</code> is a pointer to an array of chars that will contain the hostname upon the function’s return, and <code>size</code> is the length in bytes of the <code>hostname</code> array.</p>
<p>The function returns <code>0</code> on successful completion, and <code>-1</code> on error, setting <code>errno</code> as usual.</p>
<h1 data-number="6" id="client-server-background"><span class="header-section-number">6</span> Client-Server Background</h1>
<p> It’s a client-server world, baby. Just about everything on the 
network deals with client processes talking to server processes and 
vice-versa. Take <code>telnet</code>, for instance. When you connect to a remote host on port 23 with telnet (the client), a program on that host (called <code>telnetd</code>, the server) springs to life. It handles the incoming telnet connection, sets you up with a login prompt, etc.</p>
<figure>
<embed src="Beej's%20Guide%20to%20Network%20Programming_files/cs.svg" title="[Client-Server Interaction Diagram]"><figcaption aria-hidden="true">Client-Server Interaction.</figcaption>
</figure>
<p>The exchange of information between client and server is summarized in the above diagram.</p>
<p>Note that the client-server pair can speak <code>SOCK_STREAM</code>, <code>SOCK_DGRAM</code>, or anything else (as long as they’re speaking the same thing). Some good examples of client-server pairs are <code>telnet</code>/<code>telnetd</code>, <code>ftp</code>/<code>ftpd</code>, or <code>Firefox</code>/<code>Apache</code>. Every time you use <code>ftp</code>, there’s a remote program, <code>ftpd</code>, that serves you.</p>
<p>Often, there will only be one server on a machine, and that server will handle multiple clients using  <code>fork()</code>. The basic routine is: server will wait for a connection, <code>accept()</code> it, and <code>fork()</code> a child process to handle it. This is what our sample server does in the next section.</p>
<h2 data-number="6.1" id="a-simple-stream-server"><span class="header-section-number">6.1</span> A Simple Stream Server</h2>
<p> All this server does is send the string “<code>Hello, world!</code>”
 out over a stream connection. All you need to do to test this server is
 run it in one window, and telnet to it from another with:</p>
<pre><code>    $ telnet remotehostname 3490</code></pre>
<p>where <code>remotehostname</code> is the name of the machine you’re running it on.</p>
<p><a href="https://beej.us/guide/bgnet/examples/server.c">The server code</a><a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a>:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1"></a><span class="co">/*</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="co">** server.c -- a stream socket server demo</span></span>
<span id="cb46-3"><a href="#cb46-3"></a><span class="co">*/</span></span>
<span id="cb46-4"><a href="#cb46-4"></a></span>
<span id="cb46-5"><a href="#cb46-5"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb46-6"><a href="#cb46-6"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb46-7"><a href="#cb46-7"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb46-8"><a href="#cb46-8"></a><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></span>
<span id="cb46-9"><a href="#cb46-9"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb46-10"><a href="#cb46-10"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb46-11"><a href="#cb46-11"></a><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb46-12"><a href="#cb46-12"></a><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></span>
<span id="cb46-13"><a href="#cb46-13"></a><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></span>
<span id="cb46-14"><a href="#cb46-14"></a><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></span>
<span id="cb46-15"><a href="#cb46-15"></a><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></span>
<span id="cb46-16"><a href="#cb46-16"></a><span class="pp">#include </span><span class="im">&lt;signal.h&gt;</span></span>
<span id="cb46-17"><a href="#cb46-17"></a></span>
<span id="cb46-18"><a href="#cb46-18"></a><span class="pp">#define PORT "3490"  </span><span class="co">// the port users will be connecting to</span></span>
<span id="cb46-19"><a href="#cb46-19"></a></span>
<span id="cb46-20"><a href="#cb46-20"></a><span class="pp">#define BACKLOG 10   </span><span class="co">// how many pending connections queue will hold</span></span>
<span id="cb46-21"><a href="#cb46-21"></a></span>
<span id="cb46-22"><a href="#cb46-22"></a><span class="dt">void</span> sigchld_handler(<span class="dt">int</span> s)</span>
<span id="cb46-23"><a href="#cb46-23"></a>{</span>
<span id="cb46-24"><a href="#cb46-24"></a>    <span class="co">// waitpid() might overwrite errno, so we save and restore it:</span></span>
<span id="cb46-25"><a href="#cb46-25"></a>    <span class="dt">int</span> saved_errno = errno;</span>
<span id="cb46-26"><a href="#cb46-26"></a></span>
<span id="cb46-27"><a href="#cb46-27"></a>    <span class="cf">while</span>(waitpid(-<span class="dv">1</span>, NULL, WNOHANG) &gt; <span class="dv">0</span>);</span>
<span id="cb46-28"><a href="#cb46-28"></a></span>
<span id="cb46-29"><a href="#cb46-29"></a>    errno = saved_errno;</span>
<span id="cb46-30"><a href="#cb46-30"></a>}</span>
<span id="cb46-31"><a href="#cb46-31"></a></span>
<span id="cb46-32"><a href="#cb46-32"></a></span>
<span id="cb46-33"><a href="#cb46-33"></a><span class="co">// get sockaddr, IPv4 or IPv6:</span></span>
<span id="cb46-34"><a href="#cb46-34"></a><span class="dt">void</span> *get_in_addr(<span class="kw">struct</span> sockaddr *sa)</span>
<span id="cb46-35"><a href="#cb46-35"></a>{</span>
<span id="cb46-36"><a href="#cb46-36"></a>    <span class="cf">if</span> (sa-&gt;sa_family == AF_INET) {</span>
<span id="cb46-37"><a href="#cb46-37"></a>        <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in*)sa)-&gt;sin_addr);</span>
<span id="cb46-38"><a href="#cb46-38"></a>    }</span>
<span id="cb46-39"><a href="#cb46-39"></a></span>
<span id="cb46-40"><a href="#cb46-40"></a>    <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr);</span>
<span id="cb46-41"><a href="#cb46-41"></a>}</span>
<span id="cb46-42"><a href="#cb46-42"></a></span>
<span id="cb46-43"><a href="#cb46-43"></a><span class="dt">int</span> main(<span class="dt">void</span>)</span>
<span id="cb46-44"><a href="#cb46-44"></a>{</span>
<span id="cb46-45"><a href="#cb46-45"></a>    <span class="dt">int</span> sockfd, new_fd;  <span class="co">// listen on sock_fd, new connection on new_fd</span></span>
<span id="cb46-46"><a href="#cb46-46"></a>    <span class="kw">struct</span> addrinfo hints, *servinfo, *p;</span>
<span id="cb46-47"><a href="#cb46-47"></a>    <span class="kw">struct</span> sockaddr_storage their_addr; <span class="co">// connector's address information</span></span>
<span id="cb46-48"><a href="#cb46-48"></a>    socklen_t sin_size;</span>
<span id="cb46-49"><a href="#cb46-49"></a>    <span class="kw">struct</span> sigaction sa;</span>
<span id="cb46-50"><a href="#cb46-50"></a>    <span class="dt">int</span> yes=<span class="dv">1</span>;</span>
<span id="cb46-51"><a href="#cb46-51"></a>    <span class="dt">char</span> s[INET6_ADDRSTRLEN];</span>
<span id="cb46-52"><a href="#cb46-52"></a>    <span class="dt">int</span> rv;</span>
<span id="cb46-53"><a href="#cb46-53"></a></span>
<span id="cb46-54"><a href="#cb46-54"></a>    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb46-55"><a href="#cb46-55"></a>    hints.ai_family = AF_UNSPEC;</span>
<span id="cb46-56"><a href="#cb46-56"></a>    hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb46-57"><a href="#cb46-57"></a>    hints.ai_flags = AI_PASSIVE; <span class="co">// use my IP</span></span>
<span id="cb46-58"><a href="#cb46-58"></a></span>
<span id="cb46-59"><a href="#cb46-59"></a>    <span class="cf">if</span> ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</span>
<span id="cb46-60"><a href="#cb46-60"></a>        fprintf(stderr, <span class="st">"getaddrinfo: %s</span><span class="sc">\n</span><span class="st">"</span>, gai_strerror(rv));</span>
<span id="cb46-61"><a href="#cb46-61"></a>        <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb46-62"><a href="#cb46-62"></a>    }</span>
<span id="cb46-63"><a href="#cb46-63"></a></span>
<span id="cb46-64"><a href="#cb46-64"></a>    <span class="co">// loop through all the results and bind to the first we can</span></span>
<span id="cb46-65"><a href="#cb46-65"></a>    <span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</span>
<span id="cb46-66"><a href="#cb46-66"></a>        <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span>
<span id="cb46-67"><a href="#cb46-67"></a>                p-&gt;ai_protocol)) == -<span class="dv">1</span>) {</span>
<span id="cb46-68"><a href="#cb46-68"></a>            perror(<span class="st">"server: socket"</span>);</span>
<span id="cb46-69"><a href="#cb46-69"></a>            <span class="cf">continue</span>;</span>
<span id="cb46-70"><a href="#cb46-70"></a>        }</span>
<span id="cb46-71"><a href="#cb46-71"></a></span>
<span id="cb46-72"><a href="#cb46-72"></a>        <span class="cf">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes,</span>
<span id="cb46-73"><a href="#cb46-73"></a>                <span class="kw">sizeof</span>(<span class="dt">int</span>)) == -<span class="dv">1</span>) {</span>
<span id="cb46-74"><a href="#cb46-74"></a>            perror(<span class="st">"setsockopt"</span>);</span>
<span id="cb46-75"><a href="#cb46-75"></a>            exit(<span class="dv">1</span>);</span>
<span id="cb46-76"><a href="#cb46-76"></a>        }</span>
<span id="cb46-77"><a href="#cb46-77"></a></span>
<span id="cb46-78"><a href="#cb46-78"></a>        <span class="cf">if</span> (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -<span class="dv">1</span>) {</span>
<span id="cb46-79"><a href="#cb46-79"></a>            close(sockfd);</span>
<span id="cb46-80"><a href="#cb46-80"></a>            perror(<span class="st">"server: bind"</span>);</span>
<span id="cb46-81"><a href="#cb46-81"></a>            <span class="cf">continue</span>;</span>
<span id="cb46-82"><a href="#cb46-82"></a>        }</span>
<span id="cb46-83"><a href="#cb46-83"></a></span>
<span id="cb46-84"><a href="#cb46-84"></a>        <span class="cf">break</span>;</span>
<span id="cb46-85"><a href="#cb46-85"></a>    }</span>
<span id="cb46-86"><a href="#cb46-86"></a></span>
<span id="cb46-87"><a href="#cb46-87"></a>    freeaddrinfo(servinfo); <span class="co">// all done with this structure</span></span>
<span id="cb46-88"><a href="#cb46-88"></a></span>
<span id="cb46-89"><a href="#cb46-89"></a>    <span class="cf">if</span> (p == NULL)  {</span>
<span id="cb46-90"><a href="#cb46-90"></a>        fprintf(stderr, <span class="st">"server: failed to bind</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb46-91"><a href="#cb46-91"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb46-92"><a href="#cb46-92"></a>    }</span>
<span id="cb46-93"><a href="#cb46-93"></a></span>
<span id="cb46-94"><a href="#cb46-94"></a>    <span class="cf">if</span> (listen(sockfd, BACKLOG) == -<span class="dv">1</span>) {</span>
<span id="cb46-95"><a href="#cb46-95"></a>        perror(<span class="st">"listen"</span>);</span>
<span id="cb46-96"><a href="#cb46-96"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb46-97"><a href="#cb46-97"></a>    }</span>
<span id="cb46-98"><a href="#cb46-98"></a></span>
<span id="cb46-99"><a href="#cb46-99"></a>    sa.sa_handler = sigchld_handler; <span class="co">// reap all dead processes</span></span>
<span id="cb46-100"><a href="#cb46-100"></a>    sigemptyset(&amp;sa.sa_mask);</span>
<span id="cb46-101"><a href="#cb46-101"></a>    sa.sa_flags = SA_RESTART;</span>
<span id="cb46-102"><a href="#cb46-102"></a>    <span class="cf">if</span> (sigaction(SIGCHLD, &amp;sa, NULL) == -<span class="dv">1</span>) {</span>
<span id="cb46-103"><a href="#cb46-103"></a>        perror(<span class="st">"sigaction"</span>);</span>
<span id="cb46-104"><a href="#cb46-104"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb46-105"><a href="#cb46-105"></a>    }</span>
<span id="cb46-106"><a href="#cb46-106"></a></span>
<span id="cb46-107"><a href="#cb46-107"></a>    printf(<span class="st">"server: waiting for connections...</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb46-108"><a href="#cb46-108"></a></span>
<span id="cb46-109"><a href="#cb46-109"></a>    <span class="cf">while</span>(<span class="dv">1</span>) {  <span class="co">// main accept() loop</span></span>
<span id="cb46-110"><a href="#cb46-110"></a>        sin_size = <span class="kw">sizeof</span> their_addr;</span>
<span id="cb46-111"><a href="#cb46-111"></a>        new_fd = accept(sockfd, (<span class="kw">struct</span> sockaddr *)&amp;their_addr, &amp;sin_size);</span>
<span id="cb46-112"><a href="#cb46-112"></a>        <span class="cf">if</span> (new_fd == -<span class="dv">1</span>) {</span>
<span id="cb46-113"><a href="#cb46-113"></a>            perror(<span class="st">"accept"</span>);</span>
<span id="cb46-114"><a href="#cb46-114"></a>            <span class="cf">continue</span>;</span>
<span id="cb46-115"><a href="#cb46-115"></a>        }</span>
<span id="cb46-116"><a href="#cb46-116"></a></span>
<span id="cb46-117"><a href="#cb46-117"></a>        inet_ntop(their_addr.ss_family,</span>
<span id="cb46-118"><a href="#cb46-118"></a>            get_in_addr((<span class="kw">struct</span> sockaddr *)&amp;their_addr),</span>
<span id="cb46-119"><a href="#cb46-119"></a>            s, <span class="kw">sizeof</span> s);</span>
<span id="cb46-120"><a href="#cb46-120"></a>        printf(<span class="st">"server: got connection from %s</span><span class="sc">\n</span><span class="st">"</span>, s);</span>
<span id="cb46-121"><a href="#cb46-121"></a></span>
<span id="cb46-122"><a href="#cb46-122"></a>        <span class="cf">if</span> (!fork()) { <span class="co">// this is the child process</span></span>
<span id="cb46-123"><a href="#cb46-123"></a>            close(sockfd); <span class="co">// child doesn't need the listener</span></span>
<span id="cb46-124"><a href="#cb46-124"></a>            <span class="cf">if</span> (send(new_fd, <span class="st">"Hello, world!"</span>, <span class="dv">13</span>, <span class="dv">0</span>) == -<span class="dv">1</span>)</span>
<span id="cb46-125"><a href="#cb46-125"></a>                perror(<span class="st">"send"</span>);</span>
<span id="cb46-126"><a href="#cb46-126"></a>            close(new_fd);</span>
<span id="cb46-127"><a href="#cb46-127"></a>            exit(<span class="dv">0</span>);</span>
<span id="cb46-128"><a href="#cb46-128"></a>        }</span>
<span id="cb46-129"><a href="#cb46-129"></a>        close(new_fd);  <span class="co">// parent doesn't need this</span></span>
<span id="cb46-130"><a href="#cb46-130"></a>    }</span>
<span id="cb46-131"><a href="#cb46-131"></a></span>
<span id="cb46-132"><a href="#cb46-132"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb46-133"><a href="#cb46-133"></a>}</span></code></pre></div>
<p>In case you’re curious, I have the code in one big <code>main()</code> function for (I feel) syntactic clarity. Feel free to split it into smaller functions if it makes you feel better.</p>
<p>(Also, this whole  <code>sigaction()</code> thing might be new to you—that’s ok. The code that’s there is responsible for reaping  zombie processes that appear as the <code>fork()</code>ed child processes exit. If you make lots of zombies and don’t reap them, your system administrator will become agitated.)</p>
<p>You can get the data from this server by using the client listed in the next section.</p>
<h2 data-number="6.2" id="a-simple-stream-client"><span class="header-section-number">6.2</span> A Simple Stream Client</h2>
<p> This guy’s even easier than the server. All this client does is 
connect to the host you specify on the command line, port 3490. It gets 
the string that the server sends.</p>
<p><a href="https://beej.us/guide/bgnet/examples/client.c">The client source</a><a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a>:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1"></a><span class="co">/*</span></span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="co">** client.c -- a stream socket client demo</span></span>
<span id="cb47-3"><a href="#cb47-3"></a><span class="co">*/</span></span>
<span id="cb47-4"><a href="#cb47-4"></a></span>
<span id="cb47-5"><a href="#cb47-5"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb47-6"><a href="#cb47-6"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb47-7"><a href="#cb47-7"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb47-8"><a href="#cb47-8"></a><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></span>
<span id="cb47-9"><a href="#cb47-9"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb47-10"><a href="#cb47-10"></a><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></span>
<span id="cb47-11"><a href="#cb47-11"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb47-12"><a href="#cb47-12"></a><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></span>
<span id="cb47-13"><a href="#cb47-13"></a><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb47-14"><a href="#cb47-14"></a></span>
<span id="cb47-15"><a href="#cb47-15"></a><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></span>
<span id="cb47-16"><a href="#cb47-16"></a></span>
<span id="cb47-17"><a href="#cb47-17"></a><span class="pp">#define PORT "3490" </span><span class="co">// the port client will be connecting to </span></span>
<span id="cb47-18"><a href="#cb47-18"></a></span>
<span id="cb47-19"><a href="#cb47-19"></a><span class="pp">#define MAXDATASIZE 100 </span><span class="co">// max number of bytes we can get at once </span></span>
<span id="cb47-20"><a href="#cb47-20"></a></span>
<span id="cb47-21"><a href="#cb47-21"></a><span class="co">// get sockaddr, IPv4 or IPv6:</span></span>
<span id="cb47-22"><a href="#cb47-22"></a><span class="dt">void</span> *get_in_addr(<span class="kw">struct</span> sockaddr *sa)</span>
<span id="cb47-23"><a href="#cb47-23"></a>{</span>
<span id="cb47-24"><a href="#cb47-24"></a>    <span class="cf">if</span> (sa-&gt;sa_family == AF_INET) {</span>
<span id="cb47-25"><a href="#cb47-25"></a>        <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in*)sa)-&gt;sin_addr);</span>
<span id="cb47-26"><a href="#cb47-26"></a>    }</span>
<span id="cb47-27"><a href="#cb47-27"></a></span>
<span id="cb47-28"><a href="#cb47-28"></a>    <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr);</span>
<span id="cb47-29"><a href="#cb47-29"></a>}</span>
<span id="cb47-30"><a href="#cb47-30"></a></span>
<span id="cb47-31"><a href="#cb47-31"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</span>
<span id="cb47-32"><a href="#cb47-32"></a>{</span>
<span id="cb47-33"><a href="#cb47-33"></a>    <span class="dt">int</span> sockfd, numbytes;  </span>
<span id="cb47-34"><a href="#cb47-34"></a>    <span class="dt">char</span> buf[MAXDATASIZE];</span>
<span id="cb47-35"><a href="#cb47-35"></a>    <span class="kw">struct</span> addrinfo hints, *servinfo, *p;</span>
<span id="cb47-36"><a href="#cb47-36"></a>    <span class="dt">int</span> rv;</span>
<span id="cb47-37"><a href="#cb47-37"></a>    <span class="dt">char</span> s[INET6_ADDRSTRLEN];</span>
<span id="cb47-38"><a href="#cb47-38"></a></span>
<span id="cb47-39"><a href="#cb47-39"></a>    <span class="cf">if</span> (argc != <span class="dv">2</span>) {</span>
<span id="cb47-40"><a href="#cb47-40"></a>        fprintf(stderr,<span class="st">"usage: client hostname</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb47-41"><a href="#cb47-41"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb47-42"><a href="#cb47-42"></a>    }</span>
<span id="cb47-43"><a href="#cb47-43"></a></span>
<span id="cb47-44"><a href="#cb47-44"></a>    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb47-45"><a href="#cb47-45"></a>    hints.ai_family = AF_UNSPEC;</span>
<span id="cb47-46"><a href="#cb47-46"></a>    hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb47-47"><a href="#cb47-47"></a></span>
<span id="cb47-48"><a href="#cb47-48"></a>    <span class="cf">if</span> ((rv = getaddrinfo(argv[<span class="dv">1</span>], PORT, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</span>
<span id="cb47-49"><a href="#cb47-49"></a>        fprintf(stderr, <span class="st">"getaddrinfo: %s</span><span class="sc">\n</span><span class="st">"</span>, gai_strerror(rv));</span>
<span id="cb47-50"><a href="#cb47-50"></a>        <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb47-51"><a href="#cb47-51"></a>    }</span>
<span id="cb47-52"><a href="#cb47-52"></a></span>
<span id="cb47-53"><a href="#cb47-53"></a>    <span class="co">// loop through all the results and connect to the first we can</span></span>
<span id="cb47-54"><a href="#cb47-54"></a>    <span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</span>
<span id="cb47-55"><a href="#cb47-55"></a>        <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span>
<span id="cb47-56"><a href="#cb47-56"></a>                p-&gt;ai_protocol)) == -<span class="dv">1</span>) {</span>
<span id="cb47-57"><a href="#cb47-57"></a>            perror(<span class="st">"client: socket"</span>);</span>
<span id="cb47-58"><a href="#cb47-58"></a>            <span class="cf">continue</span>;</span>
<span id="cb47-59"><a href="#cb47-59"></a>        }</span>
<span id="cb47-60"><a href="#cb47-60"></a></span>
<span id="cb47-61"><a href="#cb47-61"></a>        <span class="cf">if</span> (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -<span class="dv">1</span>) {</span>
<span id="cb47-62"><a href="#cb47-62"></a>            close(sockfd);</span>
<span id="cb47-63"><a href="#cb47-63"></a>            perror(<span class="st">"client: connect"</span>);</span>
<span id="cb47-64"><a href="#cb47-64"></a>            <span class="cf">continue</span>;</span>
<span id="cb47-65"><a href="#cb47-65"></a>        }</span>
<span id="cb47-66"><a href="#cb47-66"></a></span>
<span id="cb47-67"><a href="#cb47-67"></a>        <span class="cf">break</span>;</span>
<span id="cb47-68"><a href="#cb47-68"></a>    }</span>
<span id="cb47-69"><a href="#cb47-69"></a></span>
<span id="cb47-70"><a href="#cb47-70"></a>    <span class="cf">if</span> (p == NULL) {</span>
<span id="cb47-71"><a href="#cb47-71"></a>        fprintf(stderr, <span class="st">"client: failed to connect</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb47-72"><a href="#cb47-72"></a>        <span class="cf">return</span> <span class="dv">2</span>;</span>
<span id="cb47-73"><a href="#cb47-73"></a>    }</span>
<span id="cb47-74"><a href="#cb47-74"></a></span>
<span id="cb47-75"><a href="#cb47-75"></a>    inet_ntop(p-&gt;ai_family, get_in_addr((<span class="kw">struct</span> sockaddr *)p-&gt;ai_addr),</span>
<span id="cb47-76"><a href="#cb47-76"></a>            s, <span class="kw">sizeof</span> s);</span>
<span id="cb47-77"><a href="#cb47-77"></a>    printf(<span class="st">"client: connecting to %s</span><span class="sc">\n</span><span class="st">"</span>, s);</span>
<span id="cb47-78"><a href="#cb47-78"></a></span>
<span id="cb47-79"><a href="#cb47-79"></a>    freeaddrinfo(servinfo); <span class="co">// all done with this structure</span></span>
<span id="cb47-80"><a href="#cb47-80"></a></span>
<span id="cb47-81"><a href="#cb47-81"></a>    <span class="cf">if</span> ((numbytes = recv(sockfd, buf, MAXDATASIZE-<span class="dv">1</span>, <span class="dv">0</span>)) == -<span class="dv">1</span>) {</span>
<span id="cb47-82"><a href="#cb47-82"></a>        perror(<span class="st">"recv"</span>);</span>
<span id="cb47-83"><a href="#cb47-83"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb47-84"><a href="#cb47-84"></a>    }</span>
<span id="cb47-85"><a href="#cb47-85"></a></span>
<span id="cb47-86"><a href="#cb47-86"></a>    buf[numbytes] = <span class="ch">'\0'</span>;</span>
<span id="cb47-87"><a href="#cb47-87"></a></span>
<span id="cb47-88"><a href="#cb47-88"></a>    printf(<span class="st">"client: received '%s'</span><span class="sc">\n</span><span class="st">"</span>,buf);</span>
<span id="cb47-89"><a href="#cb47-89"></a></span>
<span id="cb47-90"><a href="#cb47-90"></a>    close(sockfd);</span>
<span id="cb47-91"><a href="#cb47-91"></a></span>
<span id="cb47-92"><a href="#cb47-92"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb47-93"><a href="#cb47-93"></a>}</span></code></pre></div>
<p>Notice that if you don’t run the server before you run the client, <code>connect()</code> returns  “Connection refused”. Very useful.</p>
<h2 data-number="6.3" id="datagram"><span class="header-section-number">6.3</span> Datagram Sockets</h2>
<p>We’ve already covered the basics of UDP datagram sockets with our discussion of <code>sendto()</code> and <code>recvfrom()</code>, above, so I’ll just present a couple of sample programs: <code>talker.c</code> and <code>listener.c</code>.</p>
<p> <code>listener</code> sits on a machine waiting for an incoming packet on port 4950. <code>talker</code> sends a packet to that port, on the specified machine, that contains whatever the user enters on the command line.</p>
<p>Because datagram sockets are connectionless and just fire packets off
 into the ether with callous disregard for success, we are going to tell
 the client and server to use specifically IPv6. This way we avoid the 
situation where the server is listening on IPv6 and the client sends on 
IPv4; the data simply would not be received. (In our connected TCP 
stream sockets world, we might still have the mismatch, but the error on
 <code>connect()</code> for one address family would cause us to retry for the other.)</p>
<p>Here is the <a href="https://beej.us/guide/bgnet/examples/listener.c">source for <code>listener.c</code></a><a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1"></a><span class="co">/*</span></span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="co">** listener.c -- a datagram sockets "server" demo</span></span>
<span id="cb48-3"><a href="#cb48-3"></a><span class="co">*/</span></span>
<span id="cb48-4"><a href="#cb48-4"></a></span>
<span id="cb48-5"><a href="#cb48-5"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb48-6"><a href="#cb48-6"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb48-7"><a href="#cb48-7"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb48-8"><a href="#cb48-8"></a><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></span>
<span id="cb48-9"><a href="#cb48-9"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb48-10"><a href="#cb48-10"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb48-11"><a href="#cb48-11"></a><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb48-12"><a href="#cb48-12"></a><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></span>
<span id="cb48-13"><a href="#cb48-13"></a><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></span>
<span id="cb48-14"><a href="#cb48-14"></a><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></span>
<span id="cb48-15"><a href="#cb48-15"></a></span>
<span id="cb48-16"><a href="#cb48-16"></a><span class="pp">#define MYPORT "4950"    </span><span class="co">// the port users will be connecting to</span></span>
<span id="cb48-17"><a href="#cb48-17"></a></span>
<span id="cb48-18"><a href="#cb48-18"></a><span class="pp">#define MAXBUFLEN 100</span></span>
<span id="cb48-19"><a href="#cb48-19"></a></span>
<span id="cb48-20"><a href="#cb48-20"></a><span class="co">// get sockaddr, IPv4 or IPv6:</span></span>
<span id="cb48-21"><a href="#cb48-21"></a><span class="dt">void</span> *get_in_addr(<span class="kw">struct</span> sockaddr *sa)</span>
<span id="cb48-22"><a href="#cb48-22"></a>{</span>
<span id="cb48-23"><a href="#cb48-23"></a>    <span class="cf">if</span> (sa-&gt;sa_family == AF_INET) {</span>
<span id="cb48-24"><a href="#cb48-24"></a>        <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in*)sa)-&gt;sin_addr);</span>
<span id="cb48-25"><a href="#cb48-25"></a>    }</span>
<span id="cb48-26"><a href="#cb48-26"></a></span>
<span id="cb48-27"><a href="#cb48-27"></a>    <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr);</span>
<span id="cb48-28"><a href="#cb48-28"></a>}</span>
<span id="cb48-29"><a href="#cb48-29"></a></span>
<span id="cb48-30"><a href="#cb48-30"></a><span class="dt">int</span> main(<span class="dt">void</span>)</span>
<span id="cb48-31"><a href="#cb48-31"></a>{</span>
<span id="cb48-32"><a href="#cb48-32"></a>    <span class="dt">int</span> sockfd;</span>
<span id="cb48-33"><a href="#cb48-33"></a>    <span class="kw">struct</span> addrinfo hints, *servinfo, *p;</span>
<span id="cb48-34"><a href="#cb48-34"></a>    <span class="dt">int</span> rv;</span>
<span id="cb48-35"><a href="#cb48-35"></a>    <span class="dt">int</span> numbytes;</span>
<span id="cb48-36"><a href="#cb48-36"></a>    <span class="kw">struct</span> sockaddr_storage their_addr;</span>
<span id="cb48-37"><a href="#cb48-37"></a>    <span class="dt">char</span> buf[MAXBUFLEN];</span>
<span id="cb48-38"><a href="#cb48-38"></a>    socklen_t addr_len;</span>
<span id="cb48-39"><a href="#cb48-39"></a>    <span class="dt">char</span> s[INET6_ADDRSTRLEN];</span>
<span id="cb48-40"><a href="#cb48-40"></a></span>
<span id="cb48-41"><a href="#cb48-41"></a>    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb48-42"><a href="#cb48-42"></a>    hints.ai_family = AF_INET6; <span class="co">// set to AF_INET to use IPv4</span></span>
<span id="cb48-43"><a href="#cb48-43"></a>    hints.ai_socktype = SOCK_DGRAM;</span>
<span id="cb48-44"><a href="#cb48-44"></a>    hints.ai_flags = AI_PASSIVE; <span class="co">// use my IP</span></span>
<span id="cb48-45"><a href="#cb48-45"></a></span>
<span id="cb48-46"><a href="#cb48-46"></a>    <span class="cf">if</span> ((rv = getaddrinfo(NULL, MYPORT, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</span>
<span id="cb48-47"><a href="#cb48-47"></a>        fprintf(stderr, <span class="st">"getaddrinfo: %s</span><span class="sc">\n</span><span class="st">"</span>, gai_strerror(rv));</span>
<span id="cb48-48"><a href="#cb48-48"></a>        <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb48-49"><a href="#cb48-49"></a>    }</span>
<span id="cb48-50"><a href="#cb48-50"></a></span>
<span id="cb48-51"><a href="#cb48-51"></a>    <span class="co">// loop through all the results and bind to the first we can</span></span>
<span id="cb48-52"><a href="#cb48-52"></a>    <span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</span>
<span id="cb48-53"><a href="#cb48-53"></a>        <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span>
<span id="cb48-54"><a href="#cb48-54"></a>                p-&gt;ai_protocol)) == -<span class="dv">1</span>) {</span>
<span id="cb48-55"><a href="#cb48-55"></a>            perror(<span class="st">"listener: socket"</span>);</span>
<span id="cb48-56"><a href="#cb48-56"></a>            <span class="cf">continue</span>;</span>
<span id="cb48-57"><a href="#cb48-57"></a>        }</span>
<span id="cb48-58"><a href="#cb48-58"></a></span>
<span id="cb48-59"><a href="#cb48-59"></a>        <span class="cf">if</span> (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -<span class="dv">1</span>) {</span>
<span id="cb48-60"><a href="#cb48-60"></a>            close(sockfd);</span>
<span id="cb48-61"><a href="#cb48-61"></a>            perror(<span class="st">"listener: bind"</span>);</span>
<span id="cb48-62"><a href="#cb48-62"></a>            <span class="cf">continue</span>;</span>
<span id="cb48-63"><a href="#cb48-63"></a>        }</span>
<span id="cb48-64"><a href="#cb48-64"></a></span>
<span id="cb48-65"><a href="#cb48-65"></a>        <span class="cf">break</span>;</span>
<span id="cb48-66"><a href="#cb48-66"></a>    }</span>
<span id="cb48-67"><a href="#cb48-67"></a></span>
<span id="cb48-68"><a href="#cb48-68"></a>    <span class="cf">if</span> (p == NULL) {</span>
<span id="cb48-69"><a href="#cb48-69"></a>        fprintf(stderr, <span class="st">"listener: failed to bind socket</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb48-70"><a href="#cb48-70"></a>        <span class="cf">return</span> <span class="dv">2</span>;</span>
<span id="cb48-71"><a href="#cb48-71"></a>    }</span>
<span id="cb48-72"><a href="#cb48-72"></a></span>
<span id="cb48-73"><a href="#cb48-73"></a>    freeaddrinfo(servinfo);</span>
<span id="cb48-74"><a href="#cb48-74"></a></span>
<span id="cb48-75"><a href="#cb48-75"></a>    printf(<span class="st">"listener: waiting to recvfrom...</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb48-76"><a href="#cb48-76"></a></span>
<span id="cb48-77"><a href="#cb48-77"></a>    addr_len = <span class="kw">sizeof</span> their_addr;</span>
<span id="cb48-78"><a href="#cb48-78"></a>    <span class="cf">if</span> ((numbytes = recvfrom(sockfd, buf, MAXBUFLEN-<span class="dv">1</span> , <span class="dv">0</span>,</span>
<span id="cb48-79"><a href="#cb48-79"></a>        (<span class="kw">struct</span> sockaddr *)&amp;their_addr, &amp;addr_len)) == -<span class="dv">1</span>) {</span>
<span id="cb48-80"><a href="#cb48-80"></a>        perror(<span class="st">"recvfrom"</span>);</span>
<span id="cb48-81"><a href="#cb48-81"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb48-82"><a href="#cb48-82"></a>    }</span>
<span id="cb48-83"><a href="#cb48-83"></a></span>
<span id="cb48-84"><a href="#cb48-84"></a>    printf(<span class="st">"listener: got packet from %s</span><span class="sc">\n</span><span class="st">"</span>,</span>
<span id="cb48-85"><a href="#cb48-85"></a>        inet_ntop(their_addr.ss_family,</span>
<span id="cb48-86"><a href="#cb48-86"></a>            get_in_addr((<span class="kw">struct</span> sockaddr *)&amp;their_addr),</span>
<span id="cb48-87"><a href="#cb48-87"></a>            s, <span class="kw">sizeof</span> s));</span>
<span id="cb48-88"><a href="#cb48-88"></a>    printf(<span class="st">"listener: packet is %d bytes long</span><span class="sc">\n</span><span class="st">"</span>, numbytes);</span>
<span id="cb48-89"><a href="#cb48-89"></a>    buf[numbytes] = <span class="ch">'\0'</span>;</span>
<span id="cb48-90"><a href="#cb48-90"></a>    printf(<span class="st">"listener: packet contains </span><span class="sc">\"</span><span class="st">%s</span><span class="sc">\"\n</span><span class="st">"</span>, buf);</span>
<span id="cb48-91"><a href="#cb48-91"></a></span>
<span id="cb48-92"><a href="#cb48-92"></a>    close(sockfd);</span>
<span id="cb48-93"><a href="#cb48-93"></a></span>
<span id="cb48-94"><a href="#cb48-94"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb48-95"><a href="#cb48-95"></a>}</span></code></pre></div>
<p>Notice that in our call to <code>getaddrinfo()</code> we’re finally using <code>SOCK_DGRAM</code>. Also, note that there’s no need to <code>listen()</code> or <code>accept()</code>. This is one of the perks of using unconnected datagram sockets!</p>
<p> Next comes the <a href="https://beej.us/guide/bgnet/examples/talker.c">source for <code>talker.c</code></a><a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a>:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1"></a><span class="co">/*</span></span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="co">** talker.c -- a datagram "client" demo</span></span>
<span id="cb49-3"><a href="#cb49-3"></a><span class="co">*/</span></span>
<span id="cb49-4"><a href="#cb49-4"></a></span>
<span id="cb49-5"><a href="#cb49-5"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb49-6"><a href="#cb49-6"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb49-7"><a href="#cb49-7"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb49-8"><a href="#cb49-8"></a><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></span>
<span id="cb49-9"><a href="#cb49-9"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb49-10"><a href="#cb49-10"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb49-11"><a href="#cb49-11"></a><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb49-12"><a href="#cb49-12"></a><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></span>
<span id="cb49-13"><a href="#cb49-13"></a><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></span>
<span id="cb49-14"><a href="#cb49-14"></a><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></span>
<span id="cb49-15"><a href="#cb49-15"></a></span>
<span id="cb49-16"><a href="#cb49-16"></a><span class="pp">#define SERVERPORT "4950"    </span><span class="co">// the port users will be connecting to</span></span>
<span id="cb49-17"><a href="#cb49-17"></a></span>
<span id="cb49-18"><a href="#cb49-18"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</span>
<span id="cb49-19"><a href="#cb49-19"></a>{</span>
<span id="cb49-20"><a href="#cb49-20"></a>    <span class="dt">int</span> sockfd;</span>
<span id="cb49-21"><a href="#cb49-21"></a>    <span class="kw">struct</span> addrinfo hints, *servinfo, *p;</span>
<span id="cb49-22"><a href="#cb49-22"></a>    <span class="dt">int</span> rv;</span>
<span id="cb49-23"><a href="#cb49-23"></a>    <span class="dt">int</span> numbytes;</span>
<span id="cb49-24"><a href="#cb49-24"></a></span>
<span id="cb49-25"><a href="#cb49-25"></a>    <span class="cf">if</span> (argc != <span class="dv">3</span>) {</span>
<span id="cb49-26"><a href="#cb49-26"></a>        fprintf(stderr,<span class="st">"usage: talker hostname message</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb49-27"><a href="#cb49-27"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb49-28"><a href="#cb49-28"></a>    }</span>
<span id="cb49-29"><a href="#cb49-29"></a></span>
<span id="cb49-30"><a href="#cb49-30"></a>    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb49-31"><a href="#cb49-31"></a>    hints.ai_family = AF_INET6; <span class="co">// set to AF_INET to use IPv4</span></span>
<span id="cb49-32"><a href="#cb49-32"></a>    hints.ai_socktype = SOCK_DGRAM;</span>
<span id="cb49-33"><a href="#cb49-33"></a></span>
<span id="cb49-34"><a href="#cb49-34"></a>    <span class="cf">if</span> ((rv = getaddrinfo(argv[<span class="dv">1</span>], SERVERPORT, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</span>
<span id="cb49-35"><a href="#cb49-35"></a>        fprintf(stderr, <span class="st">"getaddrinfo: %s</span><span class="sc">\n</span><span class="st">"</span>, gai_strerror(rv));</span>
<span id="cb49-36"><a href="#cb49-36"></a>        <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb49-37"><a href="#cb49-37"></a>    }</span>
<span id="cb49-38"><a href="#cb49-38"></a></span>
<span id="cb49-39"><a href="#cb49-39"></a>    <span class="co">// loop through all the results and make a socket</span></span>
<span id="cb49-40"><a href="#cb49-40"></a>    <span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</span>
<span id="cb49-41"><a href="#cb49-41"></a>        <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span>
<span id="cb49-42"><a href="#cb49-42"></a>                p-&gt;ai_protocol)) == -<span class="dv">1</span>) {</span>
<span id="cb49-43"><a href="#cb49-43"></a>            perror(<span class="st">"talker: socket"</span>);</span>
<span id="cb49-44"><a href="#cb49-44"></a>            <span class="cf">continue</span>;</span>
<span id="cb49-45"><a href="#cb49-45"></a>        }</span>
<span id="cb49-46"><a href="#cb49-46"></a></span>
<span id="cb49-47"><a href="#cb49-47"></a>        <span class="cf">break</span>;</span>
<span id="cb49-48"><a href="#cb49-48"></a>    }</span>
<span id="cb49-49"><a href="#cb49-49"></a></span>
<span id="cb49-50"><a href="#cb49-50"></a>    <span class="cf">if</span> (p == NULL) {</span>
<span id="cb49-51"><a href="#cb49-51"></a>        fprintf(stderr, <span class="st">"talker: failed to create socket</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb49-52"><a href="#cb49-52"></a>        <span class="cf">return</span> <span class="dv">2</span>;</span>
<span id="cb49-53"><a href="#cb49-53"></a>    }</span>
<span id="cb49-54"><a href="#cb49-54"></a></span>
<span id="cb49-55"><a href="#cb49-55"></a>    <span class="cf">if</span> ((numbytes = sendto(sockfd, argv[<span class="dv">2</span>], strlen(argv[<span class="dv">2</span>]), <span class="dv">0</span>,</span>
<span id="cb49-56"><a href="#cb49-56"></a>             p-&gt;ai_addr, p-&gt;ai_addrlen)) == -<span class="dv">1</span>) {</span>
<span id="cb49-57"><a href="#cb49-57"></a>        perror(<span class="st">"talker: sendto"</span>);</span>
<span id="cb49-58"><a href="#cb49-58"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb49-59"><a href="#cb49-59"></a>    }</span>
<span id="cb49-60"><a href="#cb49-60"></a></span>
<span id="cb49-61"><a href="#cb49-61"></a>    freeaddrinfo(servinfo);</span>
<span id="cb49-62"><a href="#cb49-62"></a></span>
<span id="cb49-63"><a href="#cb49-63"></a>    printf(<span class="st">"talker: sent %d bytes to %s</span><span class="sc">\n</span><span class="st">"</span>, numbytes, argv[<span class="dv">1</span>]);</span>
<span id="cb49-64"><a href="#cb49-64"></a>    close(sockfd);</span>
<span id="cb49-65"><a href="#cb49-65"></a></span>
<span id="cb49-66"><a href="#cb49-66"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb49-67"><a href="#cb49-67"></a>}</span></code></pre></div>
<p>And that’s all there is to it! Run <code>listener</code> on some machine, then run <code>talker</code> on another. Watch them communicate! Fun G-rated excitement for the entire nuclear family!</p>
<p>You don’t even have to run the server this time! You can run <code>talker</code> by itself, and it just happily fires packets off into the ether where they disappear if no one is ready with a <code>recvfrom()</code> on the other side. Remember: data sent using UDP datagram sockets isn’t guaranteed to arrive!</p>
<p>Except for one more tiny detail that I’ve mentioned many times in the
 past:  connected datagram sockets. I need to talk about this here, 
since we’re in the datagram section of the document. Let’s say that <code>talker</code> calls <code>connect()</code> and specifies the <code>listener</code>’s address. From that point on, <code>talker</code> may only sent to and receive from the address specified by <code>connect()</code>. For this reason, you don’t have to use <code>sendto()</code> and <code>recvfrom()</code>; you can simply use <code>send()</code> and <code>recv()</code>.</p>
<h1 data-number="7" id="slightly-advanced-techniques"><span class="header-section-number">7</span> Slightly Advanced Techniques</h1>
<p>These aren’t <em>really</em> advanced, but they’re getting out of the
 more basic levels we’ve already covered. In fact, if you’ve gotten this
 far, you should consider yourself fairly accomplished in the basics of 
Unix network programming! Congratulations!</p>
<p>So here we go into the brave new world of some of the more esoteric things you might want to learn about sockets. Have at it!</p>
<h2 data-number="7.1" id="blocking"><span class="header-section-number">7.1</span> Blocking</h2>
<p> Blocking. You’ve heard about it—now what the heck is it? In a 
nutshell, “block” is techie jargon for “sleep”. You probably noticed 
that when you run <code>listener</code>, above, it just sits there until a packet arrives. What happened is that it called <code>recvfrom()</code>, there was no data, and so <code>recvfrom()</code> is said to “block” (that is, sleep there) until some data arrives.</p>
<p>Lots of functions block. <code>accept()</code> blocks. All the <code>recv()</code> functions block. The reason they can do this is because they’re allowed to. When you first create the socket descriptor with <code>socket()</code>, the kernel sets it to blocking.  If you don’t want a socket to be blocking, you have to make a call to  <code>fcntl()</code>:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb50-2"><a href="#cb50-2"></a><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></span>
<span id="cb50-3"><a href="#cb50-3"></a>.</span>
<span id="cb50-4"><a href="#cb50-4"></a>.</span>
<span id="cb50-5"><a href="#cb50-5"></a>.</span>
<span id="cb50-6"><a href="#cb50-6"></a>sockfd = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</span>
<span id="cb50-7"><a href="#cb50-7"></a>fcntl(sockfd, F_SETFL, O_NONBLOCK);</span>
<span id="cb50-8"><a href="#cb50-8"></a>.</span>
<span id="cb50-9"><a href="#cb50-9"></a>.</span>
<span id="cb50-10"><a href="#cb50-10"></a>. </span></code></pre></div>
<p>By setting a socket to non-blocking, you can effectively “poll” the 
socket for information. If you try to read from a non-blocking socket 
and there’s no data there, it’s not allowed to block—it will return <code>-1</code> and <code>errno</code> will be set to  <code>EAGAIN</code> or  <code>EWOULDBLOCK</code>.</p>
<p>(Wait—it can return  <code>EAGAIN</code> <em>or</em>  <code>EWOULDBLOCK</code>?
 Which do you check for? The specification doesn’t actually specify 
which your system will return, so for portability, check them both.)</p>
<p>Generally speaking, however, this type of polling is a bad idea. If 
you put your program in a busy-wait looking for data on the socket, 
you’ll suck up CPU time like it was going out of style. A more elegant 
solution for checking to see if there’s data waiting to be read comes in
 the following section on  <code>poll()</code>.</p>
<h2 data-number="7.2" id="poll"><span class="header-section-number">7.2</span> <code>poll()</code>—Synchronous I/O Multiplexing</h2>
<p> What you really want to be able to do is somehow monitor a <em>bunch</em>
 of sockets at once and then handle the ones that have data ready. This 
way you don’t have to continously poll all those sockets to see which 
are ready to read.</p>
<blockquote>
<p><em>A word of warning: <code>poll()</code> is horribly slow when it 
comes to giant numbers of connections. In those circumstances, you’ll 
get better performance out of an event library such as <a href="https://libevent.org/">libevent</a><a href="#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a> that attempts to use the fastest possible method availabile on your system.</em></p>
</blockquote>
<p>So how can you avoid polling? Not slightly ironically, you can avoid polling by using the <code>poll()</code>
 system call. In a nutshell, we’re going to ask the operating system to 
do all the dirty work for us, and just let us know when some data is 
ready to read on which sockets. In the meantime, our process can go to 
sleep, saving system resources.</p>
<p>The general gameplan is to keep an array of <code>struct pollfd</code>s
 with information about which socket descriptors we want to monitor, and
 what kind of events we want to monitor for. The OS will block on the <code>poll()</code> call until one of those events occurs (e.g.&nbsp;“socket ready to read!”) or until a user-specified timeout occurs.</p>
<p>Usefully, a <code>listen()</code>ing socket will return “ready to read” when a new incoming connection is ready to be <code>accept()</code>ed.</p>
<p>That’s enough banter. How do we use this?</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;poll.h&gt;</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> poll(<span class="kw">struct</span> pollfd fds[], nfds_t nfds, <span class="dt">int</span> timeout);</span></code></pre></div>
<p><code>fds</code> is our array of information (which sockets to monitor for what), <code>nfds</code> is the count of elements in the array, and <code>timeout</code> is a timeout in milliseconds. It returns the number of elements in the array that have had an event occur.</p>
<p>Let’s have a look at that <code>struct</code>:</p>
<p></p>
<div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> pollfd {</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> fd;         <span class="co">// the socket descriptor</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">short</span> events;   <span class="co">// bitmap of events we're interested in</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">short</span> revents;  <span class="co">// when poll() returns, bitmap of events that occurred</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    };</span></code></pre></div>
<p>So we’re going to have an array of those, and we’ll see the <code>fd</code> field for each element to a socket descriptor we’re interested in monitoring. And then we’ll set the <code>events</code> field to indicate the type of events we’re interested in.</p>
<p>The <code>events</code> field is the bitwise-OR of the following:</p>
<table>
<thead>
<tr class="header">
<th>Macro</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>POLLIN</code></td>
<td>Alert me when data is ready to <code>recv()</code> on this socket.</td>
</tr>
<tr class="even">
<td><code>POLLOUT</code></td>
<td>Alert me when I can <code>send()</code> data to this socket without blocking.</td>
</tr>
</tbody>
</table>
<p>Once you have your array of <code>struct pollfd</code>s in order, then you can pass it to <code>poll()</code>,
 also passing the size of the array, as well as a timeout value in 
milliseconds. (You can specify a negative timeout to wait forever.)</p>
<p>After <code>poll()</code> returns, you can check the <code>revents</code> field to see if <code>POLLIN</code> or <code>POLLOUT</code> is set, indicating that event occurred.</p>
<p>(There’s actually more that you can do with the <code>poll()</code> call. See the <a href="#pollman"><code>poll()</code> man page, below</a>, for more details.)</p>
<p>Here’s <a href="https://beej.us/guide/bgnet/examples/poll.c">an example</a><a href="#fn28" class="footnote-ref" id="fnref28" role="doc-noteref"><sup>28</sup></a> where we’ll wait 2.5 seconds for data to be ready to read from standard input, i.e.&nbsp;when you hit <code>RETURN</code>:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb53-2"><a href="#cb53-2"></a><span class="pp">#include </span><span class="im">&lt;poll.h&gt;</span></span>
<span id="cb53-3"><a href="#cb53-3"></a></span>
<span id="cb53-4"><a href="#cb53-4"></a><span class="dt">int</span> main(<span class="dt">void</span>)</span>
<span id="cb53-5"><a href="#cb53-5"></a>{</span>
<span id="cb53-6"><a href="#cb53-6"></a>    <span class="kw">struct</span> pollfd pfds[<span class="dv">1</span>]; <span class="co">// More if you want to monitor more</span></span>
<span id="cb53-7"><a href="#cb53-7"></a></span>
<span id="cb53-8"><a href="#cb53-8"></a>    pfds[<span class="dv">0</span>].fd = <span class="dv">0</span>;          <span class="co">// Standard input</span></span>
<span id="cb53-9"><a href="#cb53-9"></a>    pfds[<span class="dv">0</span>].events = POLLIN; <span class="co">// Tell me when ready to read</span></span>
<span id="cb53-10"><a href="#cb53-10"></a></span>
<span id="cb53-11"><a href="#cb53-11"></a>    <span class="co">// If you needed to monitor other things, as well:</span></span>
<span id="cb53-12"><a href="#cb53-12"></a>    <span class="co">//pfds[1].fd = some_socket; // Some socket descriptor</span></span>
<span id="cb53-13"><a href="#cb53-13"></a>    <span class="co">//pfds[1].events = POLLIN;  // Tell me when ready to read</span></span>
<span id="cb53-14"><a href="#cb53-14"></a></span>
<span id="cb53-15"><a href="#cb53-15"></a>    printf(<span class="st">"Hit RETURN or wait 2.5 seconds for timeout</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb53-16"><a href="#cb53-16"></a></span>
<span id="cb53-17"><a href="#cb53-17"></a>    <span class="dt">int</span> num_events = poll(pfds, <span class="dv">1</span>, <span class="dv">2500</span>); <span class="co">// 2.5 second timeout</span></span>
<span id="cb53-18"><a href="#cb53-18"></a></span>
<span id="cb53-19"><a href="#cb53-19"></a>    <span class="cf">if</span> (num_events == <span class="dv">0</span>) {</span>
<span id="cb53-20"><a href="#cb53-20"></a>        printf(<span class="st">"Poll timed out!</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb53-21"><a href="#cb53-21"></a>    } <span class="cf">else</span> {</span>
<span id="cb53-22"><a href="#cb53-22"></a>        <span class="dt">int</span> pollin_happened = pfds[<span class="dv">0</span>].revents &amp; POLLIN;</span>
<span id="cb53-23"><a href="#cb53-23"></a></span>
<span id="cb53-24"><a href="#cb53-24"></a>        <span class="cf">if</span> (pollin_happened) {</span>
<span id="cb53-25"><a href="#cb53-25"></a>            printf(<span class="st">"File descriptor %d is ready to read</span><span class="sc">\n</span><span class="st">"</span>, pfds[<span class="dv">0</span>].fd);</span>
<span id="cb53-26"><a href="#cb53-26"></a>        } <span class="cf">else</span> {</span>
<span id="cb53-27"><a href="#cb53-27"></a>            printf(<span class="st">"Unexpected event occurred: %d</span><span class="sc">\n</span><span class="st">"</span>, pfds[<span class="dv">0</span>].revents);</span>
<span id="cb53-28"><a href="#cb53-28"></a>        }</span>
<span id="cb53-29"><a href="#cb53-29"></a>    }</span>
<span id="cb53-30"><a href="#cb53-30"></a></span>
<span id="cb53-31"><a href="#cb53-31"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb53-32"><a href="#cb53-32"></a>}</span></code></pre></div>
<p>Notice again that <code>poll()</code> returns the number of elements in the <code>pfds</code> array for which events have occurred. It doesn’t tell you <em>which</em> elements in the array (you still have to scan for that), but it does tell you how many entries have a non-zero <code>revents</code> field (so you can stop scanning after you find that many).</p>
<p>A couple questions might come up here: how to add new file descriptors to the set I pass to <code>poll()</code>? For this, simply make sure you have enough space in the array for all you need, or <code>realloc()</code> more space as needed.</p>
<p>What about deleting items from the set? For this, you can copy the 
last element in the array over-top the one you’re deleting. And then 
pass in one fewer as the count to <code>poll()</code>. Another option is that you can set any <code>fd</code> field to a negative number and <code>poll()</code> will ignore it.</p>
<p>How can we put it all together into a chat server that you can <code>telnet</code> to?</p>
<p>What we’ll do is start a listener socket, and add it to the set of file descriptors to <code>poll()</code>. (It will show ready-to-read when there’s an incoming connection.)</p>
<p>Then we’ll add new connections to our <code>struct pollfd</code> array. And we’ll grow it dynamically if we run out of space.</p>
<p>When a connection is closed, we’ll remove it from the array.</p>
<p>And when a connection is ready-to-read, we’ll read the data from it 
and send that data to all the other connections so they can see what the
 other users typed.</p>
<p>So give <a href="https://beej.us/guide/bgnet/examples/pollserver.c">this poll server</a><a href="#fn29" class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a> a try. Run it in one window, then <code>telnet localhost 9034</code>
 from a number of other terminal windows. You should be able to see what
 you type in one window in the other ones (after you hit RETURN).</p>
<p>Not only that, but if you hit <code>CTRL-]</code> and type <code>quit</code> to exit <code>telnet</code>, the server should detect the disconnection and remove you from the array of file descriptors.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1"></a><span class="co">/*</span></span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="co">** pollserver.c -- a cheezy multiperson chat server</span></span>
<span id="cb54-3"><a href="#cb54-3"></a><span class="co">*/</span></span>
<span id="cb54-4"><a href="#cb54-4"></a></span>
<span id="cb54-5"><a href="#cb54-5"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb54-6"><a href="#cb54-6"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb54-7"><a href="#cb54-7"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb54-8"><a href="#cb54-8"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb54-9"><a href="#cb54-9"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb54-10"><a href="#cb54-10"></a><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb54-11"><a href="#cb54-11"></a><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></span>
<span id="cb54-12"><a href="#cb54-12"></a><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></span>
<span id="cb54-13"><a href="#cb54-13"></a><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></span>
<span id="cb54-14"><a href="#cb54-14"></a><span class="pp">#include </span><span class="im">&lt;poll.h&gt;</span></span>
<span id="cb54-15"><a href="#cb54-15"></a></span>
<span id="cb54-16"><a href="#cb54-16"></a><span class="pp">#define PORT "9034"   </span><span class="co">// Port we're listening on</span></span>
<span id="cb54-17"><a href="#cb54-17"></a></span>
<span id="cb54-18"><a href="#cb54-18"></a><span class="co">// Get sockaddr, IPv4 or IPv6:</span></span>
<span id="cb54-19"><a href="#cb54-19"></a><span class="dt">void</span> *get_in_addr(<span class="kw">struct</span> sockaddr *sa)</span>
<span id="cb54-20"><a href="#cb54-20"></a>{</span>
<span id="cb54-21"><a href="#cb54-21"></a>    <span class="cf">if</span> (sa-&gt;sa_family == AF_INET) {</span>
<span id="cb54-22"><a href="#cb54-22"></a>        <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in*)sa)-&gt;sin_addr);</span>
<span id="cb54-23"><a href="#cb54-23"></a>    }</span>
<span id="cb54-24"><a href="#cb54-24"></a></span>
<span id="cb54-25"><a href="#cb54-25"></a>    <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr);</span>
<span id="cb54-26"><a href="#cb54-26"></a>}</span>
<span id="cb54-27"><a href="#cb54-27"></a></span>
<span id="cb54-28"><a href="#cb54-28"></a><span class="co">// Return a listening socket</span></span>
<span id="cb54-29"><a href="#cb54-29"></a><span class="dt">int</span> get_listener_socket(<span class="dt">void</span>)</span>
<span id="cb54-30"><a href="#cb54-30"></a>{</span>
<span id="cb54-31"><a href="#cb54-31"></a>    <span class="dt">int</span> listener;     <span class="co">// Listening socket descriptor</span></span>
<span id="cb54-32"><a href="#cb54-32"></a>    <span class="dt">int</span> yes=<span class="dv">1</span>;        <span class="co">// For setsockopt() SO_REUSEADDR, below</span></span>
<span id="cb54-33"><a href="#cb54-33"></a>    <span class="dt">int</span> rv;</span>
<span id="cb54-34"><a href="#cb54-34"></a></span>
<span id="cb54-35"><a href="#cb54-35"></a>    <span class="kw">struct</span> addrinfo hints, *ai, *p;</span>
<span id="cb54-36"><a href="#cb54-36"></a></span>
<span id="cb54-37"><a href="#cb54-37"></a>    <span class="co">// Get us a socket and bind it</span></span>
<span id="cb54-38"><a href="#cb54-38"></a>    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb54-39"><a href="#cb54-39"></a>    hints.ai_family = AF_UNSPEC;</span>
<span id="cb54-40"><a href="#cb54-40"></a>    hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb54-41"><a href="#cb54-41"></a>    hints.ai_flags = AI_PASSIVE;</span>
<span id="cb54-42"><a href="#cb54-42"></a>    <span class="cf">if</span> ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;ai)) != <span class="dv">0</span>) {</span>
<span id="cb54-43"><a href="#cb54-43"></a>        fprintf(stderr, <span class="st">"selectserver: %s</span><span class="sc">\n</span><span class="st">"</span>, gai_strerror(rv));</span>
<span id="cb54-44"><a href="#cb54-44"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb54-45"><a href="#cb54-45"></a>    }</span>
<span id="cb54-46"><a href="#cb54-46"></a>    </span>
<span id="cb54-47"><a href="#cb54-47"></a>    <span class="cf">for</span>(p = ai; p != NULL; p = p-&gt;ai_next) {</span>
<span id="cb54-48"><a href="#cb54-48"></a>        listener = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);</span>
<span id="cb54-49"><a href="#cb54-49"></a>        <span class="cf">if</span> (listener &lt; <span class="dv">0</span>) { </span>
<span id="cb54-50"><a href="#cb54-50"></a>            <span class="cf">continue</span>;</span>
<span id="cb54-51"><a href="#cb54-51"></a>        }</span>
<span id="cb54-52"><a href="#cb54-52"></a>        </span>
<span id="cb54-53"><a href="#cb54-53"></a>        <span class="co">// Lose the pesky "address already in use" error message</span></span>
<span id="cb54-54"><a href="#cb54-54"></a>        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, <span class="kw">sizeof</span>(<span class="dt">int</span>));</span>
<span id="cb54-55"><a href="#cb54-55"></a></span>
<span id="cb54-56"><a href="#cb54-56"></a>        <span class="cf">if</span> (bind(listener, p-&gt;ai_addr, p-&gt;ai_addrlen) &lt; <span class="dv">0</span>) {</span>
<span id="cb54-57"><a href="#cb54-57"></a>            close(listener);</span>
<span id="cb54-58"><a href="#cb54-58"></a>            <span class="cf">continue</span>;</span>
<span id="cb54-59"><a href="#cb54-59"></a>        }</span>
<span id="cb54-60"><a href="#cb54-60"></a></span>
<span id="cb54-61"><a href="#cb54-61"></a>        <span class="cf">break</span>;</span>
<span id="cb54-62"><a href="#cb54-62"></a>    }</span>
<span id="cb54-63"><a href="#cb54-63"></a></span>
<span id="cb54-64"><a href="#cb54-64"></a>    freeaddrinfo(ai); <span class="co">// All done with this</span></span>
<span id="cb54-65"><a href="#cb54-65"></a></span>
<span id="cb54-66"><a href="#cb54-66"></a>    <span class="co">// If we got here, it means we didn't get bound</span></span>
<span id="cb54-67"><a href="#cb54-67"></a>    <span class="cf">if</span> (p == NULL) {</span>
<span id="cb54-68"><a href="#cb54-68"></a>        <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb54-69"><a href="#cb54-69"></a>    }</span>
<span id="cb54-70"><a href="#cb54-70"></a></span>
<span id="cb54-71"><a href="#cb54-71"></a>    <span class="co">// Listen</span></span>
<span id="cb54-72"><a href="#cb54-72"></a>    <span class="cf">if</span> (listen(listener, <span class="dv">10</span>) == -<span class="dv">1</span>) {</span>
<span id="cb54-73"><a href="#cb54-73"></a>        <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb54-74"><a href="#cb54-74"></a>    }</span>
<span id="cb54-75"><a href="#cb54-75"></a></span>
<span id="cb54-76"><a href="#cb54-76"></a>    <span class="cf">return</span> listener;</span>
<span id="cb54-77"><a href="#cb54-77"></a>}</span>
<span id="cb54-78"><a href="#cb54-78"></a></span>
<span id="cb54-79"><a href="#cb54-79"></a><span class="co">// Add a new file descriptor to the set</span></span>
<span id="cb54-80"><a href="#cb54-80"></a><span class="dt">void</span> add_to_pfds(<span class="kw">struct</span> pollfd *pfds[], <span class="dt">int</span> newfd, <span class="dt">int</span> *fd_count, <span class="dt">int</span> *fd_size)</span>
<span id="cb54-81"><a href="#cb54-81"></a>{</span>
<span id="cb54-82"><a href="#cb54-82"></a>    <span class="co">// If we don't have room, add more space in the pfds array</span></span>
<span id="cb54-83"><a href="#cb54-83"></a>    <span class="cf">if</span> (*fd_count == *fd_size) {</span>
<span id="cb54-84"><a href="#cb54-84"></a>        *fd_size *= <span class="dv">2</span>; <span class="co">// Double it</span></span>
<span id="cb54-85"><a href="#cb54-85"></a></span>
<span id="cb54-86"><a href="#cb54-86"></a>        *pfds = realloc(*pfds, <span class="kw">sizeof</span>(**pfds) * (*fd_size));</span>
<span id="cb54-87"><a href="#cb54-87"></a>    }</span>
<span id="cb54-88"><a href="#cb54-88"></a></span>
<span id="cb54-89"><a href="#cb54-89"></a>    (*pfds)[*fd_count].fd = newfd;</span>
<span id="cb54-90"><a href="#cb54-90"></a>    (*pfds)[*fd_count].events = POLLIN; <span class="co">// Check ready-to-read</span></span>
<span id="cb54-91"><a href="#cb54-91"></a></span>
<span id="cb54-92"><a href="#cb54-92"></a>    (*fd_count)++;</span>
<span id="cb54-93"><a href="#cb54-93"></a>}</span>
<span id="cb54-94"><a href="#cb54-94"></a></span>
<span id="cb54-95"><a href="#cb54-95"></a><span class="co">// Remove an index from the set</span></span>
<span id="cb54-96"><a href="#cb54-96"></a><span class="dt">void</span> del_from_pfds(<span class="kw">struct</span> pollfd pfds[], <span class="dt">int</span> i, <span class="dt">int</span> *fd_count)</span>
<span id="cb54-97"><a href="#cb54-97"></a>{</span>
<span id="cb54-98"><a href="#cb54-98"></a>    <span class="co">// Copy the one from the end over this one</span></span>
<span id="cb54-99"><a href="#cb54-99"></a>    pfds[i] = pfds[*fd_count-<span class="dv">1</span>];</span>
<span id="cb54-100"><a href="#cb54-100"></a></span>
<span id="cb54-101"><a href="#cb54-101"></a>    (*fd_count)--;</span>
<span id="cb54-102"><a href="#cb54-102"></a>}</span>
<span id="cb54-103"><a href="#cb54-103"></a></span>
<span id="cb54-104"><a href="#cb54-104"></a><span class="co">// Main</span></span>
<span id="cb54-105"><a href="#cb54-105"></a><span class="dt">int</span> main(<span class="dt">void</span>)</span>
<span id="cb54-106"><a href="#cb54-106"></a>{</span>
<span id="cb54-107"><a href="#cb54-107"></a>    <span class="dt">int</span> listener;     <span class="co">// Listening socket descriptor</span></span>
<span id="cb54-108"><a href="#cb54-108"></a></span>
<span id="cb54-109"><a href="#cb54-109"></a>    <span class="dt">int</span> newfd;        <span class="co">// Newly accept()ed socket descriptor</span></span>
<span id="cb54-110"><a href="#cb54-110"></a>    <span class="kw">struct</span> sockaddr_storage remoteaddr; <span class="co">// Client address</span></span>
<span id="cb54-111"><a href="#cb54-111"></a>    socklen_t addrlen;</span>
<span id="cb54-112"><a href="#cb54-112"></a></span>
<span id="cb54-113"><a href="#cb54-113"></a>    <span class="dt">char</span> buf[<span class="dv">256</span>];    <span class="co">// Buffer for client data</span></span>
<span id="cb54-114"><a href="#cb54-114"></a></span>
<span id="cb54-115"><a href="#cb54-115"></a>    <span class="dt">char</span> remoteIP[INET6_ADDRSTRLEN];</span>
<span id="cb54-116"><a href="#cb54-116"></a></span>
<span id="cb54-117"><a href="#cb54-117"></a>    <span class="co">// Start off with room for 5 connections</span></span>
<span id="cb54-118"><a href="#cb54-118"></a>    <span class="co">// (We'll realloc as necessary)</span></span>
<span id="cb54-119"><a href="#cb54-119"></a>    <span class="dt">int</span> fd_count = <span class="dv">0</span>;</span>
<span id="cb54-120"><a href="#cb54-120"></a>    <span class="dt">int</span> fd_size = <span class="dv">5</span>;</span>
<span id="cb54-121"><a href="#cb54-121"></a>    <span class="kw">struct</span> pollfd *pfds = malloc(<span class="kw">sizeof</span> *pfds * fd_size);</span>
<span id="cb54-122"><a href="#cb54-122"></a></span>
<span id="cb54-123"><a href="#cb54-123"></a>    <span class="co">// Set up and get a listening socket</span></span>
<span id="cb54-124"><a href="#cb54-124"></a>    listener = get_listener_socket();</span>
<span id="cb54-125"><a href="#cb54-125"></a></span>
<span id="cb54-126"><a href="#cb54-126"></a>    <span class="cf">if</span> (listener == -<span class="dv">1</span>) {</span>
<span id="cb54-127"><a href="#cb54-127"></a>        fprintf(stderr, <span class="st">"error getting listening socket</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb54-128"><a href="#cb54-128"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb54-129"><a href="#cb54-129"></a>    }</span>
<span id="cb54-130"><a href="#cb54-130"></a></span>
<span id="cb54-131"><a href="#cb54-131"></a>    <span class="co">// Add the listener to set</span></span>
<span id="cb54-132"><a href="#cb54-132"></a>    pfds[<span class="dv">0</span>].fd = listener;</span>
<span id="cb54-133"><a href="#cb54-133"></a>    pfds[<span class="dv">0</span>].events = POLLIN; <span class="co">// Report ready to read on incoming connection</span></span>
<span id="cb54-134"><a href="#cb54-134"></a></span>
<span id="cb54-135"><a href="#cb54-135"></a>    fd_count = <span class="dv">1</span>; <span class="co">// For the listener</span></span>
<span id="cb54-136"><a href="#cb54-136"></a></span>
<span id="cb54-137"><a href="#cb54-137"></a>    <span class="co">// Main loop</span></span>
<span id="cb54-138"><a href="#cb54-138"></a>    <span class="cf">for</span>(;;) {</span>
<span id="cb54-139"><a href="#cb54-139"></a>        <span class="dt">int</span> poll_count = poll(pfds, fd_count, -<span class="dv">1</span>);</span>
<span id="cb54-140"><a href="#cb54-140"></a></span>
<span id="cb54-141"><a href="#cb54-141"></a>        <span class="cf">if</span> (poll_count == -<span class="dv">1</span>) {</span>
<span id="cb54-142"><a href="#cb54-142"></a>            perror(<span class="st">"poll"</span>);</span>
<span id="cb54-143"><a href="#cb54-143"></a>            exit(<span class="dv">1</span>);</span>
<span id="cb54-144"><a href="#cb54-144"></a>        }</span>
<span id="cb54-145"><a href="#cb54-145"></a></span>
<span id="cb54-146"><a href="#cb54-146"></a>        <span class="co">// Run through the existing connections looking for data to read</span></span>
<span id="cb54-147"><a href="#cb54-147"></a>        <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; fd_count; i++) {</span>
<span id="cb54-148"><a href="#cb54-148"></a></span>
<span id="cb54-149"><a href="#cb54-149"></a>            <span class="co">// Check if someone's ready to read</span></span>
<span id="cb54-150"><a href="#cb54-150"></a>            <span class="cf">if</span> (pfds[i].revents &amp; POLLIN) { <span class="co">// We got one!!</span></span>
<span id="cb54-151"><a href="#cb54-151"></a></span>
<span id="cb54-152"><a href="#cb54-152"></a>                <span class="cf">if</span> (pfds[i].fd == listener) {</span>
<span id="cb54-153"><a href="#cb54-153"></a>                    <span class="co">// If listener is ready to read, handle new connection</span></span>
<span id="cb54-154"><a href="#cb54-154"></a></span>
<span id="cb54-155"><a href="#cb54-155"></a>                    addrlen = <span class="kw">sizeof</span> remoteaddr;</span>
<span id="cb54-156"><a href="#cb54-156"></a>                    newfd = accept(listener,</span>
<span id="cb54-157"><a href="#cb54-157"></a>                        (<span class="kw">struct</span> sockaddr *)&amp;remoteaddr,</span>
<span id="cb54-158"><a href="#cb54-158"></a>                        &amp;addrlen);</span>
<span id="cb54-159"><a href="#cb54-159"></a></span>
<span id="cb54-160"><a href="#cb54-160"></a>                    <span class="cf">if</span> (newfd == -<span class="dv">1</span>) {</span>
<span id="cb54-161"><a href="#cb54-161"></a>                        perror(<span class="st">"accept"</span>);</span>
<span id="cb54-162"><a href="#cb54-162"></a>                    } <span class="cf">else</span> {</span>
<span id="cb54-163"><a href="#cb54-163"></a>                        add_to_pfds(&amp;pfds, newfd, &amp;fd_count, &amp;fd_size);</span>
<span id="cb54-164"><a href="#cb54-164"></a></span>
<span id="cb54-165"><a href="#cb54-165"></a>                        printf(<span class="st">"pollserver: new connection from %s on "</span></span>
<span id="cb54-166"><a href="#cb54-166"></a>                            <span class="st">"socket %d</span><span class="sc">\n</span><span class="st">"</span>,</span>
<span id="cb54-167"><a href="#cb54-167"></a>                            inet_ntop(remoteaddr.ss_family,</span>
<span id="cb54-168"><a href="#cb54-168"></a>                                get_in_addr((<span class="kw">struct</span> sockaddr*)&amp;remoteaddr),</span>
<span id="cb54-169"><a href="#cb54-169"></a>                                remoteIP, INET6_ADDRSTRLEN),</span>
<span id="cb54-170"><a href="#cb54-170"></a>                            newfd);</span>
<span id="cb54-171"><a href="#cb54-171"></a>                    }</span>
<span id="cb54-172"><a href="#cb54-172"></a>                } <span class="cf">else</span> {</span>
<span id="cb54-173"><a href="#cb54-173"></a>                    <span class="co">// If not the listener, we're just a regular client</span></span>
<span id="cb54-174"><a href="#cb54-174"></a>                    <span class="dt">int</span> nbytes = recv(pfds[i].fd, buf, <span class="kw">sizeof</span> buf, <span class="dv">0</span>);</span>
<span id="cb54-175"><a href="#cb54-175"></a></span>
<span id="cb54-176"><a href="#cb54-176"></a>                    <span class="dt">int</span> sender_fd = pfds[i].fd;</span>
<span id="cb54-177"><a href="#cb54-177"></a></span>
<span id="cb54-178"><a href="#cb54-178"></a>                    <span class="cf">if</span> (nbytes &lt;= <span class="dv">0</span>) {</span>
<span id="cb54-179"><a href="#cb54-179"></a>                        <span class="co">// Got error or connection closed by client</span></span>
<span id="cb54-180"><a href="#cb54-180"></a>                        <span class="cf">if</span> (nbytes == <span class="dv">0</span>) {</span>
<span id="cb54-181"><a href="#cb54-181"></a>                            <span class="co">// Connection closed</span></span>
<span id="cb54-182"><a href="#cb54-182"></a>                            printf(<span class="st">"pollserver: socket %d hung up</span><span class="sc">\n</span><span class="st">"</span>, sender_fd);</span>
<span id="cb54-183"><a href="#cb54-183"></a>                        } <span class="cf">else</span> {</span>
<span id="cb54-184"><a href="#cb54-184"></a>                            perror(<span class="st">"recv"</span>);</span>
<span id="cb54-185"><a href="#cb54-185"></a>                        }</span>
<span id="cb54-186"><a href="#cb54-186"></a></span>
<span id="cb54-187"><a href="#cb54-187"></a>                        close(pfds[i].fd); <span class="co">// Bye!</span></span>
<span id="cb54-188"><a href="#cb54-188"></a></span>
<span id="cb54-189"><a href="#cb54-189"></a>                        del_from_pfds(pfds, i, &amp;fd_count);</span>
<span id="cb54-190"><a href="#cb54-190"></a></span>
<span id="cb54-191"><a href="#cb54-191"></a>                    } <span class="cf">else</span> {</span>
<span id="cb54-192"><a href="#cb54-192"></a>                        <span class="co">// We got some good data from a client</span></span>
<span id="cb54-193"><a href="#cb54-193"></a></span>
<span id="cb54-194"><a href="#cb54-194"></a>                        <span class="cf">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; fd_count; j++) {</span>
<span id="cb54-195"><a href="#cb54-195"></a>                            <span class="co">// Send to everyone!</span></span>
<span id="cb54-196"><a href="#cb54-196"></a>                            <span class="dt">int</span> dest_fd = pfds[j].fd;</span>
<span id="cb54-197"><a href="#cb54-197"></a></span>
<span id="cb54-198"><a href="#cb54-198"></a>                            <span class="co">// Except the listener and ourselves</span></span>
<span id="cb54-199"><a href="#cb54-199"></a>                            <span class="cf">if</span> (dest_fd != listener &amp;&amp; dest_fd != sender_fd) {</span>
<span id="cb54-200"><a href="#cb54-200"></a>                                <span class="cf">if</span> (send(dest_fd, buf, nbytes, <span class="dv">0</span>) == -<span class="dv">1</span>) {</span>
<span id="cb54-201"><a href="#cb54-201"></a>                                    perror(<span class="st">"send"</span>);</span>
<span id="cb54-202"><a href="#cb54-202"></a>                                }</span>
<span id="cb54-203"><a href="#cb54-203"></a>                            }</span>
<span id="cb54-204"><a href="#cb54-204"></a>                        }</span>
<span id="cb54-205"><a href="#cb54-205"></a>                    }</span>
<span id="cb54-206"><a href="#cb54-206"></a>                } <span class="co">// </span><span class="re">END</span><span class="co"> handle data from client</span></span>
<span id="cb54-207"><a href="#cb54-207"></a>            } <span class="co">// </span><span class="re">END</span><span class="co"> got ready-to-read from poll()</span></span>
<span id="cb54-208"><a href="#cb54-208"></a>        } <span class="co">// </span><span class="re">END</span><span class="co"> looping through file descriptors</span></span>
<span id="cb54-209"><a href="#cb54-209"></a>    } <span class="co">// </span><span class="re">END</span><span class="co"> for(;;)--and you thought it would never end!</span></span>
<span id="cb54-210"><a href="#cb54-210"></a>    </span>
<span id="cb54-211"><a href="#cb54-211"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb54-212"><a href="#cb54-212"></a>}</span></code></pre></div>
<p>In the next section, we’ll look at a similar, older function called <code>select()</code>. Both <code>select()</code> and <code>poll()</code> offer similar functionality and performance, and only really differ in how they’re used. <code>select()</code>
 might be slightly more portable, but is perhaps a little clunkier in 
use. Choose the one you like the best, as long as it’s supported on your
 system.</p>
<h2 data-number="7.3" id="select"><span class="header-section-number">7.3</span> <code>select()</code>—Synchronous I/O Multiplexing, Old School</h2>
<p> This function is somewhat strange, but it’s very useful. Take the 
following situation: you are a server and you want to listen for 
incoming connections as well as keep reading from the connections you 
already have.</p>
<p>No problem, you say, just an <code>accept()</code> and a couple of <code>recv()</code>s. Not so fast, buster! What if you’re blocking on an <code>accept()</code> call? How are you going to <code>recv()</code> data at the same time? “Use non-blocking sockets!” No way! You don’t want to be a CPU hog. What, then?</p>
<p><code>select()</code> gives you the power to monitor several sockets 
at the same time. It’ll tell you which ones are ready for reading, which
 are ready for writing, and which sockets have raised exceptions, if you
 really want to know that.</p>
<blockquote>
<p><em>A word of warning: <code>select()</code>, though very portable, 
is terribly slow when it comes to giant numbers of connections. In those
 circumstances, you’ll get better performance out of an event library 
such as <a href="https://libevent.org/">libevent</a><a href="#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a> that attempts to use the fastest possible method availabile on your system.</em></p>
</blockquote>
<p>Without any further ado, I’ll offer the synopsis of <code>select()</code>:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/time.h&gt;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> select(<span class="dt">int</span> numfds, fd_set *readfds, fd_set *writefds,</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>               fd_set *exceptfds, <span class="kw">struct</span> timeval *timeout); </span></code></pre></div>
<p>The function monitors “sets” of file descriptors; in particular <code>readfds</code>, <code>writefds</code>, and <code>exceptfds</code>. If you want to see if you can read from standard input and some socket descriptor, <code>sockfd</code>, just add the file descriptors <code>0</code> and <code>sockfd</code> to the set <code>readfds</code>. The parameter <code>numfds</code> should be set to the values of the highest file descriptor plus one. In this example, it should be set to <code>sockfd+1</code>, since it is assuredly higher than standard input (<code>0</code>).</p>
<p>When <code>select()</code> returns, <code>readfds</code> will be 
modified to reflect which of the file descriptors you selected which is 
ready for reading. You can test them with the macro <code>FD_ISSET()</code>, below.</p>
<p>Before progressing much further, I’ll talk about how to manipulate these sets. Each set is of the type <code>fd_set</code>. The following macros operate on this type:</p>
<p>   </p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>FD_SET(int fd, fd_set *set);</code></td>
<td>Add <code>fd</code> to the <code>set</code>.</td>
</tr>
<tr class="even">
<td><code>FD_CLR(int fd, fd_set *set);</code></td>
<td>Remove <code>fd</code> from the <code>set</code>.</td>
</tr>
<tr class="odd">
<td><code>FD_ISSET(int fd, fd_set *set);</code></td>
<td>Return true if <code>fd</code> is in the <code>set</code>.</td>
</tr>
<tr class="even">
<td><code>FD_ZERO(fd_set *set);</code></td>
<td>Clear all entries from the <code>set</code>.</td>
</tr>
</tbody>
</table>
<p>Finally, what is this weirded out  <code>struct timeval</code>? Well,
 sometimes you don’t want to wait forever for someone to send you some 
data. Maybe every 96 seconds you want to print “Still Going…” to the 
terminal even though nothing has happened. This time structure allows 
you to specify a timeout period. If the time is exceeded and <code>select()</code> still hasn’t found any ready file descriptors, it’ll return so you can continue processing.</p>
<p>The <code>struct timeval</code> has the follow fields:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> timeval {</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> tv_sec;     <span class="co">// seconds</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> tv_usec;    <span class="co">// microseconds</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    }; </span></code></pre></div>
<p>Just set <code>tv_sec</code> to the number of seconds to wait, and set <code>tv_usec</code>
 to the number of microseconds to wait. Yes, that’s _micro_seconds, not 
milliseconds. There are 1,000 microseconds in a millisecond, and 1,000 
milliseconds in a second. Thus, there are 1,000,000 microseconds in a 
second. Why is it “usec”? The “u” is supposed to look like the Greek 
letter μ (Mu) that we use for “micro”. Also, when the function returns, <code>timeout</code> <em>might</em> be updated to show the time still remaining. This depends on what flavor of Unix you’re running.</p>
<p>Yay! We have a microsecond resolution timer! Well, don’t count on it.
 You’ll probably have to wait some part of your standard Unix timeslice 
no matter how small you set your <code>struct timeval</code>.</p>
<p>Other things of interest: If you set the fields in your <code>struct timeval</code> to <code>0</code>, <code>select()</code> will timeout immediately, effectively polling all the file descriptors in your sets. If you set the parameter <code>timeout</code>
 to NULL, it will never timeout, and will wait until the first file 
descriptor is ready. Finally, if you don’t care about waiting for a 
certain set, you can just set it to NULL in the call to <code>select()</code>.</p>
<p><a href="https://beej.us/guide/bgnet/examples/select.c">The following code snippet</a><a href="#fn31" class="footnote-ref" id="fnref31" role="doc-noteref"><sup>31</sup></a> waits 2.5 seconds for something to appear on standard input:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb57-1"><a href="#cb57-1"></a><span class="co">/*</span></span>
<span id="cb57-2"><a href="#cb57-2"></a><span class="co">** select.c -- a select() demo</span></span>
<span id="cb57-3"><a href="#cb57-3"></a><span class="co">*/</span></span>
<span id="cb57-4"><a href="#cb57-4"></a></span>
<span id="cb57-5"><a href="#cb57-5"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb57-6"><a href="#cb57-6"></a><span class="pp">#include </span><span class="im">&lt;sys/time.h&gt;</span></span>
<span id="cb57-7"><a href="#cb57-7"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb57-8"><a href="#cb57-8"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb57-9"><a href="#cb57-9"></a></span>
<span id="cb57-10"><a href="#cb57-10"></a><span class="pp">#define STDIN 0  </span><span class="co">// file descriptor for standard input</span></span>
<span id="cb57-11"><a href="#cb57-11"></a></span>
<span id="cb57-12"><a href="#cb57-12"></a><span class="dt">int</span> main(<span class="dt">void</span>)</span>
<span id="cb57-13"><a href="#cb57-13"></a>{</span>
<span id="cb57-14"><a href="#cb57-14"></a>    <span class="kw">struct</span> timeval tv;</span>
<span id="cb57-15"><a href="#cb57-15"></a>    fd_set readfds;</span>
<span id="cb57-16"><a href="#cb57-16"></a></span>
<span id="cb57-17"><a href="#cb57-17"></a>    tv.tv_sec = <span class="dv">2</span>;</span>
<span id="cb57-18"><a href="#cb57-18"></a>    tv.tv_usec = <span class="dv">500000</span>;</span>
<span id="cb57-19"><a href="#cb57-19"></a></span>
<span id="cb57-20"><a href="#cb57-20"></a>    FD_ZERO(&amp;readfds);</span>
<span id="cb57-21"><a href="#cb57-21"></a>    FD_SET(STDIN, &amp;readfds);</span>
<span id="cb57-22"><a href="#cb57-22"></a></span>
<span id="cb57-23"><a href="#cb57-23"></a>    <span class="co">// don't care about writefds and exceptfds:</span></span>
<span id="cb57-24"><a href="#cb57-24"></a>    select(STDIN+<span class="dv">1</span>, &amp;readfds, NULL, NULL, &amp;tv);</span>
<span id="cb57-25"><a href="#cb57-25"></a></span>
<span id="cb57-26"><a href="#cb57-26"></a>    <span class="cf">if</span> (FD_ISSET(STDIN, &amp;readfds))</span>
<span id="cb57-27"><a href="#cb57-27"></a>        printf(<span class="st">"A key was pressed!</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb57-28"><a href="#cb57-28"></a>    <span class="cf">else</span></span>
<span id="cb57-29"><a href="#cb57-29"></a>        printf(<span class="st">"Timed out.</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb57-30"><a href="#cb57-30"></a></span>
<span id="cb57-31"><a href="#cb57-31"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb57-32"><a href="#cb57-32"></a>} </span></code></pre></div>
<p>If you’re on a line buffered terminal, the key you hit should be RETURN or it will time out anyway.</p>
<p>Now, some of you might think this is a great way to wait for data on a datagram socket—and you are right: it <em>might</em>
 be. Some Unices can use select in this manner, and some can’t. You 
should see what your local man page says on the matter if you want to 
attempt it.</p>
<p>Some Unices update the time in your <code>struct timeval</code> to 
reflect the amount of time still remaining before a timeout. But others 
do not. Don’t rely on that occurring if you want to be portable. (Use  <code>gettimeofday()</code> if you need to track time elapsed. It’s a bummer, I know, but that’s the way it is.)</p>
<p>What happens if a socket in the read set closes the connection? Well, in that case, <code>select()</code> returns with that socket descriptor set as “ready to read”. When you actually do <code>recv()</code> from it, <code>recv()</code> will return <code>0</code>. That’s how you know the client has closed the connection.</p>
<p>One more note of interest about <code>select()</code>: if you have a socket that is   <code>listen()</code>ing, you can check to see if there is a new connection by putting that socket’s file descriptor in the <code>readfds</code> set.</p>
<p>And that, my friends, is a quick overview of the almighty <code>select()</code> function.</p>
<p>But, by popular demand, here is an in-depth example. Unfortunately, 
the difference between the dirt-simple example, above, and this one here
 is significant. But have a look, then read the description that follows
 it.</p>
<p><a href="https://beej.us/guide/bgnet/examples/selectserver.c">This program</a><a href="#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a> acts like a simple multi-user chat server. Start it running in one window, then <code>telnet</code> to it (“<code>telnet hostname 9034</code>”) from multiple other windows. When you type something in one <code>telnet</code> session, it should appear in all the others.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1"></a><span class="co">/*</span></span>
<span id="cb58-2"><a href="#cb58-2"></a><span class="co">** selectserver.c -- a cheezy multiperson chat server</span></span>
<span id="cb58-3"><a href="#cb58-3"></a><span class="co">*/</span></span>
<span id="cb58-4"><a href="#cb58-4"></a></span>
<span id="cb58-5"><a href="#cb58-5"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb58-6"><a href="#cb58-6"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb58-7"><a href="#cb58-7"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb58-8"><a href="#cb58-8"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb58-9"><a href="#cb58-9"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb58-10"><a href="#cb58-10"></a><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb58-11"><a href="#cb58-11"></a><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></span>
<span id="cb58-12"><a href="#cb58-12"></a><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></span>
<span id="cb58-13"><a href="#cb58-13"></a><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></span>
<span id="cb58-14"><a href="#cb58-14"></a></span>
<span id="cb58-15"><a href="#cb58-15"></a><span class="pp">#define PORT "9034"   </span><span class="co">// port we're listening on</span></span>
<span id="cb58-16"><a href="#cb58-16"></a></span>
<span id="cb58-17"><a href="#cb58-17"></a><span class="co">// get sockaddr, IPv4 or IPv6:</span></span>
<span id="cb58-18"><a href="#cb58-18"></a><span class="dt">void</span> *get_in_addr(<span class="kw">struct</span> sockaddr *sa)</span>
<span id="cb58-19"><a href="#cb58-19"></a>{</span>
<span id="cb58-20"><a href="#cb58-20"></a>    <span class="cf">if</span> (sa-&gt;sa_family == AF_INET) {</span>
<span id="cb58-21"><a href="#cb58-21"></a>        <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in*)sa)-&gt;sin_addr);</span>
<span id="cb58-22"><a href="#cb58-22"></a>    }</span>
<span id="cb58-23"><a href="#cb58-23"></a></span>
<span id="cb58-24"><a href="#cb58-24"></a>    <span class="cf">return</span> &amp;(((<span class="kw">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr);</span>
<span id="cb58-25"><a href="#cb58-25"></a>}</span>
<span id="cb58-26"><a href="#cb58-26"></a></span>
<span id="cb58-27"><a href="#cb58-27"></a><span class="dt">int</span> main(<span class="dt">void</span>)</span>
<span id="cb58-28"><a href="#cb58-28"></a>{</span>
<span id="cb58-29"><a href="#cb58-29"></a>    fd_set master;    <span class="co">// master file descriptor list</span></span>
<span id="cb58-30"><a href="#cb58-30"></a>    fd_set read_fds;  <span class="co">// temp file descriptor list for select()</span></span>
<span id="cb58-31"><a href="#cb58-31"></a>    <span class="dt">int</span> fdmax;        <span class="co">// maximum file descriptor number</span></span>
<span id="cb58-32"><a href="#cb58-32"></a></span>
<span id="cb58-33"><a href="#cb58-33"></a>    <span class="dt">int</span> listener;     <span class="co">// listening socket descriptor</span></span>
<span id="cb58-34"><a href="#cb58-34"></a>    <span class="dt">int</span> newfd;        <span class="co">// newly accept()ed socket descriptor</span></span>
<span id="cb58-35"><a href="#cb58-35"></a>    <span class="kw">struct</span> sockaddr_storage remoteaddr; <span class="co">// client address</span></span>
<span id="cb58-36"><a href="#cb58-36"></a>    socklen_t addrlen;</span>
<span id="cb58-37"><a href="#cb58-37"></a></span>
<span id="cb58-38"><a href="#cb58-38"></a>    <span class="dt">char</span> buf[<span class="dv">256</span>];    <span class="co">// buffer for client data</span></span>
<span id="cb58-39"><a href="#cb58-39"></a>    <span class="dt">int</span> nbytes;</span>
<span id="cb58-40"><a href="#cb58-40"></a></span>
<span id="cb58-41"><a href="#cb58-41"></a>    <span class="dt">char</span> remoteIP[INET6_ADDRSTRLEN];</span>
<span id="cb58-42"><a href="#cb58-42"></a></span>
<span id="cb58-43"><a href="#cb58-43"></a>    <span class="dt">int</span> yes=<span class="dv">1</span>;        <span class="co">// for setsockopt() SO_REUSEADDR, below</span></span>
<span id="cb58-44"><a href="#cb58-44"></a>    <span class="dt">int</span> i, j, rv;</span>
<span id="cb58-45"><a href="#cb58-45"></a></span>
<span id="cb58-46"><a href="#cb58-46"></a>    <span class="kw">struct</span> addrinfo hints, *ai, *p;</span>
<span id="cb58-47"><a href="#cb58-47"></a></span>
<span id="cb58-48"><a href="#cb58-48"></a>    FD_ZERO(&amp;master);    <span class="co">// clear the master and temp sets</span></span>
<span id="cb58-49"><a href="#cb58-49"></a>    FD_ZERO(&amp;read_fds);</span>
<span id="cb58-50"><a href="#cb58-50"></a></span>
<span id="cb58-51"><a href="#cb58-51"></a>    <span class="co">// get us a socket and bind it</span></span>
<span id="cb58-52"><a href="#cb58-52"></a>    memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb58-53"><a href="#cb58-53"></a>    hints.ai_family = AF_UNSPEC;</span>
<span id="cb58-54"><a href="#cb58-54"></a>    hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb58-55"><a href="#cb58-55"></a>    hints.ai_flags = AI_PASSIVE;</span>
<span id="cb58-56"><a href="#cb58-56"></a>    <span class="cf">if</span> ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;ai)) != <span class="dv">0</span>) {</span>
<span id="cb58-57"><a href="#cb58-57"></a>        fprintf(stderr, <span class="st">"selectserver: %s</span><span class="sc">\n</span><span class="st">"</span>, gai_strerror(rv));</span>
<span id="cb58-58"><a href="#cb58-58"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb58-59"><a href="#cb58-59"></a>    }</span>
<span id="cb58-60"><a href="#cb58-60"></a>    </span>
<span id="cb58-61"><a href="#cb58-61"></a>    <span class="cf">for</span>(p = ai; p != NULL; p = p-&gt;ai_next) {</span>
<span id="cb58-62"><a href="#cb58-62"></a>        listener = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);</span>
<span id="cb58-63"><a href="#cb58-63"></a>        <span class="cf">if</span> (listener &lt; <span class="dv">0</span>) { </span>
<span id="cb58-64"><a href="#cb58-64"></a>            <span class="cf">continue</span>;</span>
<span id="cb58-65"><a href="#cb58-65"></a>        }</span>
<span id="cb58-66"><a href="#cb58-66"></a>        </span>
<span id="cb58-67"><a href="#cb58-67"></a>        <span class="co">// lose the pesky "address already in use" error message</span></span>
<span id="cb58-68"><a href="#cb58-68"></a>        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, <span class="kw">sizeof</span>(<span class="dt">int</span>));</span>
<span id="cb58-69"><a href="#cb58-69"></a></span>
<span id="cb58-70"><a href="#cb58-70"></a>        <span class="cf">if</span> (bind(listener, p-&gt;ai_addr, p-&gt;ai_addrlen) &lt; <span class="dv">0</span>) {</span>
<span id="cb58-71"><a href="#cb58-71"></a>            close(listener);</span>
<span id="cb58-72"><a href="#cb58-72"></a>            <span class="cf">continue</span>;</span>
<span id="cb58-73"><a href="#cb58-73"></a>        }</span>
<span id="cb58-74"><a href="#cb58-74"></a></span>
<span id="cb58-75"><a href="#cb58-75"></a>        <span class="cf">break</span>;</span>
<span id="cb58-76"><a href="#cb58-76"></a>    }</span>
<span id="cb58-77"><a href="#cb58-77"></a></span>
<span id="cb58-78"><a href="#cb58-78"></a>    <span class="co">// if we got here, it means we didn't get bound</span></span>
<span id="cb58-79"><a href="#cb58-79"></a>    <span class="cf">if</span> (p == NULL) {</span>
<span id="cb58-80"><a href="#cb58-80"></a>        fprintf(stderr, <span class="st">"selectserver: failed to bind</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb58-81"><a href="#cb58-81"></a>        exit(<span class="dv">2</span>);</span>
<span id="cb58-82"><a href="#cb58-82"></a>    }</span>
<span id="cb58-83"><a href="#cb58-83"></a></span>
<span id="cb58-84"><a href="#cb58-84"></a>    freeaddrinfo(ai); <span class="co">// all done with this</span></span>
<span id="cb58-85"><a href="#cb58-85"></a></span>
<span id="cb58-86"><a href="#cb58-86"></a>    <span class="co">// listen</span></span>
<span id="cb58-87"><a href="#cb58-87"></a>    <span class="cf">if</span> (listen(listener, <span class="dv">10</span>) == -<span class="dv">1</span>) {</span>
<span id="cb58-88"><a href="#cb58-88"></a>        perror(<span class="st">"listen"</span>);</span>
<span id="cb58-89"><a href="#cb58-89"></a>        exit(<span class="dv">3</span>);</span>
<span id="cb58-90"><a href="#cb58-90"></a>    }</span>
<span id="cb58-91"><a href="#cb58-91"></a></span>
<span id="cb58-92"><a href="#cb58-92"></a>    <span class="co">// add the listener to the master set</span></span>
<span id="cb58-93"><a href="#cb58-93"></a>    FD_SET(listener, &amp;master);</span>
<span id="cb58-94"><a href="#cb58-94"></a></span>
<span id="cb58-95"><a href="#cb58-95"></a>    <span class="co">// keep track of the biggest file descriptor</span></span>
<span id="cb58-96"><a href="#cb58-96"></a>    fdmax = listener; <span class="co">// so far, it's this one</span></span>
<span id="cb58-97"><a href="#cb58-97"></a></span>
<span id="cb58-98"><a href="#cb58-98"></a>    <span class="co">// main loop</span></span>
<span id="cb58-99"><a href="#cb58-99"></a>    <span class="cf">for</span>(;;) {</span>
<span id="cb58-100"><a href="#cb58-100"></a>        read_fds = master; <span class="co">// copy it</span></span>
<span id="cb58-101"><a href="#cb58-101"></a>        <span class="cf">if</span> (select(fdmax+<span class="dv">1</span>, &amp;read_fds, NULL, NULL, NULL) == -<span class="dv">1</span>) {</span>
<span id="cb58-102"><a href="#cb58-102"></a>            perror(<span class="st">"select"</span>);</span>
<span id="cb58-103"><a href="#cb58-103"></a>            exit(<span class="dv">4</span>);</span>
<span id="cb58-104"><a href="#cb58-104"></a>        }</span>
<span id="cb58-105"><a href="#cb58-105"></a></span>
<span id="cb58-106"><a href="#cb58-106"></a>        <span class="co">// run through the existing connections looking for data to read</span></span>
<span id="cb58-107"><a href="#cb58-107"></a>        <span class="cf">for</span>(i = <span class="dv">0</span>; i &lt;= fdmax; i++) {</span>
<span id="cb58-108"><a href="#cb58-108"></a>            <span class="cf">if</span> (FD_ISSET(i, &amp;read_fds)) { <span class="co">// we got one!!</span></span>
<span id="cb58-109"><a href="#cb58-109"></a>                <span class="cf">if</span> (i == listener) {</span>
<span id="cb58-110"><a href="#cb58-110"></a>                    <span class="co">// handle new connections</span></span>
<span id="cb58-111"><a href="#cb58-111"></a>                    addrlen = <span class="kw">sizeof</span> remoteaddr;</span>
<span id="cb58-112"><a href="#cb58-112"></a>                    newfd = accept(listener,</span>
<span id="cb58-113"><a href="#cb58-113"></a>                        (<span class="kw">struct</span> sockaddr *)&amp;remoteaddr,</span>
<span id="cb58-114"><a href="#cb58-114"></a>                        &amp;addrlen);</span>
<span id="cb58-115"><a href="#cb58-115"></a></span>
<span id="cb58-116"><a href="#cb58-116"></a>                    <span class="cf">if</span> (newfd == -<span class="dv">1</span>) {</span>
<span id="cb58-117"><a href="#cb58-117"></a>                        perror(<span class="st">"accept"</span>);</span>
<span id="cb58-118"><a href="#cb58-118"></a>                    } <span class="cf">else</span> {</span>
<span id="cb58-119"><a href="#cb58-119"></a>                        FD_SET(newfd, &amp;master); <span class="co">// add to master set</span></span>
<span id="cb58-120"><a href="#cb58-120"></a>                        <span class="cf">if</span> (newfd &gt; fdmax) {    <span class="co">// keep track of the max</span></span>
<span id="cb58-121"><a href="#cb58-121"></a>                            fdmax = newfd;</span>
<span id="cb58-122"><a href="#cb58-122"></a>                        }</span>
<span id="cb58-123"><a href="#cb58-123"></a>                        printf(<span class="st">"selectserver: new connection from %s on "</span></span>
<span id="cb58-124"><a href="#cb58-124"></a>                            <span class="st">"socket %d</span><span class="sc">\n</span><span class="st">"</span>,</span>
<span id="cb58-125"><a href="#cb58-125"></a>                            inet_ntop(remoteaddr.ss_family,</span>
<span id="cb58-126"><a href="#cb58-126"></a>                                get_in_addr((<span class="kw">struct</span> sockaddr*)&amp;remoteaddr),</span>
<span id="cb58-127"><a href="#cb58-127"></a>                                remoteIP, INET6_ADDRSTRLEN),</span>
<span id="cb58-128"><a href="#cb58-128"></a>                            newfd);</span>
<span id="cb58-129"><a href="#cb58-129"></a>                    }</span>
<span id="cb58-130"><a href="#cb58-130"></a>                } <span class="cf">else</span> {</span>
<span id="cb58-131"><a href="#cb58-131"></a>                    <span class="co">// handle data from a client</span></span>
<span id="cb58-132"><a href="#cb58-132"></a>                    <span class="cf">if</span> ((nbytes = recv(i, buf, <span class="kw">sizeof</span> buf, <span class="dv">0</span>)) &lt;= <span class="dv">0</span>) {</span>
<span id="cb58-133"><a href="#cb58-133"></a>                        <span class="co">// got error or connection closed by client</span></span>
<span id="cb58-134"><a href="#cb58-134"></a>                        <span class="cf">if</span> (nbytes == <span class="dv">0</span>) {</span>
<span id="cb58-135"><a href="#cb58-135"></a>                            <span class="co">// connection closed</span></span>
<span id="cb58-136"><a href="#cb58-136"></a>                            printf(<span class="st">"selectserver: socket %d hung up</span><span class="sc">\n</span><span class="st">"</span>, i);</span>
<span id="cb58-137"><a href="#cb58-137"></a>                        } <span class="cf">else</span> {</span>
<span id="cb58-138"><a href="#cb58-138"></a>                            perror(<span class="st">"recv"</span>);</span>
<span id="cb58-139"><a href="#cb58-139"></a>                        }</span>
<span id="cb58-140"><a href="#cb58-140"></a>                        close(i); <span class="co">// bye!</span></span>
<span id="cb58-141"><a href="#cb58-141"></a>                        FD_CLR(i, &amp;master); <span class="co">// remove from master set</span></span>
<span id="cb58-142"><a href="#cb58-142"></a>                    } <span class="cf">else</span> {</span>
<span id="cb58-143"><a href="#cb58-143"></a>                        <span class="co">// we got some data from a client</span></span>
<span id="cb58-144"><a href="#cb58-144"></a>                        <span class="cf">for</span>(j = <span class="dv">0</span>; j &lt;= fdmax; j++) {</span>
<span id="cb58-145"><a href="#cb58-145"></a>                            <span class="co">// send to everyone!</span></span>
<span id="cb58-146"><a href="#cb58-146"></a>                            <span class="cf">if</span> (FD_ISSET(j, &amp;master)) {</span>
<span id="cb58-147"><a href="#cb58-147"></a>                                <span class="co">// except the listener and ourselves</span></span>
<span id="cb58-148"><a href="#cb58-148"></a>                                <span class="cf">if</span> (j != listener &amp;&amp; j != i) {</span>
<span id="cb58-149"><a href="#cb58-149"></a>                                    <span class="cf">if</span> (send(j, buf, nbytes, <span class="dv">0</span>) == -<span class="dv">1</span>) {</span>
<span id="cb58-150"><a href="#cb58-150"></a>                                        perror(<span class="st">"send"</span>);</span>
<span id="cb58-151"><a href="#cb58-151"></a>                                    }</span>
<span id="cb58-152"><a href="#cb58-152"></a>                                }</span>
<span id="cb58-153"><a href="#cb58-153"></a>                            }</span>
<span id="cb58-154"><a href="#cb58-154"></a>                        }</span>
<span id="cb58-155"><a href="#cb58-155"></a>                    }</span>
<span id="cb58-156"><a href="#cb58-156"></a>                } <span class="co">// </span><span class="re">END</span><span class="co"> handle data from client</span></span>
<span id="cb58-157"><a href="#cb58-157"></a>            } <span class="co">// </span><span class="re">END</span><span class="co"> got new incoming connection</span></span>
<span id="cb58-158"><a href="#cb58-158"></a>        } <span class="co">// </span><span class="re">END</span><span class="co"> looping through file descriptors</span></span>
<span id="cb58-159"><a href="#cb58-159"></a>    } <span class="co">// </span><span class="re">END</span><span class="co"> for(;;)--and you thought it would never end!</span></span>
<span id="cb58-160"><a href="#cb58-160"></a>    </span>
<span id="cb58-161"><a href="#cb58-161"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb58-162"><a href="#cb58-162"></a>}</span></code></pre></div>
<p>Notice I have two file descriptor sets in the code: <code>master</code> and <code>read_fds</code>. The first, <code>master</code>,
 holds all the socket descriptors that are currently connected, as well 
as the socket descriptor that is listening for new connections.</p>
<p>The reason I have the <code>master</code> set is that <code>select()</code> actually <em>changes</em>
 the set you pass into it to reflect which sockets are ready to read. 
Since I have to keep track of the connections from one call of <code>select()</code> to the next, I must store these safely away somewhere. At the last minute, I copy the <code>master</code> into the <code>read_fds</code>, and then call <code>select()</code>.</p>
<p>But doesn’t this mean that every time I get a new connection, I have to add it to the <code>master</code> set? Yup! And every time a connection closes, I have to remove it from the <code>master</code> set? Yes, it does.</p>
<p>Notice I check to see when the <code>listener</code> socket is ready to read. When it is, it means I have a new connection pending, and I <code>accept()</code> it and add it to the <code>master</code> set. Similarly, when a client connection is ready to read, and <code>recv()</code> returns <code>0</code>, I know the client has closed the connection, and I must remove it from the <code>master</code> set.</p>
<p>If the client <code>recv()</code> returns non-zero, though, I know some data has been received. So I get it, and then go through the <code>master</code> list and send that data to all the rest of the connected clients.</p>
<p>And that, my friends, is a less-than-simple overview of the almighty <code>select()</code> function.</p>
<p>Quick note to all you Linux fans out there: sometimes, in rare circumstances, Linux’s <code>select()</code> can return “ready-to-read” and then not actually be ready to read! This means it will block on the <code>read()</code> after the <code>select()</code> says it won’t! Why you little—! Anyway, the workaround solution is to set the  <code>O_NONBLOCK</code> flag on the receiving socket so it errors with <code>EWOULDBLOCK</code> (which you can just safely ignore if it occurs). See the <a href="#fcntlman"><code>fcntl()</code> reference page</a> for more info on setting a socket to non-blocking.</p>
<p>In addition, here is a bonus afterthought: there is another function called  <code>poll()</code> which behaves much the same way <code>select()</code> does, but with a different system for managing the file descriptor sets. <a href="#pollman">Check it out!</a></p>
<h2 data-number="7.4" id="sendall"><span class="header-section-number">7.4</span> Handling Partial <code>send()</code>s</h2>
<p>Remember back in the <a href="#sendrecv">section about <code>send()</code></a>, above, when I said that <code>send()</code>
 might not send all the bytes you asked it to? That is, you want it to 
send 512 bytes, but it returns 412. What happened to the remaining 100 
bytes?</p>
<p>Well, they’re still in your little buffer waiting to be sent out. Due
 to circumstances beyond your control, the kernel decided not to send 
all the data out in one chunk, and now, my friend, it’s up to you to get
 the data out there.</p>
<p> You could write a function like this to do it, too:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb59-1"><a href="#cb59-1"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb59-2"><a href="#cb59-2"></a><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb59-3"><a href="#cb59-3"></a></span>
<span id="cb59-4"><a href="#cb59-4"></a><span class="dt">int</span> sendall(<span class="dt">int</span> s, <span class="dt">char</span> *buf, <span class="dt">int</span> *len)</span>
<span id="cb59-5"><a href="#cb59-5"></a>{</span>
<span id="cb59-6"><a href="#cb59-6"></a>    <span class="dt">int</span> total = <span class="dv">0</span>;        <span class="co">// how many bytes we've sent</span></span>
<span id="cb59-7"><a href="#cb59-7"></a>    <span class="dt">int</span> bytesleft = *len; <span class="co">// how many we have left to send</span></span>
<span id="cb59-8"><a href="#cb59-8"></a>    <span class="dt">int</span> n;</span>
<span id="cb59-9"><a href="#cb59-9"></a></span>
<span id="cb59-10"><a href="#cb59-10"></a>    <span class="cf">while</span>(total &lt; *len) {</span>
<span id="cb59-11"><a href="#cb59-11"></a>        n = send(s, buf+total, bytesleft, <span class="dv">0</span>);</span>
<span id="cb59-12"><a href="#cb59-12"></a>        <span class="cf">if</span> (n == -<span class="dv">1</span>) { <span class="cf">break</span>; }</span>
<span id="cb59-13"><a href="#cb59-13"></a>        total += n;</span>
<span id="cb59-14"><a href="#cb59-14"></a>        bytesleft -= n;</span>
<span id="cb59-15"><a href="#cb59-15"></a>    }</span>
<span id="cb59-16"><a href="#cb59-16"></a></span>
<span id="cb59-17"><a href="#cb59-17"></a>    *len = total; <span class="co">// return number actually sent here</span></span>
<span id="cb59-18"><a href="#cb59-18"></a></span>
<span id="cb59-19"><a href="#cb59-19"></a>    <span class="cf">return</span> n==-<span class="dv">1</span>?-<span class="dv">1</span>:<span class="dv">0</span>; <span class="co">// return -1 on failure, 0 on success</span></span>
<span id="cb59-20"><a href="#cb59-20"></a>} </span></code></pre></div>
<p>In this example, <code>s</code> is the socket you want to send the data to, <code>buf</code> is the buffer containing the data, and <code>len</code> is a pointer to an <code>int</code> containing the number of bytes in the buffer.</p>
<p>The function returns <code>-1</code> on error (and <code>errno</code> is still set from the call to <code>send()</code>). Also, the number of bytes actually sent is returned in <code>len</code>. This will be the same number of bytes you asked it to send, unless there was an error. <code>sendall()</code> will do it’s best, huffing and puffing, to send the data out, but if there’s an error, it gets back to you right away.</p>
<p>For completeness, here’s a sample call to the function:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb60-1"><a href="#cb60-1"></a><span class="dt">char</span> buf[<span class="dv">10</span>] = <span class="st">"Beej!"</span>;</span>
<span id="cb60-2"><a href="#cb60-2"></a><span class="dt">int</span> len;</span>
<span id="cb60-3"><a href="#cb60-3"></a></span>
<span id="cb60-4"><a href="#cb60-4"></a>len = strlen(buf);</span>
<span id="cb60-5"><a href="#cb60-5"></a><span class="cf">if</span> (sendall(s, buf, &amp;len) == -<span class="dv">1</span>) {</span>
<span id="cb60-6"><a href="#cb60-6"></a>    perror(<span class="st">"sendall"</span>);</span>
<span id="cb60-7"><a href="#cb60-7"></a>    printf(<span class="st">"We only sent %d bytes because of the error!</span><span class="sc">\n</span><span class="st">"</span>, len);</span>
<span id="cb60-8"><a href="#cb60-8"></a>} </span></code></pre></div>
<p>What happens on the receiver’s end when part of a packet arrives? If 
the packets are variable length, how does the receiver know when one 
packet ends and another begins? Yes, real-world scenarios are a royal 
pain in the  donkeys. You probably have to  <em>encapsulate</em> (remember that from the <a href="#lowlevel">data encapsulation section</a> way back there at the beginning?) Read on for details!</p>
<h2 data-number="7.5" id="serialization"><span class="header-section-number">7.5</span> Serialization—How to Pack Data</h2>
<p> It’s easy enough to send text data across the network, you’re 
finding, but what happens if you want to send some “binary” data like <code>int</code>s or <code>float</code>s? It turns out you have a few options.</p>
<ol type="1">
<li><p>Convert the number into text with a function like <code>sprintf()</code>, then send the text. The receiver will parse the text back into a number using a function like <code>strtol()</code>.</p></li>
<li><p>Just send the data raw, passing a pointer to the data to <code>send()</code>.</p></li>
<li><p>Encode the number into a portable binary form. The receiver will decode it.</p></li>
</ol>
<p>Sneak preview! Tonight only!</p>
<p>[<em>Curtain raises</em>]</p>
<p>Beej says, “I prefer Method Three, above!”</p>
<p>[<em>THE END</em>]</p>
<p>(Before I begin this section in earnest, I should tell you that there
 are libraries out there for doing this, and rolling your own and 
remaining portable and error-free is quite a challenge. So hunt around 
and do your homework before deciding to implement this stuff yourself. I
 include the information here for those curious about how things like 
this work.)</p>
<p>Actually all the methods, above, have their drawbacks and advantages,
 but, like I said, in general, I prefer the third method. First, though,
 let’s talk about some of the drawbacks and advantages to the other two.</p>
<p>The first method, encoding the numbers as text before sending, has 
the advantage that you can easily print and read the data that’s coming 
over the wire. Sometimes a human-readable protocol is excellent to use 
in a non-bandwidth-intensive situation, such as with  <a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">Internet Relay Chat (IRC)</a><a href="#fn33" class="footnote-ref" id="fnref33" role="doc-noteref"><sup>33</sup></a>.
 However, it has the disadvantage that it is slow to convert, and the 
results almost always take up more space than the original number!</p>
<p>Method two: passing the raw data. This one is quite easy (but 
dangerous!): just take a pointer to the data to send, and call send with
 it.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> d = <span class="fl">3490.15926535</span>;</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>    send(s, &amp;d, <span class="kw">sizeof</span> d, <span class="dv">0</span>);  <span class="co">/* </span><span class="al">DANGER</span><span class="co">--non-portable! */</span></span></code></pre></div>
<p>The receiver gets it like this:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> d;</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    recv(s, &amp;d, <span class="kw">sizeof</span> d, <span class="dv">0</span>);  <span class="co">/* </span><span class="al">DANGER</span><span class="co">--non-portable! */</span></span></code></pre></div>
<p>Fast, simple—what’s not to like? Well, it turns out that not all architectures represent a <code>double</code> (or <code>int</code>
 for that matter) with the same bit representation or even the same byte
 ordering! The code is decidedly non-portable. (Hey—maybe you don’t need
 portability, in which case this is nice and fast.)</p>
<p>When packing integer types, we’ve already seen how the  <code>htons()</code>-class
 of functions can help keep things portable by transforming the numbers 
into  Network Byte Order, and how that’s the Right Thing to do. 
Unfortunately, there are no similar functions for <code>float</code> types. Is all hope lost?</p>
<p>Fear not! (Were you afraid there for a second? No? Not even a little 
bit?) There is something we can do: we can pack (or “marshal”, or 
“serialize”, or one of a thousand million other names) the data into a 
known binary format that the receiver can unpack on the remote side.</p>
<p>What do I mean by “known binary format”? Well, we’ve already seen the <code>htons()</code>
 example, right? It changes (or “encodes”, if you want to think of it 
that way) a number from whatever the host format is into Network Byte 
Order. To reverse (unencode) the number, the receiver calls <code>ntohs()</code>.</p>
<p>But didn’t I just get finished saying there wasn’t any such function 
for other non-integer types? Yes. I did. And since there’s no standard 
way in C to do this, it’s a bit of a pickle (that a gratuitous pun there
 for you Python fans).</p>
<p>The thing to do is to pack the data into a known format and send that over the wire for decoding. For example, to pack <code>float</code>s, here’s <a href="https://beej.us/guide/bgnet/examples/pack.c">something quick and dirty with plenty of room for improvement</a><a href="#fn34" class="footnote-ref" id="fnref34" role="doc-noteref"><sup>34</sup></a>:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb63-1"><a href="#cb63-1"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb63-2"><a href="#cb63-2"></a></span>
<span id="cb63-3"><a href="#cb63-3"></a><span class="dt">uint32_t</span> htonf(<span class="dt">float</span> f)</span>
<span id="cb63-4"><a href="#cb63-4"></a>{</span>
<span id="cb63-5"><a href="#cb63-5"></a>    <span class="dt">uint32_t</span> p;</span>
<span id="cb63-6"><a href="#cb63-6"></a>    <span class="dt">uint32_t</span> sign;</span>
<span id="cb63-7"><a href="#cb63-7"></a></span>
<span id="cb63-8"><a href="#cb63-8"></a>    <span class="cf">if</span> (f &lt; <span class="dv">0</span>) { sign = <span class="dv">1</span>; f = -f; }</span>
<span id="cb63-9"><a href="#cb63-9"></a>    <span class="cf">else</span> { sign = <span class="dv">0</span>; }</span>
<span id="cb63-10"><a href="#cb63-10"></a>        </span>
<span id="cb63-11"><a href="#cb63-11"></a>    p = ((((<span class="dt">uint32_t</span>)f)&amp;<span class="bn">0x7fff</span>)&lt;&lt;<span class="dv">16</span>) | (sign&lt;&lt;<span class="dv">31</span>); <span class="co">// whole part and sign</span></span>
<span id="cb63-12"><a href="#cb63-12"></a>    p |= (<span class="dt">uint32_t</span>)(((f - (<span class="dt">int</span>)f) * <span class="fl">65536.0</span><span class="bu">f</span>))&amp;<span class="bn">0xffff</span>; <span class="co">// fraction</span></span>
<span id="cb63-13"><a href="#cb63-13"></a></span>
<span id="cb63-14"><a href="#cb63-14"></a>    <span class="cf">return</span> p;</span>
<span id="cb63-15"><a href="#cb63-15"></a>}</span>
<span id="cb63-16"><a href="#cb63-16"></a></span>
<span id="cb63-17"><a href="#cb63-17"></a><span class="dt">float</span> ntohf(<span class="dt">uint32_t</span> p)</span>
<span id="cb63-18"><a href="#cb63-18"></a>{</span>
<span id="cb63-19"><a href="#cb63-19"></a>    <span class="dt">float</span> f = ((p&gt;&gt;<span class="dv">16</span>)&amp;<span class="bn">0x7fff</span>); <span class="co">// whole part</span></span>
<span id="cb63-20"><a href="#cb63-20"></a>    f += (p&amp;<span class="bn">0xffff</span>) / <span class="fl">65536.0</span><span class="bu">f</span>; <span class="co">// fraction</span></span>
<span id="cb63-21"><a href="#cb63-21"></a></span>
<span id="cb63-22"><a href="#cb63-22"></a>    <span class="cf">if</span> (((p&gt;&gt;<span class="dv">31</span>)&amp;<span class="bn">0x1</span>) == <span class="bn">0x1</span>) { f = -f; } <span class="co">// sign bit set</span></span>
<span id="cb63-23"><a href="#cb63-23"></a></span>
<span id="cb63-24"><a href="#cb63-24"></a>    <span class="cf">return</span> f;</span>
<span id="cb63-25"><a href="#cb63-25"></a>}</span></code></pre></div>
<p>The above code is sort of a naive implementation that stores a <code>float</code>
 in a 32-bit number. The high bit (31) is used to store the sign of the 
number (“1” means negative), and the next seven bits (30-16) are used to
 store the whole number portion of the <code>float</code>. Finally, the remaining bits (15-0) are used to store the fractional portion of the number.</p>
<p>Usage is fairly straightforward:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb64-1"><a href="#cb64-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb64-2"><a href="#cb64-2"></a></span>
<span id="cb64-3"><a href="#cb64-3"></a><span class="dt">int</span> main(<span class="dt">void</span>)</span>
<span id="cb64-4"><a href="#cb64-4"></a>{</span>
<span id="cb64-5"><a href="#cb64-5"></a>    <span class="dt">float</span> f = <span class="fl">3.1415926</span>, f2;</span>
<span id="cb64-6"><a href="#cb64-6"></a>    <span class="dt">uint32_t</span> netf;</span>
<span id="cb64-7"><a href="#cb64-7"></a></span>
<span id="cb64-8"><a href="#cb64-8"></a>    netf = htonf(f);  <span class="co">// convert to "network" form</span></span>
<span id="cb64-9"><a href="#cb64-9"></a>    f2 = ntohf(netf); <span class="co">// convert back to test</span></span>
<span id="cb64-10"><a href="#cb64-10"></a></span>
<span id="cb64-11"><a href="#cb64-11"></a>    printf(<span class="st">"Original: %f</span><span class="sc">\n</span><span class="st">"</span>, f);        <span class="co">// 3.141593</span></span>
<span id="cb64-12"><a href="#cb64-12"></a>    printf(<span class="st">" Network: 0x%08X</span><span class="sc">\n</span><span class="st">"</span>, netf); <span class="co">// 0x0003243F</span></span>
<span id="cb64-13"><a href="#cb64-13"></a>    printf(<span class="st">"Unpacked: %f</span><span class="sc">\n</span><span class="st">"</span>, f2);       <span class="co">// 3.141586</span></span>
<span id="cb64-14"><a href="#cb64-14"></a></span>
<span id="cb64-15"><a href="#cb64-15"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb64-16"><a href="#cb64-16"></a>}</span></code></pre></div>
<p>On the plus side, it’s small, simple, and fast. On the minus side, 
it’s not an efficient use of space and the range is severely 
restricted—try storing a number greater-than 32767 in there and it won’t
 be very happy! You can also see in the above example that the last 
couple decimal places are not correctly preserved.</p>
<p>What can we do instead? Well, <em>The</em> Standard for storing floating point numbers is known as  <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE-754</a><a href="#fn35" class="footnote-ref" id="fnref35" role="doc-noteref"><sup>35</sup></a>.
 Most computers use this format internally for doing floating point 
math, so in those cases, strictly speaking, conversion wouldn’t need to 
be done. But if you want your source code to be portable, that’s an 
assumption you can’t necessarily make. (On the other hand, if you want 
things to be fast, you should optimize this out on platforms that don’t 
need to do it! That’s what <code>htons()</code> and its ilk do.)</p>
<p><a href="https://beej.us/guide/bgnet/examples/ieee754.c">Here’s some code that encodes floats and doubles into IEEE-754 format</a><a href="#fn36" class="footnote-ref" id="fnref36" role="doc-noteref"><sup>36</sup></a>. (Mostly—it doesn’t encode NaN or Infinity, but it could be modified to do that.)</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb65-1"><a href="#cb65-1"></a><span class="pp">#define pack754_32(f) (pack754((f), 32, 8))</span></span>
<span id="cb65-2"><a href="#cb65-2"></a><span class="pp">#define pack754_64(f) (pack754((f), 64, 11))</span></span>
<span id="cb65-3"><a href="#cb65-3"></a><span class="pp">#define unpack754_32(i) (unpack754((i), 32, 8))</span></span>
<span id="cb65-4"><a href="#cb65-4"></a><span class="pp">#define unpack754_64(i) (unpack754((i), 64, 11))</span></span>
<span id="cb65-5"><a href="#cb65-5"></a></span>
<span id="cb65-6"><a href="#cb65-6"></a><span class="dt">uint64_t</span> pack754(<span class="dt">long</span> <span class="dt">double</span> f, <span class="dt">unsigned</span> bits, <span class="dt">unsigned</span> expbits)</span>
<span id="cb65-7"><a href="#cb65-7"></a>{</span>
<span id="cb65-8"><a href="#cb65-8"></a>    <span class="dt">long</span> <span class="dt">double</span> fnorm;</span>
<span id="cb65-9"><a href="#cb65-9"></a>    <span class="dt">int</span> shift;</span>
<span id="cb65-10"><a href="#cb65-10"></a>    <span class="dt">long</span> <span class="dt">long</span> sign, exp, significand;</span>
<span id="cb65-11"><a href="#cb65-11"></a>    <span class="dt">unsigned</span> significandbits = bits - expbits - <span class="dv">1</span>; <span class="co">// -1 for sign bit</span></span>
<span id="cb65-12"><a href="#cb65-12"></a></span>
<span id="cb65-13"><a href="#cb65-13"></a>    <span class="cf">if</span> (f == <span class="fl">0.0</span>) <span class="cf">return</span> <span class="dv">0</span>; <span class="co">// get this special case out of the way</span></span>
<span id="cb65-14"><a href="#cb65-14"></a></span>
<span id="cb65-15"><a href="#cb65-15"></a>    <span class="co">// check sign and begin normalization</span></span>
<span id="cb65-16"><a href="#cb65-16"></a>    <span class="cf">if</span> (f &lt; <span class="dv">0</span>) { sign = <span class="dv">1</span>; fnorm = -f; }</span>
<span id="cb65-17"><a href="#cb65-17"></a>    <span class="cf">else</span> { sign = <span class="dv">0</span>; fnorm = f; }</span>
<span id="cb65-18"><a href="#cb65-18"></a></span>
<span id="cb65-19"><a href="#cb65-19"></a>    <span class="co">// get the normalized form of f and track the exponent</span></span>
<span id="cb65-20"><a href="#cb65-20"></a>    shift = <span class="dv">0</span>;</span>
<span id="cb65-21"><a href="#cb65-21"></a>    <span class="cf">while</span>(fnorm &gt;= <span class="fl">2.0</span>) { fnorm /= <span class="fl">2.0</span>; shift++; }</span>
<span id="cb65-22"><a href="#cb65-22"></a>    <span class="cf">while</span>(fnorm &lt; <span class="fl">1.0</span>) { fnorm *= <span class="fl">2.0</span>; shift--; }</span>
<span id="cb65-23"><a href="#cb65-23"></a>    fnorm = fnorm - <span class="fl">1.0</span>;</span>
<span id="cb65-24"><a href="#cb65-24"></a></span>
<span id="cb65-25"><a href="#cb65-25"></a>    <span class="co">// calculate the binary form (non-float) of the significand data</span></span>
<span id="cb65-26"><a href="#cb65-26"></a>    significand = fnorm * ((<span class="dv">1</span><span class="bu">LL</span>&lt;&lt;significandbits) + <span class="fl">0.5</span><span class="bu">f</span>);</span>
<span id="cb65-27"><a href="#cb65-27"></a></span>
<span id="cb65-28"><a href="#cb65-28"></a>    <span class="co">// get the biased exponent</span></span>
<span id="cb65-29"><a href="#cb65-29"></a>    exp = shift + ((<span class="dv">1</span>&lt;&lt;(expbits-<span class="dv">1</span>)) - <span class="dv">1</span>); <span class="co">// shift + bias</span></span>
<span id="cb65-30"><a href="#cb65-30"></a></span>
<span id="cb65-31"><a href="#cb65-31"></a>    <span class="co">// return the final answer</span></span>
<span id="cb65-32"><a href="#cb65-32"></a>    <span class="cf">return</span> (sign&lt;&lt;(bits-<span class="dv">1</span>)) | (exp&lt;&lt;(bits-expbits-<span class="dv">1</span>)) | significand;</span>
<span id="cb65-33"><a href="#cb65-33"></a>}</span>
<span id="cb65-34"><a href="#cb65-34"></a></span>
<span id="cb65-35"><a href="#cb65-35"></a><span class="dt">long</span> <span class="dt">double</span> unpack754(<span class="dt">uint64_t</span> i, <span class="dt">unsigned</span> bits, <span class="dt">unsigned</span> expbits)</span>
<span id="cb65-36"><a href="#cb65-36"></a>{</span>
<span id="cb65-37"><a href="#cb65-37"></a>    <span class="dt">long</span> <span class="dt">double</span> result;</span>
<span id="cb65-38"><a href="#cb65-38"></a>    <span class="dt">long</span> <span class="dt">long</span> shift;</span>
<span id="cb65-39"><a href="#cb65-39"></a>    <span class="dt">unsigned</span> bias;</span>
<span id="cb65-40"><a href="#cb65-40"></a>    <span class="dt">unsigned</span> significandbits = bits - expbits - <span class="dv">1</span>; <span class="co">// -1 for sign bit</span></span>
<span id="cb65-41"><a href="#cb65-41"></a></span>
<span id="cb65-42"><a href="#cb65-42"></a>    <span class="cf">if</span> (i == <span class="dv">0</span>) <span class="cf">return</span> <span class="fl">0.0</span>;</span>
<span id="cb65-43"><a href="#cb65-43"></a></span>
<span id="cb65-44"><a href="#cb65-44"></a>    <span class="co">// pull the significand</span></span>
<span id="cb65-45"><a href="#cb65-45"></a>    result = (i&amp;((<span class="dv">1</span><span class="bu">LL</span>&lt;&lt;significandbits)-<span class="dv">1</span>)); <span class="co">// mask</span></span>
<span id="cb65-46"><a href="#cb65-46"></a>    result /= (<span class="dv">1</span><span class="bu">LL</span>&lt;&lt;significandbits); <span class="co">// convert back to float</span></span>
<span id="cb65-47"><a href="#cb65-47"></a>    result += <span class="fl">1.0</span><span class="bu">f</span>; <span class="co">// add the one back on</span></span>
<span id="cb65-48"><a href="#cb65-48"></a></span>
<span id="cb65-49"><a href="#cb65-49"></a>    <span class="co">// deal with the exponent</span></span>
<span id="cb65-50"><a href="#cb65-50"></a>    bias = (<span class="dv">1</span>&lt;&lt;(expbits-<span class="dv">1</span>)) - <span class="dv">1</span>;</span>
<span id="cb65-51"><a href="#cb65-51"></a>    shift = ((i&gt;&gt;significandbits)&amp;((<span class="dv">1</span><span class="bu">LL</span>&lt;&lt;expbits)-<span class="dv">1</span>)) - bias;</span>
<span id="cb65-52"><a href="#cb65-52"></a>    <span class="cf">while</span>(shift &gt; <span class="dv">0</span>) { result *= <span class="fl">2.0</span>; shift--; }</span>
<span id="cb65-53"><a href="#cb65-53"></a>    <span class="cf">while</span>(shift &lt; <span class="dv">0</span>) { result /= <span class="fl">2.0</span>; shift++; }</span>
<span id="cb65-54"><a href="#cb65-54"></a></span>
<span id="cb65-55"><a href="#cb65-55"></a>    <span class="co">// sign it</span></span>
<span id="cb65-56"><a href="#cb65-56"></a>    result *= (i&gt;&gt;(bits-<span class="dv">1</span>))&amp;<span class="dv">1</span>? -<span class="fl">1.0</span>: <span class="fl">1.0</span>;</span>
<span id="cb65-57"><a href="#cb65-57"></a></span>
<span id="cb65-58"><a href="#cb65-58"></a>    <span class="cf">return</span> result;</span>
<span id="cb65-59"><a href="#cb65-59"></a>}</span></code></pre></div>
<p>I put some handy macros up there at the top for packing and unpacking 32-bit (probably a <code>float</code>) and 64-bit (probably a <code>double</code>) numbers, but the <code>pack754()</code> function could be called directly and told to encode <code>bits</code>-worth of data (<code>expbits</code> of which are reserved for the normalized number’s exponent).</p>
<p>Here’s sample usage:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb66-1"><a href="#cb66-1"></a></span>
<span id="cb66-2"><a href="#cb66-2"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb66-3"><a href="#cb66-3"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span><span class="pp"> </span><span class="co">// defines uintN_t types</span></span>
<span id="cb66-4"><a href="#cb66-4"></a><span class="pp">#include </span><span class="im">&lt;inttypes.h&gt;</span><span class="pp"> </span><span class="co">// defines PRIx macros</span></span>
<span id="cb66-5"><a href="#cb66-5"></a></span>
<span id="cb66-6"><a href="#cb66-6"></a><span class="dt">int</span> main(<span class="dt">void</span>)</span>
<span id="cb66-7"><a href="#cb66-7"></a>{</span>
<span id="cb66-8"><a href="#cb66-8"></a>    <span class="dt">float</span> f = <span class="fl">3.1415926</span>, f2;</span>
<span id="cb66-9"><a href="#cb66-9"></a>    <span class="dt">double</span> d = <span class="fl">3.14159265358979323</span>, d2;</span>
<span id="cb66-10"><a href="#cb66-10"></a>    <span class="dt">uint32_t</span> fi;</span>
<span id="cb66-11"><a href="#cb66-11"></a>    <span class="dt">uint64_t</span> di;</span>
<span id="cb66-12"><a href="#cb66-12"></a></span>
<span id="cb66-13"><a href="#cb66-13"></a>    fi = pack754_32(f);</span>
<span id="cb66-14"><a href="#cb66-14"></a>    f2 = unpack754_32(fi);</span>
<span id="cb66-15"><a href="#cb66-15"></a></span>
<span id="cb66-16"><a href="#cb66-16"></a>    di = pack754_64(d);</span>
<span id="cb66-17"><a href="#cb66-17"></a>    d2 = unpack754_64(di);</span>
<span id="cb66-18"><a href="#cb66-18"></a></span>
<span id="cb66-19"><a href="#cb66-19"></a>    printf(<span class="st">"float before : %.7f</span><span class="sc">\n</span><span class="st">"</span>, f);</span>
<span id="cb66-20"><a href="#cb66-20"></a>    printf(<span class="st">"float encoded: 0x%08"</span> PRIx32 <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>, fi);</span>
<span id="cb66-21"><a href="#cb66-21"></a>    printf(<span class="st">"float after  : %.7f</span><span class="sc">\n\n</span><span class="st">"</span>, f2);</span>
<span id="cb66-22"><a href="#cb66-22"></a></span>
<span id="cb66-23"><a href="#cb66-23"></a>    printf(<span class="st">"double before : %.20lf</span><span class="sc">\n</span><span class="st">"</span>, d);</span>
<span id="cb66-24"><a href="#cb66-24"></a>    printf(<span class="st">"double encoded: 0x%016"</span> PRIx64 <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>, di);</span>
<span id="cb66-25"><a href="#cb66-25"></a>    printf(<span class="st">"double after  : %.20lf</span><span class="sc">\n</span><span class="st">"</span>, d2);</span>
<span id="cb66-26"><a href="#cb66-26"></a></span>
<span id="cb66-27"><a href="#cb66-27"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb66-28"><a href="#cb66-28"></a>}</span></code></pre></div>
<p>The above code produces this output:</p>
<pre><code>    float before : 3.1415925
    float encoded: 0x40490FDA
    float after  : 3.1415925
    
    double before : 3.14159265358979311600
    double encoded: 0x400921FB54442D18
    double after  : 3.14159265358979311600</code></pre>
<p>Another question you might have is how do you pack <code>struct</code>s? Unfortunately for you, the compiler is free to put padding all over the place in a <code>struct</code>,
 and that means you can’t portably send the whole thing over the wire in
 one chunk. (Aren’t you getting sick of hearing “can’t do this”, “can’t 
do that”? Sorry! To quote a friend, “Whenever anything goes wrong, I 
always blame Microsoft.” This one might not be Microsoft’s fault, 
admittedly, but my friend’s statement is completely true.)</p>
<p>Back to it: the best way to send the <code>struct</code> over the wire is to pack each field independently and then unpack them into the <code>struct</code> when they arrive on the other side.</p>
<p>That’s a lot of work, is what you’re thinking. Yes, it is. One thing 
you can do is write a helper function to help pack the data for you. 
It’ll be fun! Really!</p>
<p>In the book <a href="https://beej.us/guide/url/tpop"><em>The Practice of Programming</em></a><a href="#fn37" class="footnote-ref" id="fnref37" role="doc-noteref"><sup>37</sup></a> by Kernighan and Pike, they implement <code>printf()</code>-like functions called <code>pack()</code> and <code>unpack()</code> that do exactly this. I’d link to them, but apparently those functions aren’t online with the rest of the source from the book.</p>
<p>(The Practice of Programming is an excellent read. Zeus saves a kitten every time I recommend it.)</p>
<p>At this point, I’m going to drop a pointer to a <a href="https://github.com/protobuf-c/protobuf-c">Protocol Buffers implementation in C</a><a href="#fn38" class="footnote-ref" id="fnref38" role="doc-noteref"><sup>38</sup></a> which I’ve never used, but looks completely respectable. Python and Perl programmers will want to check out their language’s <code>pack()</code> and <code>unpack()</code> functions for accomplishing the same thing. And Java has a big-ol’ Serializable interface that can be used in a similar way.</p>
<p>But if you want to write your own packing utility in C, K&amp;P’s trick is to use variable argument lists to make <code>printf()</code>-like functions to build the packets. <a href="https://beej.us/guide/bgnet/examples/pack2.c">Here’s a version I cooked up</a><a href="#fn39" class="footnote-ref" id="fnref39" role="doc-noteref"><sup>39</sup></a> on my own based on that which hopefully will be enough to give you an idea of how such a thing can work.</p>
<p>(This code references the <code>pack754()</code> functions, above. The <code>packi*()</code> functions operate like the familiar <code>htons()</code> family, except they pack into a <code>char</code> array instead of another integer.)</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb68-1"><a href="#cb68-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb68-2"><a href="#cb68-2"></a><span class="pp">#include </span><span class="im">&lt;ctype.h&gt;</span></span>
<span id="cb68-3"><a href="#cb68-3"></a><span class="pp">#include </span><span class="im">&lt;stdarg.h&gt;</span></span>
<span id="cb68-4"><a href="#cb68-4"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb68-5"><a href="#cb68-5"></a></span>
<span id="cb68-6"><a href="#cb68-6"></a><span class="co">/*</span></span>
<span id="cb68-7"><a href="#cb68-7"></a><span class="co">** packi16() -- store a 16-bit int into a char buffer (like htons())</span></span>
<span id="cb68-8"><a href="#cb68-8"></a><span class="co">*/</span> </span>
<span id="cb68-9"><a href="#cb68-9"></a><span class="dt">void</span> packi16(<span class="dt">unsigned</span> <span class="dt">char</span> *buf, <span class="dt">unsigned</span> <span class="dt">int</span> i)</span>
<span id="cb68-10"><a href="#cb68-10"></a>{</span>
<span id="cb68-11"><a href="#cb68-11"></a>    *buf++ = i&gt;&gt;<span class="dv">8</span>; *buf++ = i;</span>
<span id="cb68-12"><a href="#cb68-12"></a>}</span>
<span id="cb68-13"><a href="#cb68-13"></a></span>
<span id="cb68-14"><a href="#cb68-14"></a><span class="co">/*</span></span>
<span id="cb68-15"><a href="#cb68-15"></a><span class="co">** packi32() -- store a 32-bit int into a char buffer (like htonl())</span></span>
<span id="cb68-16"><a href="#cb68-16"></a><span class="co">*/</span> </span>
<span id="cb68-17"><a href="#cb68-17"></a><span class="dt">void</span> packi32(<span class="dt">unsigned</span> <span class="dt">char</span> *buf, <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> i)</span>
<span id="cb68-18"><a href="#cb68-18"></a>{</span>
<span id="cb68-19"><a href="#cb68-19"></a>    *buf++ = i&gt;&gt;<span class="dv">24</span>; *buf++ = i&gt;&gt;<span class="dv">16</span>;</span>
<span id="cb68-20"><a href="#cb68-20"></a>    *buf++ = i&gt;&gt;<span class="dv">8</span>;  *buf++ = i;</span>
<span id="cb68-21"><a href="#cb68-21"></a>}</span>
<span id="cb68-22"><a href="#cb68-22"></a></span>
<span id="cb68-23"><a href="#cb68-23"></a><span class="co">/*</span></span>
<span id="cb68-24"><a href="#cb68-24"></a><span class="co">** packi64() -- store a 64-bit int into a char buffer (like htonl())</span></span>
<span id="cb68-25"><a href="#cb68-25"></a><span class="co">*/</span> </span>
<span id="cb68-26"><a href="#cb68-26"></a><span class="dt">void</span> packi64(<span class="dt">unsigned</span> <span class="dt">char</span> *buf, <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> i)</span>
<span id="cb68-27"><a href="#cb68-27"></a>{</span>
<span id="cb68-28"><a href="#cb68-28"></a>    *buf++ = i&gt;&gt;<span class="dv">56</span>; *buf++ = i&gt;&gt;<span class="dv">48</span>;</span>
<span id="cb68-29"><a href="#cb68-29"></a>    *buf++ = i&gt;&gt;<span class="dv">40</span>; *buf++ = i&gt;&gt;<span class="dv">32</span>;</span>
<span id="cb68-30"><a href="#cb68-30"></a>    *buf++ = i&gt;&gt;<span class="dv">24</span>; *buf++ = i&gt;&gt;<span class="dv">16</span>;</span>
<span id="cb68-31"><a href="#cb68-31"></a>    *buf++ = i&gt;&gt;<span class="dv">8</span>;  *buf++ = i;</span>
<span id="cb68-32"><a href="#cb68-32"></a>}</span>
<span id="cb68-33"><a href="#cb68-33"></a></span>
<span id="cb68-34"><a href="#cb68-34"></a><span class="co">/*</span></span>
<span id="cb68-35"><a href="#cb68-35"></a><span class="co">** unpacki16() -- unpack a 16-bit int from a char buffer (like ntohs())</span></span>
<span id="cb68-36"><a href="#cb68-36"></a><span class="co">*/</span> </span>
<span id="cb68-37"><a href="#cb68-37"></a><span class="dt">int</span> unpacki16(<span class="dt">unsigned</span> <span class="dt">char</span> *buf)</span>
<span id="cb68-38"><a href="#cb68-38"></a>{</span>
<span id="cb68-39"><a href="#cb68-39"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> i2 = ((<span class="dt">unsigned</span> <span class="dt">int</span>)buf[<span class="dv">0</span>]&lt;&lt;<span class="dv">8</span>) | buf[<span class="dv">1</span>];</span>
<span id="cb68-40"><a href="#cb68-40"></a>    <span class="dt">int</span> i;</span>
<span id="cb68-41"><a href="#cb68-41"></a></span>
<span id="cb68-42"><a href="#cb68-42"></a>    <span class="co">// change unsigned numbers to signed</span></span>
<span id="cb68-43"><a href="#cb68-43"></a>    <span class="cf">if</span> (i2 &lt;= <span class="bn">0x7fff</span><span class="bu">u</span>) { i = i2; }</span>
<span id="cb68-44"><a href="#cb68-44"></a>    <span class="cf">else</span> { i = -<span class="dv">1</span> - (<span class="dt">unsigned</span> <span class="dt">int</span>)(<span class="bn">0xffff</span><span class="bu">u</span> - i2); }</span>
<span id="cb68-45"><a href="#cb68-45"></a></span>
<span id="cb68-46"><a href="#cb68-46"></a>    <span class="cf">return</span> i;</span>
<span id="cb68-47"><a href="#cb68-47"></a>}</span>
<span id="cb68-48"><a href="#cb68-48"></a></span>
<span id="cb68-49"><a href="#cb68-49"></a><span class="co">/*</span></span>
<span id="cb68-50"><a href="#cb68-50"></a><span class="co">** unpacku16() -- unpack a 16-bit unsigned from a char buffer (like ntohs())</span></span>
<span id="cb68-51"><a href="#cb68-51"></a><span class="co">*/</span> </span>
<span id="cb68-52"><a href="#cb68-52"></a><span class="dt">unsigned</span> <span class="dt">int</span> unpacku16(<span class="dt">unsigned</span> <span class="dt">char</span> *buf)</span>
<span id="cb68-53"><a href="#cb68-53"></a>{</span>
<span id="cb68-54"><a href="#cb68-54"></a>    <span class="cf">return</span> ((<span class="dt">unsigned</span> <span class="dt">int</span>)buf[<span class="dv">0</span>]&lt;&lt;<span class="dv">8</span>) | buf[<span class="dv">1</span>];</span>
<span id="cb68-55"><a href="#cb68-55"></a>}</span>
<span id="cb68-56"><a href="#cb68-56"></a></span>
<span id="cb68-57"><a href="#cb68-57"></a><span class="co">/*</span></span>
<span id="cb68-58"><a href="#cb68-58"></a><span class="co">** unpacki32() -- unpack a 32-bit int from a char buffer (like ntohl())</span></span>
<span id="cb68-59"><a href="#cb68-59"></a><span class="co">*/</span> </span>
<span id="cb68-60"><a href="#cb68-60"></a><span class="dt">long</span> <span class="dt">int</span> unpacki32(<span class="dt">unsigned</span> <span class="dt">char</span> *buf)</span>
<span id="cb68-61"><a href="#cb68-61"></a>{</span>
<span id="cb68-62"><a href="#cb68-62"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> i2 = ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">0</span>]&lt;&lt;<span class="dv">24</span>) |</span>
<span id="cb68-63"><a href="#cb68-63"></a>                           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">1</span>]&lt;&lt;<span class="dv">16</span>) |</span>
<span id="cb68-64"><a href="#cb68-64"></a>                           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">2</span>]&lt;&lt;<span class="dv">8</span>)  |</span>
<span id="cb68-65"><a href="#cb68-65"></a>                           buf[<span class="dv">3</span>];</span>
<span id="cb68-66"><a href="#cb68-66"></a>    <span class="dt">long</span> <span class="dt">int</span> i;</span>
<span id="cb68-67"><a href="#cb68-67"></a></span>
<span id="cb68-68"><a href="#cb68-68"></a>    <span class="co">// change unsigned numbers to signed</span></span>
<span id="cb68-69"><a href="#cb68-69"></a>    <span class="cf">if</span> (i2 &lt;= <span class="bn">0x7fffffff</span><span class="bu">u</span>) { i = i2; }</span>
<span id="cb68-70"><a href="#cb68-70"></a>    <span class="cf">else</span> { i = -<span class="dv">1</span> - (<span class="dt">long</span> <span class="dt">int</span>)(<span class="bn">0xffffffff</span><span class="bu">u</span> - i2); }</span>
<span id="cb68-71"><a href="#cb68-71"></a></span>
<span id="cb68-72"><a href="#cb68-72"></a>    <span class="cf">return</span> i;</span>
<span id="cb68-73"><a href="#cb68-73"></a>}</span>
<span id="cb68-74"><a href="#cb68-74"></a></span>
<span id="cb68-75"><a href="#cb68-75"></a><span class="co">/*</span></span>
<span id="cb68-76"><a href="#cb68-76"></a><span class="co">** unpacku32() -- unpack a 32-bit unsigned from a char buffer (like ntohl())</span></span>
<span id="cb68-77"><a href="#cb68-77"></a><span class="co">*/</span> </span>
<span id="cb68-78"><a href="#cb68-78"></a><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> unpacku32(<span class="dt">unsigned</span> <span class="dt">char</span> *buf)</span>
<span id="cb68-79"><a href="#cb68-79"></a>{</span>
<span id="cb68-80"><a href="#cb68-80"></a>    <span class="cf">return</span> ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">0</span>]&lt;&lt;<span class="dv">24</span>) |</span>
<span id="cb68-81"><a href="#cb68-81"></a>           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">1</span>]&lt;&lt;<span class="dv">16</span>) |</span>
<span id="cb68-82"><a href="#cb68-82"></a>           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">2</span>]&lt;&lt;<span class="dv">8</span>)  |</span>
<span id="cb68-83"><a href="#cb68-83"></a>           buf[<span class="dv">3</span>];</span>
<span id="cb68-84"><a href="#cb68-84"></a>}</span>
<span id="cb68-85"><a href="#cb68-85"></a></span>
<span id="cb68-86"><a href="#cb68-86"></a><span class="co">/*</span></span>
<span id="cb68-87"><a href="#cb68-87"></a><span class="co">** unpacki64() -- unpack a 64-bit int from a char buffer (like ntohl())</span></span>
<span id="cb68-88"><a href="#cb68-88"></a><span class="co">*/</span> </span>
<span id="cb68-89"><a href="#cb68-89"></a><span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> unpacki64(<span class="dt">unsigned</span> <span class="dt">char</span> *buf)</span>
<span id="cb68-90"><a href="#cb68-90"></a>{</span>
<span id="cb68-91"><a href="#cb68-91"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> i2 = ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">0</span>]&lt;&lt;<span class="dv">56</span>) |</span>
<span id="cb68-92"><a href="#cb68-92"></a>                                ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">1</span>]&lt;&lt;<span class="dv">48</span>) |</span>
<span id="cb68-93"><a href="#cb68-93"></a>                                ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">2</span>]&lt;&lt;<span class="dv">40</span>) |</span>
<span id="cb68-94"><a href="#cb68-94"></a>                                ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">3</span>]&lt;&lt;<span class="dv">32</span>) |</span>
<span id="cb68-95"><a href="#cb68-95"></a>                                ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">4</span>]&lt;&lt;<span class="dv">24</span>) |</span>
<span id="cb68-96"><a href="#cb68-96"></a>                                ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">5</span>]&lt;&lt;<span class="dv">16</span>) |</span>
<span id="cb68-97"><a href="#cb68-97"></a>                                ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">6</span>]&lt;&lt;<span class="dv">8</span>)  |</span>
<span id="cb68-98"><a href="#cb68-98"></a>                                buf[<span class="dv">7</span>];</span>
<span id="cb68-99"><a href="#cb68-99"></a>    <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> i;</span>
<span id="cb68-100"><a href="#cb68-100"></a></span>
<span id="cb68-101"><a href="#cb68-101"></a>    <span class="co">// change unsigned numbers to signed</span></span>
<span id="cb68-102"><a href="#cb68-102"></a>    <span class="cf">if</span> (i2 &lt;= <span class="bn">0x7fffffffffffffff</span><span class="bu">u</span>) { i = i2; }</span>
<span id="cb68-103"><a href="#cb68-103"></a>    <span class="cf">else</span> { i = -<span class="dv">1</span> -(<span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)(<span class="bn">0xffffffffffffffff</span><span class="bu">u</span> - i2); }</span>
<span id="cb68-104"><a href="#cb68-104"></a></span>
<span id="cb68-105"><a href="#cb68-105"></a>    <span class="cf">return</span> i;</span>
<span id="cb68-106"><a href="#cb68-106"></a>}</span>
<span id="cb68-107"><a href="#cb68-107"></a></span>
<span id="cb68-108"><a href="#cb68-108"></a><span class="co">/*</span></span>
<span id="cb68-109"><a href="#cb68-109"></a><span class="co">** unpacku64() -- unpack a 64-bit unsigned from a char buffer (like ntohl())</span></span>
<span id="cb68-110"><a href="#cb68-110"></a><span class="co">*/</span> </span>
<span id="cb68-111"><a href="#cb68-111"></a><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> unpacku64(<span class="dt">unsigned</span> <span class="dt">char</span> *buf)</span>
<span id="cb68-112"><a href="#cb68-112"></a>{</span>
<span id="cb68-113"><a href="#cb68-113"></a>    <span class="cf">return</span> ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">0</span>]&lt;&lt;<span class="dv">56</span>) |</span>
<span id="cb68-114"><a href="#cb68-114"></a>           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">1</span>]&lt;&lt;<span class="dv">48</span>) |</span>
<span id="cb68-115"><a href="#cb68-115"></a>           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">2</span>]&lt;&lt;<span class="dv">40</span>) |</span>
<span id="cb68-116"><a href="#cb68-116"></a>           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">3</span>]&lt;&lt;<span class="dv">32</span>) |</span>
<span id="cb68-117"><a href="#cb68-117"></a>           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">4</span>]&lt;&lt;<span class="dv">24</span>) |</span>
<span id="cb68-118"><a href="#cb68-118"></a>           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">5</span>]&lt;&lt;<span class="dv">16</span>) |</span>
<span id="cb68-119"><a href="#cb68-119"></a>           ((<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>)buf[<span class="dv">6</span>]&lt;&lt;<span class="dv">8</span>)  |</span>
<span id="cb68-120"><a href="#cb68-120"></a>           buf[<span class="dv">7</span>];</span>
<span id="cb68-121"><a href="#cb68-121"></a>}</span>
<span id="cb68-122"><a href="#cb68-122"></a></span>
<span id="cb68-123"><a href="#cb68-123"></a><span class="co">/*</span></span>
<span id="cb68-124"><a href="#cb68-124"></a><span class="co">** pack() -- store data dictated by the format string in the buffer</span></span>
<span id="cb68-125"><a href="#cb68-125"></a><span class="co">**</span></span>
<span id="cb68-126"><a href="#cb68-126"></a><span class="co">**   bits |signed   unsigned   float   string</span></span>
<span id="cb68-127"><a href="#cb68-127"></a><span class="co">**   -----+----------------------------------</span></span>
<span id="cb68-128"><a href="#cb68-128"></a><span class="co">**      8 |   c        C         </span></span>
<span id="cb68-129"><a href="#cb68-129"></a><span class="co">**     16 |   h        H         f</span></span>
<span id="cb68-130"><a href="#cb68-130"></a><span class="co">**     32 |   l        L         d</span></span>
<span id="cb68-131"><a href="#cb68-131"></a><span class="co">**     64 |   q        Q         g</span></span>
<span id="cb68-132"><a href="#cb68-132"></a><span class="co">**      - |                               s</span></span>
<span id="cb68-133"><a href="#cb68-133"></a><span class="co">**</span></span>
<span id="cb68-134"><a href="#cb68-134"></a><span class="co">**  (16-bit unsigned length is automatically prepended to strings)</span></span>
<span id="cb68-135"><a href="#cb68-135"></a><span class="co">*/</span> </span>
<span id="cb68-136"><a href="#cb68-136"></a></span>
<span id="cb68-137"><a href="#cb68-137"></a><span class="dt">unsigned</span> <span class="dt">int</span> pack(<span class="dt">unsigned</span> <span class="dt">char</span> *buf, <span class="dt">char</span> *format, ...)</span>
<span id="cb68-138"><a href="#cb68-138"></a>{</span>
<span id="cb68-139"><a href="#cb68-139"></a>    <span class="dt">va_list</span> ap;</span>
<span id="cb68-140"><a href="#cb68-140"></a></span>
<span id="cb68-141"><a href="#cb68-141"></a>    <span class="dt">signed</span> <span class="dt">char</span> c;              <span class="co">// 8-bit</span></span>
<span id="cb68-142"><a href="#cb68-142"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> C;</span>
<span id="cb68-143"><a href="#cb68-143"></a></span>
<span id="cb68-144"><a href="#cb68-144"></a>    <span class="dt">int</span> h;                      <span class="co">// 16-bit</span></span>
<span id="cb68-145"><a href="#cb68-145"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> H;</span>
<span id="cb68-146"><a href="#cb68-146"></a></span>
<span id="cb68-147"><a href="#cb68-147"></a>    <span class="dt">long</span> <span class="dt">int</span> l;                 <span class="co">// 32-bit</span></span>
<span id="cb68-148"><a href="#cb68-148"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> L;</span>
<span id="cb68-149"><a href="#cb68-149"></a></span>
<span id="cb68-150"><a href="#cb68-150"></a>    <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> q;            <span class="co">// 64-bit</span></span>
<span id="cb68-151"><a href="#cb68-151"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> Q;</span>
<span id="cb68-152"><a href="#cb68-152"></a></span>
<span id="cb68-153"><a href="#cb68-153"></a>    <span class="dt">float</span> f;                    <span class="co">// floats</span></span>
<span id="cb68-154"><a href="#cb68-154"></a>    <span class="dt">double</span> d;</span>
<span id="cb68-155"><a href="#cb68-155"></a>    <span class="dt">long</span> <span class="dt">double</span> g;</span>
<span id="cb68-156"><a href="#cb68-156"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> fhold;</span>
<span id="cb68-157"><a href="#cb68-157"></a></span>
<span id="cb68-158"><a href="#cb68-158"></a>    <span class="dt">char</span> *s;                    <span class="co">// strings</span></span>
<span id="cb68-159"><a href="#cb68-159"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> len;</span>
<span id="cb68-160"><a href="#cb68-160"></a></span>
<span id="cb68-161"><a href="#cb68-161"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> size = <span class="dv">0</span>;</span>
<span id="cb68-162"><a href="#cb68-162"></a></span>
<span id="cb68-163"><a href="#cb68-163"></a>    va_start(ap, format);</span>
<span id="cb68-164"><a href="#cb68-164"></a></span>
<span id="cb68-165"><a href="#cb68-165"></a>    <span class="cf">for</span>(; *format != <span class="ch">'\0'</span>; format++) {</span>
<span id="cb68-166"><a href="#cb68-166"></a>        <span class="cf">switch</span>(*format) {</span>
<span id="cb68-167"><a href="#cb68-167"></a>        <span class="cf">case</span> <span class="ch">'c'</span>: <span class="co">// 8-bit</span></span>
<span id="cb68-168"><a href="#cb68-168"></a>            size += <span class="dv">1</span>;</span>
<span id="cb68-169"><a href="#cb68-169"></a>            c = (<span class="dt">signed</span> <span class="dt">char</span>)va_arg(ap, <span class="dt">int</span>); <span class="co">// promoted</span></span>
<span id="cb68-170"><a href="#cb68-170"></a>            *buf++ = c;</span>
<span id="cb68-171"><a href="#cb68-171"></a>            <span class="cf">break</span>;</span>
<span id="cb68-172"><a href="#cb68-172"></a></span>
<span id="cb68-173"><a href="#cb68-173"></a>        <span class="cf">case</span> <span class="ch">'C'</span>: <span class="co">// 8-bit unsigned</span></span>
<span id="cb68-174"><a href="#cb68-174"></a>            size += <span class="dv">1</span>;</span>
<span id="cb68-175"><a href="#cb68-175"></a>            C = (<span class="dt">unsigned</span> <span class="dt">char</span>)va_arg(ap, <span class="dt">unsigned</span> <span class="dt">int</span>); <span class="co">// promoted</span></span>
<span id="cb68-176"><a href="#cb68-176"></a>            *buf++ = C;</span>
<span id="cb68-177"><a href="#cb68-177"></a>            <span class="cf">break</span>;</span>
<span id="cb68-178"><a href="#cb68-178"></a></span>
<span id="cb68-179"><a href="#cb68-179"></a>        <span class="cf">case</span> <span class="ch">'h'</span>: <span class="co">// 16-bit</span></span>
<span id="cb68-180"><a href="#cb68-180"></a>            size += <span class="dv">2</span>;</span>
<span id="cb68-181"><a href="#cb68-181"></a>            h = va_arg(ap, <span class="dt">int</span>);</span>
<span id="cb68-182"><a href="#cb68-182"></a>            packi16(buf, h);</span>
<span id="cb68-183"><a href="#cb68-183"></a>            buf += <span class="dv">2</span>;</span>
<span id="cb68-184"><a href="#cb68-184"></a>            <span class="cf">break</span>;</span>
<span id="cb68-185"><a href="#cb68-185"></a></span>
<span id="cb68-186"><a href="#cb68-186"></a>        <span class="cf">case</span> <span class="ch">'H'</span>: <span class="co">// 16-bit unsigned</span></span>
<span id="cb68-187"><a href="#cb68-187"></a>            size += <span class="dv">2</span>;</span>
<span id="cb68-188"><a href="#cb68-188"></a>            H = va_arg(ap, <span class="dt">unsigned</span> <span class="dt">int</span>);</span>
<span id="cb68-189"><a href="#cb68-189"></a>            packi16(buf, H);</span>
<span id="cb68-190"><a href="#cb68-190"></a>            buf += <span class="dv">2</span>;</span>
<span id="cb68-191"><a href="#cb68-191"></a>            <span class="cf">break</span>;</span>
<span id="cb68-192"><a href="#cb68-192"></a></span>
<span id="cb68-193"><a href="#cb68-193"></a>        <span class="cf">case</span> <span class="ch">'l'</span>: <span class="co">// 32-bit</span></span>
<span id="cb68-194"><a href="#cb68-194"></a>            size += <span class="dv">4</span>;</span>
<span id="cb68-195"><a href="#cb68-195"></a>            l = va_arg(ap, <span class="dt">long</span> <span class="dt">int</span>);</span>
<span id="cb68-196"><a href="#cb68-196"></a>            packi32(buf, l);</span>
<span id="cb68-197"><a href="#cb68-197"></a>            buf += <span class="dv">4</span>;</span>
<span id="cb68-198"><a href="#cb68-198"></a>            <span class="cf">break</span>;</span>
<span id="cb68-199"><a href="#cb68-199"></a></span>
<span id="cb68-200"><a href="#cb68-200"></a>        <span class="cf">case</span> <span class="ch">'L'</span>: <span class="co">// 32-bit unsigned</span></span>
<span id="cb68-201"><a href="#cb68-201"></a>            size += <span class="dv">4</span>;</span>
<span id="cb68-202"><a href="#cb68-202"></a>            L = va_arg(ap, <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>);</span>
<span id="cb68-203"><a href="#cb68-203"></a>            packi32(buf, L);</span>
<span id="cb68-204"><a href="#cb68-204"></a>            buf += <span class="dv">4</span>;</span>
<span id="cb68-205"><a href="#cb68-205"></a>            <span class="cf">break</span>;</span>
<span id="cb68-206"><a href="#cb68-206"></a></span>
<span id="cb68-207"><a href="#cb68-207"></a>        <span class="cf">case</span> <span class="ch">'q'</span>: <span class="co">// 64-bit</span></span>
<span id="cb68-208"><a href="#cb68-208"></a>            size += <span class="dv">8</span>;</span>
<span id="cb68-209"><a href="#cb68-209"></a>            q = va_arg(ap, <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>);</span>
<span id="cb68-210"><a href="#cb68-210"></a>            packi64(buf, q);</span>
<span id="cb68-211"><a href="#cb68-211"></a>            buf += <span class="dv">8</span>;</span>
<span id="cb68-212"><a href="#cb68-212"></a>            <span class="cf">break</span>;</span>
<span id="cb68-213"><a href="#cb68-213"></a></span>
<span id="cb68-214"><a href="#cb68-214"></a>        <span class="cf">case</span> <span class="ch">'Q'</span>: <span class="co">// 64-bit unsigned</span></span>
<span id="cb68-215"><a href="#cb68-215"></a>            size += <span class="dv">8</span>;</span>
<span id="cb68-216"><a href="#cb68-216"></a>            Q = va_arg(ap, <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>);</span>
<span id="cb68-217"><a href="#cb68-217"></a>            packi64(buf, Q);</span>
<span id="cb68-218"><a href="#cb68-218"></a>            buf += <span class="dv">8</span>;</span>
<span id="cb68-219"><a href="#cb68-219"></a>            <span class="cf">break</span>;</span>
<span id="cb68-220"><a href="#cb68-220"></a></span>
<span id="cb68-221"><a href="#cb68-221"></a>        <span class="cf">case</span> <span class="ch">'f'</span>: <span class="co">// float-16</span></span>
<span id="cb68-222"><a href="#cb68-222"></a>            size += <span class="dv">2</span>;</span>
<span id="cb68-223"><a href="#cb68-223"></a>            f = (<span class="dt">float</span>)va_arg(ap, <span class="dt">double</span>); <span class="co">// promoted</span></span>
<span id="cb68-224"><a href="#cb68-224"></a>            fhold = pack754_16(f); <span class="co">// convert to IEEE 754</span></span>
<span id="cb68-225"><a href="#cb68-225"></a>            packi16(buf, fhold);</span>
<span id="cb68-226"><a href="#cb68-226"></a>            buf += <span class="dv">2</span>;</span>
<span id="cb68-227"><a href="#cb68-227"></a>            <span class="cf">break</span>;</span>
<span id="cb68-228"><a href="#cb68-228"></a></span>
<span id="cb68-229"><a href="#cb68-229"></a>        <span class="cf">case</span> <span class="ch">'d'</span>: <span class="co">// float-32</span></span>
<span id="cb68-230"><a href="#cb68-230"></a>            size += <span class="dv">4</span>;</span>
<span id="cb68-231"><a href="#cb68-231"></a>            d = va_arg(ap, <span class="dt">double</span>);</span>
<span id="cb68-232"><a href="#cb68-232"></a>            fhold = pack754_32(d); <span class="co">// convert to IEEE 754</span></span>
<span id="cb68-233"><a href="#cb68-233"></a>            packi32(buf, fhold);</span>
<span id="cb68-234"><a href="#cb68-234"></a>            buf += <span class="dv">4</span>;</span>
<span id="cb68-235"><a href="#cb68-235"></a>            <span class="cf">break</span>;</span>
<span id="cb68-236"><a href="#cb68-236"></a></span>
<span id="cb68-237"><a href="#cb68-237"></a>        <span class="cf">case</span> <span class="ch">'g'</span>: <span class="co">// float-64</span></span>
<span id="cb68-238"><a href="#cb68-238"></a>            size += <span class="dv">8</span>;</span>
<span id="cb68-239"><a href="#cb68-239"></a>            g = va_arg(ap, <span class="dt">long</span> <span class="dt">double</span>);</span>
<span id="cb68-240"><a href="#cb68-240"></a>            fhold = pack754_64(g); <span class="co">// convert to IEEE 754</span></span>
<span id="cb68-241"><a href="#cb68-241"></a>            packi64(buf, fhold);</span>
<span id="cb68-242"><a href="#cb68-242"></a>            buf += <span class="dv">8</span>;</span>
<span id="cb68-243"><a href="#cb68-243"></a>            <span class="cf">break</span>;</span>
<span id="cb68-244"><a href="#cb68-244"></a></span>
<span id="cb68-245"><a href="#cb68-245"></a>        <span class="cf">case</span> <span class="ch">'s'</span>: <span class="co">// string</span></span>
<span id="cb68-246"><a href="#cb68-246"></a>            s = va_arg(ap, <span class="dt">char</span>*);</span>
<span id="cb68-247"><a href="#cb68-247"></a>            len = strlen(s);</span>
<span id="cb68-248"><a href="#cb68-248"></a>            size += len + <span class="dv">2</span>;</span>
<span id="cb68-249"><a href="#cb68-249"></a>            packi16(buf, len);</span>
<span id="cb68-250"><a href="#cb68-250"></a>            buf += <span class="dv">2</span>;</span>
<span id="cb68-251"><a href="#cb68-251"></a>            memcpy(buf, s, len);</span>
<span id="cb68-252"><a href="#cb68-252"></a>            buf += len;</span>
<span id="cb68-253"><a href="#cb68-253"></a>            <span class="cf">break</span>;</span>
<span id="cb68-254"><a href="#cb68-254"></a>        }</span>
<span id="cb68-255"><a href="#cb68-255"></a>    }</span>
<span id="cb68-256"><a href="#cb68-256"></a></span>
<span id="cb68-257"><a href="#cb68-257"></a>    va_end(ap);</span>
<span id="cb68-258"><a href="#cb68-258"></a></span>
<span id="cb68-259"><a href="#cb68-259"></a>    <span class="cf">return</span> size;</span>
<span id="cb68-260"><a href="#cb68-260"></a>}</span>
<span id="cb68-261"><a href="#cb68-261"></a></span>
<span id="cb68-262"><a href="#cb68-262"></a><span class="co">/*</span></span>
<span id="cb68-263"><a href="#cb68-263"></a><span class="co">** unpack() -- unpack data dictated by the format string into the buffer</span></span>
<span id="cb68-264"><a href="#cb68-264"></a><span class="co">**</span></span>
<span id="cb68-265"><a href="#cb68-265"></a><span class="co">**   bits |signed   unsigned   float   string</span></span>
<span id="cb68-266"><a href="#cb68-266"></a><span class="co">**   -----+----------------------------------</span></span>
<span id="cb68-267"><a href="#cb68-267"></a><span class="co">**      8 |   c        C         </span></span>
<span id="cb68-268"><a href="#cb68-268"></a><span class="co">**     16 |   h        H         f</span></span>
<span id="cb68-269"><a href="#cb68-269"></a><span class="co">**     32 |   l        L         d</span></span>
<span id="cb68-270"><a href="#cb68-270"></a><span class="co">**     64 |   q        Q         g</span></span>
<span id="cb68-271"><a href="#cb68-271"></a><span class="co">**      - |                               s</span></span>
<span id="cb68-272"><a href="#cb68-272"></a><span class="co">**</span></span>
<span id="cb68-273"><a href="#cb68-273"></a><span class="co">**  (string is extracted based on its stored length, but 's' can be</span></span>
<span id="cb68-274"><a href="#cb68-274"></a><span class="co">**  prepended with a max length)</span></span>
<span id="cb68-275"><a href="#cb68-275"></a><span class="co">*/</span></span>
<span id="cb68-276"><a href="#cb68-276"></a><span class="dt">void</span> unpack(<span class="dt">unsigned</span> <span class="dt">char</span> *buf, <span class="dt">char</span> *format, ...)</span>
<span id="cb68-277"><a href="#cb68-277"></a>{</span>
<span id="cb68-278"><a href="#cb68-278"></a>    <span class="dt">va_list</span> ap;</span>
<span id="cb68-279"><a href="#cb68-279"></a></span>
<span id="cb68-280"><a href="#cb68-280"></a>    <span class="dt">signed</span> <span class="dt">char</span> *c;              <span class="co">// 8-bit</span></span>
<span id="cb68-281"><a href="#cb68-281"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> *C;</span>
<span id="cb68-282"><a href="#cb68-282"></a></span>
<span id="cb68-283"><a href="#cb68-283"></a>    <span class="dt">int</span> *h;                      <span class="co">// 16-bit</span></span>
<span id="cb68-284"><a href="#cb68-284"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> *H;</span>
<span id="cb68-285"><a href="#cb68-285"></a></span>
<span id="cb68-286"><a href="#cb68-286"></a>    <span class="dt">long</span> <span class="dt">int</span> *l;                 <span class="co">// 32-bit</span></span>
<span id="cb68-287"><a href="#cb68-287"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> *L;</span>
<span id="cb68-288"><a href="#cb68-288"></a></span>
<span id="cb68-289"><a href="#cb68-289"></a>    <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> *q;            <span class="co">// 64-bit</span></span>
<span id="cb68-290"><a href="#cb68-290"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> *Q;</span>
<span id="cb68-291"><a href="#cb68-291"></a></span>
<span id="cb68-292"><a href="#cb68-292"></a>    <span class="dt">float</span> *f;                    <span class="co">// floats</span></span>
<span id="cb68-293"><a href="#cb68-293"></a>    <span class="dt">double</span> *d;</span>
<span id="cb68-294"><a href="#cb68-294"></a>    <span class="dt">long</span> <span class="dt">double</span> *g;</span>
<span id="cb68-295"><a href="#cb68-295"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> fhold;</span>
<span id="cb68-296"><a href="#cb68-296"></a></span>
<span id="cb68-297"><a href="#cb68-297"></a>    <span class="dt">char</span> *s;</span>
<span id="cb68-298"><a href="#cb68-298"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> len, maxstrlen=<span class="dv">0</span>, count;</span>
<span id="cb68-299"><a href="#cb68-299"></a></span>
<span id="cb68-300"><a href="#cb68-300"></a>    va_start(ap, format);</span>
<span id="cb68-301"><a href="#cb68-301"></a></span>
<span id="cb68-302"><a href="#cb68-302"></a>    <span class="cf">for</span>(; *format != <span class="ch">'\0'</span>; format++) {</span>
<span id="cb68-303"><a href="#cb68-303"></a>        <span class="cf">switch</span>(*format) {</span>
<span id="cb68-304"><a href="#cb68-304"></a>        <span class="cf">case</span> <span class="ch">'c'</span>: <span class="co">// 8-bit</span></span>
<span id="cb68-305"><a href="#cb68-305"></a>            c = va_arg(ap, <span class="dt">signed</span> <span class="dt">char</span>*);</span>
<span id="cb68-306"><a href="#cb68-306"></a>            <span class="cf">if</span> (*buf &lt;= <span class="bn">0x7f</span>) { *c = *buf;} <span class="co">// re-sign</span></span>
<span id="cb68-307"><a href="#cb68-307"></a>            <span class="cf">else</span> { *c = -<span class="dv">1</span> - (<span class="dt">unsigned</span> <span class="dt">char</span>)(<span class="bn">0xff</span><span class="bu">u</span> - *buf); }</span>
<span id="cb68-308"><a href="#cb68-308"></a>            buf++;</span>
<span id="cb68-309"><a href="#cb68-309"></a>            <span class="cf">break</span>;</span>
<span id="cb68-310"><a href="#cb68-310"></a></span>
<span id="cb68-311"><a href="#cb68-311"></a>        <span class="cf">case</span> <span class="ch">'C'</span>: <span class="co">// 8-bit unsigned</span></span>
<span id="cb68-312"><a href="#cb68-312"></a>            C = va_arg(ap, <span class="dt">unsigned</span> <span class="dt">char</span>*);</span>
<span id="cb68-313"><a href="#cb68-313"></a>            *C = *buf++;</span>
<span id="cb68-314"><a href="#cb68-314"></a>            <span class="cf">break</span>;</span>
<span id="cb68-315"><a href="#cb68-315"></a></span>
<span id="cb68-316"><a href="#cb68-316"></a>        <span class="cf">case</span> <span class="ch">'h'</span>: <span class="co">// 16-bit</span></span>
<span id="cb68-317"><a href="#cb68-317"></a>            h = va_arg(ap, <span class="dt">int</span>*);</span>
<span id="cb68-318"><a href="#cb68-318"></a>            *h = unpacki16(buf);</span>
<span id="cb68-319"><a href="#cb68-319"></a>            buf += <span class="dv">2</span>;</span>
<span id="cb68-320"><a href="#cb68-320"></a>            <span class="cf">break</span>;</span>
<span id="cb68-321"><a href="#cb68-321"></a></span>
<span id="cb68-322"><a href="#cb68-322"></a>        <span class="cf">case</span> <span class="ch">'H'</span>: <span class="co">// 16-bit unsigned</span></span>
<span id="cb68-323"><a href="#cb68-323"></a>            H = va_arg(ap, <span class="dt">unsigned</span> <span class="dt">int</span>*);</span>
<span id="cb68-324"><a href="#cb68-324"></a>            *H = unpacku16(buf);</span>
<span id="cb68-325"><a href="#cb68-325"></a>            buf += <span class="dv">2</span>;</span>
<span id="cb68-326"><a href="#cb68-326"></a>            <span class="cf">break</span>;</span>
<span id="cb68-327"><a href="#cb68-327"></a></span>
<span id="cb68-328"><a href="#cb68-328"></a>        <span class="cf">case</span> <span class="ch">'l'</span>: <span class="co">// 32-bit</span></span>
<span id="cb68-329"><a href="#cb68-329"></a>            l = va_arg(ap, <span class="dt">long</span> <span class="dt">int</span>*);</span>
<span id="cb68-330"><a href="#cb68-330"></a>            *l = unpacki32(buf);</span>
<span id="cb68-331"><a href="#cb68-331"></a>            buf += <span class="dv">4</span>;</span>
<span id="cb68-332"><a href="#cb68-332"></a>            <span class="cf">break</span>;</span>
<span id="cb68-333"><a href="#cb68-333"></a></span>
<span id="cb68-334"><a href="#cb68-334"></a>        <span class="cf">case</span> <span class="ch">'L'</span>: <span class="co">// 32-bit unsigned</span></span>
<span id="cb68-335"><a href="#cb68-335"></a>            L = va_arg(ap, <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>*);</span>
<span id="cb68-336"><a href="#cb68-336"></a>            *L = unpacku32(buf);</span>
<span id="cb68-337"><a href="#cb68-337"></a>            buf += <span class="dv">4</span>;</span>
<span id="cb68-338"><a href="#cb68-338"></a>            <span class="cf">break</span>;</span>
<span id="cb68-339"><a href="#cb68-339"></a></span>
<span id="cb68-340"><a href="#cb68-340"></a>        <span class="cf">case</span> <span class="ch">'q'</span>: <span class="co">// 64-bit</span></span>
<span id="cb68-341"><a href="#cb68-341"></a>            q = va_arg(ap, <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>*);</span>
<span id="cb68-342"><a href="#cb68-342"></a>            *q = unpacki64(buf);</span>
<span id="cb68-343"><a href="#cb68-343"></a>            buf += <span class="dv">8</span>;</span>
<span id="cb68-344"><a href="#cb68-344"></a>            <span class="cf">break</span>;</span>
<span id="cb68-345"><a href="#cb68-345"></a></span>
<span id="cb68-346"><a href="#cb68-346"></a>        <span class="cf">case</span> <span class="ch">'Q'</span>: <span class="co">// 64-bit unsigned</span></span>
<span id="cb68-347"><a href="#cb68-347"></a>            Q = va_arg(ap, <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>*);</span>
<span id="cb68-348"><a href="#cb68-348"></a>            *Q = unpacku64(buf);</span>
<span id="cb68-349"><a href="#cb68-349"></a>            buf += <span class="dv">8</span>;</span>
<span id="cb68-350"><a href="#cb68-350"></a>            <span class="cf">break</span>;</span>
<span id="cb68-351"><a href="#cb68-351"></a></span>
<span id="cb68-352"><a href="#cb68-352"></a>        <span class="cf">case</span> <span class="ch">'f'</span>: <span class="co">// float</span></span>
<span id="cb68-353"><a href="#cb68-353"></a>            f = va_arg(ap, <span class="dt">float</span>*);</span>
<span id="cb68-354"><a href="#cb68-354"></a>            fhold = unpacku16(buf);</span>
<span id="cb68-355"><a href="#cb68-355"></a>            *f = unpack754_16(fhold);</span>
<span id="cb68-356"><a href="#cb68-356"></a>            buf += <span class="dv">2</span>;</span>
<span id="cb68-357"><a href="#cb68-357"></a>            <span class="cf">break</span>;</span>
<span id="cb68-358"><a href="#cb68-358"></a></span>
<span id="cb68-359"><a href="#cb68-359"></a>        <span class="cf">case</span> <span class="ch">'d'</span>: <span class="co">// float-32</span></span>
<span id="cb68-360"><a href="#cb68-360"></a>            d = va_arg(ap, <span class="dt">double</span>*);</span>
<span id="cb68-361"><a href="#cb68-361"></a>            fhold = unpacku32(buf);</span>
<span id="cb68-362"><a href="#cb68-362"></a>            *d = unpack754_32(fhold);</span>
<span id="cb68-363"><a href="#cb68-363"></a>            buf += <span class="dv">4</span>;</span>
<span id="cb68-364"><a href="#cb68-364"></a>            <span class="cf">break</span>;</span>
<span id="cb68-365"><a href="#cb68-365"></a></span>
<span id="cb68-366"><a href="#cb68-366"></a>        <span class="cf">case</span> <span class="ch">'g'</span>: <span class="co">// float-64</span></span>
<span id="cb68-367"><a href="#cb68-367"></a>            g = va_arg(ap, <span class="dt">long</span> <span class="dt">double</span>*);</span>
<span id="cb68-368"><a href="#cb68-368"></a>            fhold = unpacku64(buf);</span>
<span id="cb68-369"><a href="#cb68-369"></a>            *g = unpack754_64(fhold);</span>
<span id="cb68-370"><a href="#cb68-370"></a>            buf += <span class="dv">8</span>;</span>
<span id="cb68-371"><a href="#cb68-371"></a>            <span class="cf">break</span>;</span>
<span id="cb68-372"><a href="#cb68-372"></a></span>
<span id="cb68-373"><a href="#cb68-373"></a>        <span class="cf">case</span> <span class="ch">'s'</span>: <span class="co">// string</span></span>
<span id="cb68-374"><a href="#cb68-374"></a>            s = va_arg(ap, <span class="dt">char</span>*);</span>
<span id="cb68-375"><a href="#cb68-375"></a>            len = unpacku16(buf);</span>
<span id="cb68-376"><a href="#cb68-376"></a>            buf += <span class="dv">2</span>;</span>
<span id="cb68-377"><a href="#cb68-377"></a>            <span class="cf">if</span> (maxstrlen &gt; <span class="dv">0</span> &amp;&amp; len &gt;= maxstrlen) count = maxstrlen - <span class="dv">1</span>;</span>
<span id="cb68-378"><a href="#cb68-378"></a>            <span class="cf">else</span> count = len;</span>
<span id="cb68-379"><a href="#cb68-379"></a>            memcpy(s, buf, count);</span>
<span id="cb68-380"><a href="#cb68-380"></a>            s[count] = <span class="ch">'\0'</span>;</span>
<span id="cb68-381"><a href="#cb68-381"></a>            buf += len;</span>
<span id="cb68-382"><a href="#cb68-382"></a>            <span class="cf">break</span>;</span>
<span id="cb68-383"><a href="#cb68-383"></a></span>
<span id="cb68-384"><a href="#cb68-384"></a>        <span class="cf">default</span>:</span>
<span id="cb68-385"><a href="#cb68-385"></a>            <span class="cf">if</span> (isdigit(*format)) { <span class="co">// track max str len</span></span>
<span id="cb68-386"><a href="#cb68-386"></a>                maxstrlen = maxstrlen * <span class="dv">10</span> + (*format-<span class="ch">'0'</span>);</span>
<span id="cb68-387"><a href="#cb68-387"></a>            }</span>
<span id="cb68-388"><a href="#cb68-388"></a>        }</span>
<span id="cb68-389"><a href="#cb68-389"></a></span>
<span id="cb68-390"><a href="#cb68-390"></a>        <span class="cf">if</span> (!isdigit(*format)) maxstrlen = <span class="dv">0</span>;</span>
<span id="cb68-391"><a href="#cb68-391"></a>    }</span>
<span id="cb68-392"><a href="#cb68-392"></a></span>
<span id="cb68-393"><a href="#cb68-393"></a>    va_end(ap);</span>
<span id="cb68-394"><a href="#cb68-394"></a>}</span></code></pre></div>
<p>And <a href="https://beej.us/guide/bgnet/examples/pack2.c">here is a demonstration program</a><a href="#fn40" class="footnote-ref" id="fnref40" role="doc-noteref"><sup>40</sup></a> of the above code that packs some data into <code>buf</code> and then unpacks it into variables. Note that when calling <code>unpack()</code> with a string argument (format specifier “<code>s</code>”), it’s wise to put a maximum length count in front of it to prevent a buffer overrun, e.g.&nbsp;“<code>96s</code>”.
 Be wary when unpacking data you get over the network—a malicious user 
might send badly-constructed packets in an effort to attack your system!</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb69-1"><a href="#cb69-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb69-2"><a href="#cb69-2"></a></span>
<span id="cb69-3"><a href="#cb69-3"></a><span class="co">// various bits for floating point types--</span></span>
<span id="cb69-4"><a href="#cb69-4"></a><span class="co">// varies for different architectures</span></span>
<span id="cb69-5"><a href="#cb69-5"></a><span class="kw">typedef</span> <span class="dt">float</span> float32_t;</span>
<span id="cb69-6"><a href="#cb69-6"></a><span class="kw">typedef</span> <span class="dt">double</span> float64_t;</span>
<span id="cb69-7"><a href="#cb69-7"></a></span>
<span id="cb69-8"><a href="#cb69-8"></a><span class="dt">int</span> main(<span class="dt">void</span>)</span>
<span id="cb69-9"><a href="#cb69-9"></a>{</span>
<span id="cb69-10"><a href="#cb69-10"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> buf[<span class="dv">1024</span>];</span>
<span id="cb69-11"><a href="#cb69-11"></a>    <span class="dt">int8_t</span> magic;</span>
<span id="cb69-12"><a href="#cb69-12"></a>    <span class="dt">int16_t</span> monkeycount;</span>
<span id="cb69-13"><a href="#cb69-13"></a>    <span class="dt">int32_t</span> altitude;</span>
<span id="cb69-14"><a href="#cb69-14"></a>    float32_t absurdityfactor;</span>
<span id="cb69-15"><a href="#cb69-15"></a>    <span class="dt">char</span> *s = <span class="st">"Great unmitigated Zot! You've found the Runestaff!"</span>;</span>
<span id="cb69-16"><a href="#cb69-16"></a>    <span class="dt">char</span> s2[<span class="dv">96</span>];</span>
<span id="cb69-17"><a href="#cb69-17"></a>    <span class="dt">int16_t</span> packetsize, ps2;</span>
<span id="cb69-18"><a href="#cb69-18"></a></span>
<span id="cb69-19"><a href="#cb69-19"></a>    packetsize = pack(buf, <span class="st">"chhlsf"</span>, (<span class="dt">int8_t</span>)<span class="ch">'B'</span>, (<span class="dt">int16_t</span>)<span class="dv">0</span>, (<span class="dt">int16_t</span>)<span class="dv">37</span>, </span>
<span id="cb69-20"><a href="#cb69-20"></a>            (<span class="dt">int32_t</span>)-<span class="dv">5</span>, s, (float32_t)-<span class="fl">3490.6677</span>);</span>
<span id="cb69-21"><a href="#cb69-21"></a>    packi16(buf+<span class="dv">1</span>, packetsize); <span class="co">// store packet size in packet for kicks</span></span>
<span id="cb69-22"><a href="#cb69-22"></a></span>
<span id="cb69-23"><a href="#cb69-23"></a>    printf(<span class="st">"packet is %"</span> PRId32 <span class="st">" bytes</span><span class="sc">\n</span><span class="st">"</span>, packetsize);</span>
<span id="cb69-24"><a href="#cb69-24"></a></span>
<span id="cb69-25"><a href="#cb69-25"></a>    unpack(buf, <span class="st">"chhl96sf"</span>, &amp;magic, &amp;ps2, &amp;monkeycount, &amp;altitude, s2,</span>
<span id="cb69-26"><a href="#cb69-26"></a>        &amp;absurdityfactor);</span>
<span id="cb69-27"><a href="#cb69-27"></a></span>
<span id="cb69-28"><a href="#cb69-28"></a>    printf(<span class="st">"'%c' %"</span> PRId32<span class="st">" %"</span> PRId16 <span class="st">" %"</span> PRId32</span>
<span id="cb69-29"><a href="#cb69-29"></a>            <span class="st">" </span><span class="sc">\"</span><span class="st">%s</span><span class="sc">\"</span><span class="st"> %f</span><span class="sc">\n</span><span class="st">"</span>, magic, ps2, monkeycount,</span>
<span id="cb69-30"><a href="#cb69-30"></a>            altitude, s2, absurdityfactor);</span>
<span id="cb69-31"><a href="#cb69-31"></a></span>
<span id="cb69-32"><a href="#cb69-32"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb69-33"><a href="#cb69-33"></a>}</span></code></pre></div>
<p>Whether you roll your own code or use someone else’s, it’s a good 
idea to have a general set of data packing routines for the sake of 
keeping bugs in check, rather than packing each bit by hand each time.</p>
<p>When packing the data, what’s a good format to use? Excellent question. Fortunately,  <a href="https://tools.ietf.org/html/rfc4506">RFC 4506</a><a href="#fn41" class="footnote-ref" id="fnref41" role="doc-noteref"><sup>41</sup></a>,
 the External Data Representation Standard, already defines binary 
formats for a bunch of different types, like floating point types, 
integer types, arrays, raw data, etc. I suggest conforming to that if 
you’re going to roll the data yourself. But you’re not obligated to. The
 Packet Police are not right outside your door. At least, I don’t <em>think</em> they are.</p>
<p>In any case, encoding the data somehow or another before you send it is the right way of doing things!</p>
<h2 data-number="7.6" id="sonofdataencap"><span class="header-section-number">7.6</span> Son of Data Encapsulation</h2>
<p>What does it really mean to encapsulate data, anyway? In the simplest
 case, it means you’ll stick a header on there with either some 
identifying information or a packet length, or both.</p>
<p>What should your header look like? Well, it’s just some binary data 
that represents whatever you feel is necessary to complete your project.</p>
<p>Wow. That’s vague.</p>
<p>Okay. For instance, let’s say you have a multi-user chat program that uses <code>SOCK_STREAM</code>s.
 When a user types (“says”) something, two pieces of information need to
 be transmitted to the server: what was said and who said it.</p>
<p>So far so good? “What’s the problem?” you’re asking.</p>
<p>The problem is that the messages can be of varying lengths. One 
person named “tom” might say, “Hi”, and another person named “Benjamin” 
might say, “Hey guys what is up?”</p>
<p>So you <code>send()</code> all this stuff to the clients as it comes in. Your outgoing data stream looks like this:</p>
<pre><code>    t o m H i B e n j a m i n H e y g u y s w h a t i s u p ?</code></pre>
<p>And so on. How does the client know when one message starts and 
another stops? You could, if you wanted, make all messages the same 
length and just call the  <code>sendall()</code> we implemented, <a href="#sendall">above</a>. But that wastes bandwidth! We don’t want to <code>send()</code> 1024 bytes just so “tom” can say “Hi”.</p>
<p>So we <em>encapsulate</em> the data in a tiny header and packet 
structure. Both the client and server know how to pack and unpack 
(sometimes referred to as “marshal” and “unmarshal”) this data. Don’t 
look now, but we’re starting to define a <em>protocol</em> that describes how a client and server communicate!</p>
<p>In this case, let’s assume the user name is a fixed length of 8 characters, padded with <code>'\0'</code>.
 And then let’s assume the data is variable length, up to a maximum of 
128 characters. Let’s have a look a sample packet structure that we 
might use in this situation:</p>
<ol type="1">
<li><p><code>len</code> (1 byte, unsigned)—The total length of the packet, counting the 8-byte user name and chat data.</p></li>
<li><p><code>name</code> (8 bytes)—The user’s name, NUL-padded if necessary.</p></li>
<li><p><code>chatdata</code> (<em>n</em>-bytes)—The data itself, no more
 than 128 bytes. The length of the packet should be calculated as the 
length of this data plus 8 (the length of the name field, above).</p></li>
</ol>
<p>Why did I choose the 8-byte and 128-byte limits for the fields? I 
pulled them out of the air, assuming they’d be long enough. Maybe, 
though, 8 bytes is too restrictive for your needs, and you can have a 
30-byte name field, or whatever. The choice is up to you.</p>
<p>Using the above packet definition, the first packet would consist of the following information (in hex and ASCII):</p>
<pre><code>       0A     74 6F 6D 00 00 00 00 00      48 69
    (length)  T  o  m    (padding)         H  i</code></pre>
<p>And the second is similar:</p>
<pre><code>       18     42 65 6E 6A 61 6D 69 6E      48 65 79 20 67 75 79 73 20 77 ...
    (length)  B  e  n  j  a  m  i  n       H  e  y     g  u  y  s     w  ...</code></pre>
<p>(The length is stored in Network Byte Order, of course. In this case,
 it’s only one byte so it doesn’t matter, but generally speaking you’ll 
want all your binary integers to be stored in Network Byte Order in your
 packets.)</p>
<p>When you’re sending this data, you should be safe and use a command similar to <a href="#sendall"><code>sendall()</code></a>, above, so you know all the data is sent, even if it takes multiple calls to <code>send()</code> to get it all out.</p>
<p>Likewise, when you’re receiving this data, you need to do a bit of 
extra work. To be safe, you should assume that you might receive a 
partial packet (like maybe we receive “<code>18 42 65 6E 6A</code>” from Benjamin, above, but that’s all we get in this call to <code>recv()</code>). We need to call <code>recv()</code> over and over again until the packet is completely received.</p>
<p>But how? Well, we know the number of bytes we need to receive in 
total for the packet to be complete, since that number is tacked on the 
front of the packet. We also know the maximum packet size is 1+8+128, or
 137 bytes (because that’s how we defined the packet).</p>
<p>There are actually a couple things you can do here. Since you know every packet starts off with a length, you can call <code>recv()</code>
 just to get the packet length. Then once you have that, you can call it
 again specifying exactly the remaining length of the packet (possibly 
repeatedly to get all the data) until you have the complete packet. The 
advantage of this method is that you only need a buffer large enough for
 one packet, while the disadvantage is that you need to call <code>recv()</code> at least twice to get all the data.</p>
<p>Another option is just to call <code>recv()</code> and say the amount
 you’re willing to receive is the maximum number of bytes in a packet. 
Then whatever you get, stick it onto the back of a buffer, and finally 
check to see if the packet is complete. Of course, you might get some of
 the next packet, so you’ll need to have room for that.</p>
<p>What you can do is declare an array big enough for two packets. This 
is your work array where you will reconstruct packets as they arrive.</p>
<p>Every time you <code>recv()</code> data, you’ll append it into the 
work buffer and check to see if the packet is complete. That is, the 
number of bytes in the buffer is greater than or equal to the length 
specified in the header (+1, because the length in the header doesn’t 
include the byte for the length itself). If the number of bytes in the 
buffer is less than 1, the packet is not complete, obviously. You have 
to make a special case for this, though, since the first byte is garbage
 and you can’t rely on it for the correct packet length.</p>
<p>Once the packet is complete, you can do with it what you will. Use it, and remove it from your work buffer.</p>
<p>Whew! Are you juggling that in your head yet? Well, here’s the second
 of the one-two punch: you might have read past the end of one packet 
and onto the next in a single <code>recv()</code> call. That is, you 
have a work buffer with one complete packet, and an incomplete part of 
the next packet! Bloody heck. (But this is why you made your work buffer
 large enough to hold <em>two</em> packets—in case this happened!)</p>
<p>Since you know the length of the first packet from the header, and 
you’ve been keeping track of the number of bytes in the work buffer, you
 can subtract and calculate how many of the bytes in the work buffer 
belong to the second (incomplete) packet. When you’ve handled the first 
one, you can clear it out of the work buffer and move the partial second
 packet down the to front of the buffer so it’s all ready to go for the 
next <code>recv()</code>.</p>
<p>(Some of you readers will note that actually moving the partial 
second packet to the beginning of the work buffer takes time, and the 
program can be coded to not require this by using a circular buffer. 
Unfortunately for the rest of you, a discussion on circular buffers is 
beyond the scope of this article. If you’re still curious, grab a data 
structures book and go from there.)</p>
<p>I never said it was easy. Ok, I did say it was easy. And it is; you 
just need practice and pretty soon it’ll come to you naturally. By  
Excalibur I swear it!</p>
<h2 data-number="7.7" id="broadcast-packetshello-world"><span class="header-section-number">7.7</span> Broadcast Packets—Hello, World!</h2>
<p>So far, this guide has talked about sending data from one host to one
 other host. But it is possible, I insist, that you can, with the proper
 authority, send data to multiple hosts <em>at the same time</em>!</p>
<p>With  UDP (only UDP, not TCP) and standard IPv4, this is done through a mechanism called  <em>broadcasting</em>. With IPv6, broadcasting isn’t supported, and you have to resort to the often superior technique of <em>multicasting</em>, which, sadly I won’t be discussing at this time. But enough of the starry-eyed future—we’re stuck in the 32-bit present.</p>
<p>But wait! You can’t just run off and start broadcasting willy-nilly; You have to  set the socket option  <code>SO_BROADCAST</code>
 before you can send a broadcast packet out on the network. It’s like a 
one of those little plastic covers they put over the missile launch 
switch! That’s just how much power you hold in your hands!</p>
<p>But seriously, though, there is a danger to using broadcast packets, 
and that is: every system that receives a broadcast packet must undo all
 the onion-skin layers of data encapsulation until it finds out what 
port the data is destined to. And then it hands the data over or 
discards it. In either case, it’s a lot of work for each machine that 
receives the broadcast packet, and since it is all of them on the local 
network, that could be a lot of machines doing a lot of unnecessary 
work. When the game Doom first came out, this was a complaint about its 
network code.</p>
<p>Now, there is more than one way to skin a cat… wait a minute. Is 
there really more than one way to skin a cat? What kind of expression is
 that? Uh, and likewise, there is more than one way to send a broadcast 
packet. So, to get to the meat and potatoes of the whole thing: how do 
you specify the destination address for a broadcast message? There are 
two common ways:</p>
<ol type="1">
<li><p>Send the data to a specific subnet’s broadcast address. This is 
the subnet’s network number with all one-bits set for the host portion 
of the address. For instance, at home my network is <code>192.168.1.0</code>, my netmask is <code>255.255.255.0</code>,
 so the last byte of the address is my host number (because the first 
three bytes, according to the netmask, are the network number). So my 
broadcast address is <code>192.168.1.255</code>. Under Unix, the <code>ifconfig</code> command will actually give you all this data. (If you’re curious, the bitwise logic to get your broadcast address is <code>network_number</code> OR (NOT <code>netmask</code>).)
 You can send this type of broadcast packet to remote networks as well 
as your local network, but you run the risk of the packet being dropped 
by the destination’s router. (If they didn’t drop it, then some random 
smurf could start flooding their LAN with broadcast traffic.)</p></li>
<li><p>Send the data to the “global” broadcast address. This is  <code>255.255.255.255</code>, aka  <code>INADDR_BROADCAST</code>.
 Many machines will automatically bitwise AND this with your network 
number to convert it to a network broadcast address, but some won’t. It 
varies. Routers do not forward this type of broadcast packet off your 
local network, ironically enough.</p></li>
</ol>
<p>So what happens if you try to send data on the broadcast address without first setting the <code>SO_BROADCAST</code> socket option? Well, let’s fire up good old <a href="#datagram"><code>talker</code> and <code>listener</code></a> and see what happens.</p>
<pre><code>    $ talker 192.168.1.2 foo
    sent 3 bytes to 192.168.1.2
    $ talker 192.168.1.255 foo
    sendto: Permission denied
    $ talker 255.255.255.255 foo
    sendto: Permission denied</code></pre>
<p>Yes, it’s not happy at all…because we didn’t set the <code>SO_BROADCAST</code> socket option. Do that, and now you can <code>sendto()</code> anywhere you want!</p>
<p>In fact, that’s the <em>only difference</em> between a UDP application that can broadcast and one that can’t. So let’s take the old <code>talker</code> application and add one section that sets the <code>SO_BROADCAST</code> socket option. We’ll call this program <a href="https://beej.us/guide/bgnet/examples/broadcaster.c"><code>broadcaster.c</code></a><a href="#fn42" class="footnote-ref" id="fnref42" role="doc-noteref"><sup>42</sup></a>:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb74-1"><a href="#cb74-1"></a><span class="co">/*</span></span>
<span id="cb74-2"><a href="#cb74-2"></a><span class="co">** broadcaster.c -- a datagram "client" like talker.c, except</span></span>
<span id="cb74-3"><a href="#cb74-3"></a><span class="co">**                  this one can broadcast</span></span>
<span id="cb74-4"><a href="#cb74-4"></a><span class="co">*/</span></span>
<span id="cb74-5"><a href="#cb74-5"></a></span>
<span id="cb74-6"><a href="#cb74-6"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb74-7"><a href="#cb74-7"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb74-8"><a href="#cb74-8"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb74-9"><a href="#cb74-9"></a><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></span>
<span id="cb74-10"><a href="#cb74-10"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb74-11"><a href="#cb74-11"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb74-12"><a href="#cb74-12"></a><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb74-13"><a href="#cb74-13"></a><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></span>
<span id="cb74-14"><a href="#cb74-14"></a><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></span>
<span id="cb74-15"><a href="#cb74-15"></a><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></span>
<span id="cb74-16"><a href="#cb74-16"></a></span>
<span id="cb74-17"><a href="#cb74-17"></a><span class="pp">#define SERVERPORT 4950 </span><span class="co">// the port users will be connecting to</span></span>
<span id="cb74-18"><a href="#cb74-18"></a></span>
<span id="cb74-19"><a href="#cb74-19"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</span>
<span id="cb74-20"><a href="#cb74-20"></a>{</span>
<span id="cb74-21"><a href="#cb74-21"></a>    <span class="dt">int</span> sockfd;</span>
<span id="cb74-22"><a href="#cb74-22"></a>    <span class="kw">struct</span> sockaddr_in their_addr; <span class="co">// connector's address information</span></span>
<span id="cb74-23"><a href="#cb74-23"></a>    <span class="kw">struct</span> hostent *he;</span>
<span id="cb74-24"><a href="#cb74-24"></a>    <span class="dt">int</span> numbytes;</span>
<span id="cb74-25"><a href="#cb74-25"></a>    <span class="dt">int</span> broadcast = <span class="dv">1</span>;</span>
<span id="cb74-26"><a href="#cb74-26"></a>    <span class="co">//char broadcast = '1'; // if that doesn't work, try this</span></span>
<span id="cb74-27"><a href="#cb74-27"></a></span>
<span id="cb74-28"><a href="#cb74-28"></a>    <span class="cf">if</span> (argc != <span class="dv">3</span>) {</span>
<span id="cb74-29"><a href="#cb74-29"></a>        fprintf(stderr,<span class="st">"usage: broadcaster hostname message</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb74-30"><a href="#cb74-30"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb74-31"><a href="#cb74-31"></a>    }</span>
<span id="cb74-32"><a href="#cb74-32"></a></span>
<span id="cb74-33"><a href="#cb74-33"></a>    <span class="cf">if</span> ((he=gethostbyname(argv[<span class="dv">1</span>])) == NULL) {  <span class="co">// get the host info</span></span>
<span id="cb74-34"><a href="#cb74-34"></a>        perror(<span class="st">"gethostbyname"</span>);</span>
<span id="cb74-35"><a href="#cb74-35"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb74-36"><a href="#cb74-36"></a>    }</span>
<span id="cb74-37"><a href="#cb74-37"></a></span>
<span id="cb74-38"><a href="#cb74-38"></a>    <span class="cf">if</span> ((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="dv">0</span>)) == -<span class="dv">1</span>) {</span>
<span id="cb74-39"><a href="#cb74-39"></a>        perror(<span class="st">"socket"</span>);</span>
<span id="cb74-40"><a href="#cb74-40"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb74-41"><a href="#cb74-41"></a>    }</span>
<span id="cb74-42"><a href="#cb74-42"></a></span>
<span id="cb74-43"><a href="#cb74-43"></a>    <span class="co">// this call is what allows broadcast packets to be sent:</span></span>
<span id="cb74-44"><a href="#cb74-44"></a>    <span class="cf">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;broadcast,</span>
<span id="cb74-45"><a href="#cb74-45"></a>        <span class="kw">sizeof</span> broadcast) == -<span class="dv">1</span>) {</span>
<span id="cb74-46"><a href="#cb74-46"></a>        perror(<span class="st">"setsockopt (SO_BROADCAST)"</span>);</span>
<span id="cb74-47"><a href="#cb74-47"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb74-48"><a href="#cb74-48"></a>    }</span>
<span id="cb74-49"><a href="#cb74-49"></a></span>
<span id="cb74-50"><a href="#cb74-50"></a>    their_addr.sin_family = AF_INET;     <span class="co">// host byte order</span></span>
<span id="cb74-51"><a href="#cb74-51"></a>    their_addr.sin_port = htons(SERVERPORT); <span class="co">// short, network byte order</span></span>
<span id="cb74-52"><a href="#cb74-52"></a>    their_addr.sin_addr = *((<span class="kw">struct</span> in_addr *)he-&gt;h_addr);</span>
<span id="cb74-53"><a href="#cb74-53"></a>    memset(their_addr.sin_zero, <span class="ch">'\0'</span>, <span class="kw">sizeof</span> their_addr.sin_zero);</span>
<span id="cb74-54"><a href="#cb74-54"></a></span>
<span id="cb74-55"><a href="#cb74-55"></a>    <span class="cf">if</span> ((numbytes=sendto(sockfd, argv[<span class="dv">2</span>], strlen(argv[<span class="dv">2</span>]), <span class="dv">0</span>,</span>
<span id="cb74-56"><a href="#cb74-56"></a>             (<span class="kw">struct</span> sockaddr *)&amp;their_addr, <span class="kw">sizeof</span> their_addr)) == -<span class="dv">1</span>) {</span>
<span id="cb74-57"><a href="#cb74-57"></a>        perror(<span class="st">"sendto"</span>);</span>
<span id="cb74-58"><a href="#cb74-58"></a>        exit(<span class="dv">1</span>);</span>
<span id="cb74-59"><a href="#cb74-59"></a>    }</span>
<span id="cb74-60"><a href="#cb74-60"></a></span>
<span id="cb74-61"><a href="#cb74-61"></a>    printf(<span class="st">"sent %d bytes to %s</span><span class="sc">\n</span><span class="st">"</span>, numbytes,</span>
<span id="cb74-62"><a href="#cb74-62"></a>        inet_ntoa(their_addr.sin_addr));</span>
<span id="cb74-63"><a href="#cb74-63"></a></span>
<span id="cb74-64"><a href="#cb74-64"></a>    close(sockfd);</span>
<span id="cb74-65"><a href="#cb74-65"></a></span>
<span id="cb74-66"><a href="#cb74-66"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb74-67"><a href="#cb74-67"></a>}</span></code></pre></div>
<p>What’s different between this and a “normal” UDP client/server 
situation? Nothing! (With the exception of the client being allowed to 
send broadcast packets in this case.) As such, go ahead and run the old 
UDP <a href="#datagram"><code>listener</code></a> program in one window, and <code>broadcaster</code> in another. You should be now be able to do all those sends that failed, above.</p>
<pre><code>    $ broadcaster 192.168.1.2 foo
    sent 3 bytes to 192.168.1.2
    $ broadcaster 192.168.1.255 foo
    sent 3 bytes to 192.168.1.255
    $ broadcaster 255.255.255.255 foo
    sent 3 bytes to 255.255.255.255</code></pre>
<p>And you should see <code>listener</code> responding that it got the packets. (If <code>listener</code> doesn’t respond, it could be because it’s bound to an IPv6 address. Try changing the <code>AF_UNSPEC</code> in <code>listener.c</code> to <code>AF_INET</code> to force IPv4.)</p>
<p>Well, that’s kind of exciting. But now fire up <code>listener</code> on another machine next to you on the same network so that you have two copies going, one on each machine, and run <code>broadcaster</code> again with your broadcast address… Hey! Both <code>listener</code>s get the packet even though you only called <code>sendto()</code> once! Cool!</p>
<p>If the <code>listener</code> gets data you send directly to it, but 
not data on the broadcast address, it could be that you have a  firewall
 on your local machine that is blocking the packets. (Yes,  Pat and  
Bapper, thank you for realizing before I did that this is why my sample 
code wasn’t working. I told you I’d mention you in the guide, and here 
you are. So <em>nyah</em>.)</p>
<p>Again, be careful with broadcast packets. Since every machine on the LAN will be forced to deal with the packet whether it <code>recvfrom()</code>s
 it or not, it can present quite a load to the entire computing network.
 They are definitely to be used sparingly and appropriately.</p>
<h1 data-number="8" id="common-questions"><span class="header-section-number">8</span> Common Questions</h1>
<p><strong>Where can I get those header files?</strong></p>
<p> If you don’t have them on your system already, you probably don’t 
need them. Check the manual for your particular platform. If you’re 
building for  Windows, you only need to <code>#include &lt;winsock.h&gt;</code>.</p>
<p><strong>What do I do when <code>bind()</code> reports  “Address already in use”?</strong></p>
<p>You have to use  <code>setsockopt()</code> with the  <code>SO_REUSEADDR</code> option on the listening socket. Check out the  <a href="#bind">section on <code>bind()</code></a> and the  <a href="#select">section on <code>select()</code></a> for an example.</p>
<p><strong>How do I get a list of open sockets on the system?</strong></p>
<p>Use the  <code>netstat</code>. Check the <code>man</code> page for full details, but you should get some good output just typing:</p>
<pre><code>    $ netstat</code></pre>
<p>The only trick is determining which socket is associated with which program. <code>:-)</code></p>
<p><strong>How can I view the routing table?</strong></p>
<p>Run the  <code>route</code> command (in <code>/sbin</code> on most Linuxes) or the command  <code>netstat -r</code>.</p>
<p><strong>How can I run the client and server programs if I only have one computer? Don’t I need a network to write network programs?</strong></p>
<p>Fortunately for you, virtually all machines implement a  loopback 
network “device” that sits in the kernel and pretends to be a network 
card. (This is the interface listed as “<code>lo</code>” in the routing table.)</p>
<p>Pretend you’re logged into a machine named  “<code>goat</code>”. Run the client in one window and the server in another. Or start the server in the background (“<code>server &amp;</code>”) and run the client in the same window. The upshot of the loopback device is that you can either <code>client goat</code> or  <code>client localhost</code> (since “<code>localhost</code>” is likely defined in your <code>/etc/hosts</code> file) and you’ll have the client talking to the server without a network!</p>
<p>In short, no changes are necessary to any of the code to make it run on a single non-networked machine! Huzzah!</p>
<p><strong>How can I tell if the remote side has closed connection?</strong></p>
<p>You can tell because <code>recv()</code> will return <code>0</code>.</p>
<p><strong>How do I implement a  “ping” utility? What is  ICMP? Where can I find out more about  raw sockets and <code>SOCK_RAW</code>?</strong></p>
<p>All your raw sockets questions will be answered in <a href="#books">W. Richard Stevens’ UNIX Network Programming books</a>. Also, look in the <code>ping/</code> subdirectory in Stevens’ UNIX Network Programming source code, <a href="http://www.unpbook.com/src.html">available online</a><a href="#fn43" class="footnote-ref" id="fnref43" role="doc-noteref"><sup>43</sup></a>.</p>
<p><strong>How do I change or shorten the timeout on a call to <code>connect()</code>?</strong></p>
<p>Instead of giving you exactly the same answer that W. Richard Stevens would give you, I’ll just refer you to <a href="http://www.unpbook.com/src.html"><code>lib/connect_nonb.c</code> in the UNIX Network Programming source code</a><a href="#fn44" class="footnote-ref" id="fnref44" role="doc-noteref"><sup>44</sup></a>.</p>
<p>The gist of it is that you make a socket descriptor with <code>socket()</code>, <a href="#blocking">set it to non-blocking</a>, call <code>connect()</code>, and if all goes well <code>connect()</code> will return <code>-1</code> immediately and <code>errno</code> will be set to <code>EINPROGRESS</code>. Then you call <a href="#select"><code>select()</code></a>
 with whatever timeout you want, passing the socket descriptor in both 
the read and write sets. If it doesn’t timeout, it means the <code>connect()</code> call completed. At this point, you’ll have to use <code>getsockopt()</code> with the <code>SO_ERROR</code> option to get the return value from the <code>connect()</code> call, which should be zero if there was no error.</p>
<p>Finally, you’ll probably want to set the socket back to be blocking again before you start transferring data over it.</p>
<p>Notice that this has the added benefit of allowing your program to do
 something else while it’s connecting, too. You could, for example, set 
the timeout to something low, like 500 ms, and update an indicator 
onscreen each timeout, then call <code>select()</code> again. When you’ve called <code>select()</code> and timed-out, say, 20 times, you’ll know it’s time to give up on the connection.</p>
<p>Like I said, check out Stevens’ source for a perfectly excellent example.</p>
<p><strong>How do I build for Windows?</strong></p>
<p>First, delete Windows and install Linux or BSD. <code>};-)</code>. No, actually, just see the <a href="#windows">section on building for Windows</a> in the introduction.</p>
<p><strong>How do I build for Solaris/SunOS? I keep getting linker errors when I try to compile!</strong></p>
<p>The linker errors happen because Sun boxes don’t automatically compile in the socket libraries. See the <a href="#solaris">section on building for Solaris/SunOS</a> in the introduction for an example of how to do this.</p>
<p><strong>Why does <code>select()</code> keep falling out on a signal?</strong></p>
<p>Signals tend to cause blocked system calls to return <code>-1</code> with <code>errno</code> set to <code>EINTR</code>. When you set up a signal handler with  <code>sigaction()</code>, you can set the flag  <code>SA_RESTART</code>, which is supposed to restart the system call after it was interrupted.</p>
<p>Naturally, this doesn’t always work.</p>
<p>My favorite solution to this involves a  <code>goto</code> statement. You know this irritates your professors to no end, so go for it!</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb77-1"><a href="#cb77-1"></a>select_restart:</span>
<span id="cb77-2"><a href="#cb77-2"></a><span class="cf">if</span> ((err = select(fdmax+<span class="dv">1</span>, &amp;readfds, NULL, NULL, NULL)) == -<span class="dv">1</span>) {</span>
<span id="cb77-3"><a href="#cb77-3"></a>    <span class="cf">if</span> (errno == EINTR) {</span>
<span id="cb77-4"><a href="#cb77-4"></a>        <span class="co">// some signal just interrupted us, so restart</span></span>
<span id="cb77-5"><a href="#cb77-5"></a>        <span class="cf">goto</span> select_restart;</span>
<span id="cb77-6"><a href="#cb77-6"></a>    }</span>
<span id="cb77-7"><a href="#cb77-7"></a>    <span class="co">// handle the real error here:</span></span>
<span id="cb77-8"><a href="#cb77-8"></a>    perror(<span class="st">"select"</span>);</span>
<span id="cb77-9"><a href="#cb77-9"></a>} </span></code></pre></div>
<p>Sure, you don’t <em>need</em> to use <code>goto</code> in this case; you can use other structures to control it. But I think the <code>goto</code> statement is actually cleaner.</p>
<p><strong>How can I implement a timeout on a call to <code>recv()</code>?</strong></p>
<p> Use  <a href="#select"><code>select()</code></a>! It allows you to 
specify a timeout parameter for socket descriptors that you’re looking 
to read from. Or, you could wrap the entire functionality in a single 
function, like this:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb78-1"><a href="#cb78-1"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb78-2"><a href="#cb78-2"></a><span class="pp">#include </span><span class="im">&lt;sys/time.h&gt;</span></span>
<span id="cb78-3"><a href="#cb78-3"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb78-4"><a href="#cb78-4"></a><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb78-5"><a href="#cb78-5"></a></span>
<span id="cb78-6"><a href="#cb78-6"></a><span class="dt">int</span> recvtimeout(<span class="dt">int</span> s, <span class="dt">char</span> *buf, <span class="dt">int</span> len, <span class="dt">int</span> timeout)</span>
<span id="cb78-7"><a href="#cb78-7"></a>{</span>
<span id="cb78-8"><a href="#cb78-8"></a>    fd_set fds;</span>
<span id="cb78-9"><a href="#cb78-9"></a>    <span class="dt">int</span> n;</span>
<span id="cb78-10"><a href="#cb78-10"></a>    <span class="kw">struct</span> timeval tv;</span>
<span id="cb78-11"><a href="#cb78-11"></a></span>
<span id="cb78-12"><a href="#cb78-12"></a>    <span class="co">// set up the file descriptor set</span></span>
<span id="cb78-13"><a href="#cb78-13"></a>    FD_ZERO(&amp;fds);</span>
<span id="cb78-14"><a href="#cb78-14"></a>    FD_SET(s, &amp;fds);</span>
<span id="cb78-15"><a href="#cb78-15"></a></span>
<span id="cb78-16"><a href="#cb78-16"></a>    <span class="co">// set up the struct timeval for the timeout</span></span>
<span id="cb78-17"><a href="#cb78-17"></a>    tv.tv_sec = timeout;</span>
<span id="cb78-18"><a href="#cb78-18"></a>    tv.tv_usec = <span class="dv">0</span>;</span>
<span id="cb78-19"><a href="#cb78-19"></a></span>
<span id="cb78-20"><a href="#cb78-20"></a>    <span class="co">// wait until timeout or data received</span></span>
<span id="cb78-21"><a href="#cb78-21"></a>    n = select(s+<span class="dv">1</span>, &amp;fds, NULL, NULL, &amp;tv);</span>
<span id="cb78-22"><a href="#cb78-22"></a>    <span class="cf">if</span> (n == <span class="dv">0</span>) <span class="cf">return</span> -<span class="dv">2</span>; <span class="co">// timeout!</span></span>
<span id="cb78-23"><a href="#cb78-23"></a>    <span class="cf">if</span> (n == -<span class="dv">1</span>) <span class="cf">return</span> -<span class="dv">1</span>; <span class="co">// error</span></span>
<span id="cb78-24"><a href="#cb78-24"></a></span>
<span id="cb78-25"><a href="#cb78-25"></a>    <span class="co">// data must be here, so do a normal recv()</span></span>
<span id="cb78-26"><a href="#cb78-26"></a>    <span class="cf">return</span> recv(s, buf, len, <span class="dv">0</span>);</span>
<span id="cb78-27"><a href="#cb78-27"></a>}</span>
<span id="cb78-28"><a href="#cb78-28"></a>.</span>
<span id="cb78-29"><a href="#cb78-29"></a>.</span>
<span id="cb78-30"><a href="#cb78-30"></a>.</span>
<span id="cb78-31"><a href="#cb78-31"></a><span class="co">// Sample call to recvtimeout():</span></span>
<span id="cb78-32"><a href="#cb78-32"></a>n = recvtimeout(s, buf, <span class="kw">sizeof</span> buf, <span class="dv">10</span>); <span class="co">// 10 second timeout</span></span>
<span id="cb78-33"><a href="#cb78-33"></a></span>
<span id="cb78-34"><a href="#cb78-34"></a><span class="cf">if</span> (n == -<span class="dv">1</span>) {</span>
<span id="cb78-35"><a href="#cb78-35"></a>    <span class="co">// error occurred</span></span>
<span id="cb78-36"><a href="#cb78-36"></a>    perror(<span class="st">"recvtimeout"</span>);</span>
<span id="cb78-37"><a href="#cb78-37"></a>}</span>
<span id="cb78-38"><a href="#cb78-38"></a><span class="cf">else</span> <span class="cf">if</span> (n == -<span class="dv">2</span>) {</span>
<span id="cb78-39"><a href="#cb78-39"></a>    <span class="co">// timeout occurred</span></span>
<span id="cb78-40"><a href="#cb78-40"></a>} <span class="cf">else</span> {</span>
<span id="cb78-41"><a href="#cb78-41"></a>    <span class="co">// got some data in buf</span></span>
<span id="cb78-42"><a href="#cb78-42"></a>}</span>
<span id="cb78-43"><a href="#cb78-43"></a>.</span>
<span id="cb78-44"><a href="#cb78-44"></a>.</span>
<span id="cb78-45"><a href="#cb78-45"></a>. </span></code></pre></div>
<p>Notice that  <code>recvtimeout()</code> returns <code>-2</code> in case of a timeout. Why not return <code>0</code>? Well, if you recall, a return value of <code>0</code> on a call to <code>recv()</code> means that the remote side closed the connection. So that return value is already spoken for, and <code>-1</code> means “error”, so I chose <code>-2</code> as my timeout indicator.</p>
<p><strong>How do I  encrypt or compress the data before sending it through the socket?</strong></p>
<p>One easy way to do encryption is to use  SSL (secure sockets layer), but that’s beyond the scope of this guide.  (Check out the <a href="https://www.openssl.org/">OpenSSL project</a><a href="#fn45" class="footnote-ref" id="fnref45" role="doc-noteref"><sup>45</sup></a> for more info.)</p>
<p>But assuming you want to plug in or implement your own  compressor or
 encryption system, it’s just a matter of thinking of your data as 
running through a sequence of steps between both ends. Each step changes
 the data in some way.</p>
<ol type="1">
<li>server reads data from file (or wherever)</li>
<li>server encrypts/compresses data (you add this part)</li>
<li>server <code>send()</code>s encrypted data</li>
</ol>
<p>Now the other way around:</p>
<ol type="1">
<li>client <code>recv()</code>s encrypted data</li>
<li>client decrypts/decompresses data (you add this part)</li>
<li>client writes data to file (or wherever)</li>
</ol>
<p>If you’re going to compress and encrypt, just remember to compress first. <code>:-)</code></p>
<p>Just as long as the client properly undoes what the server does, the 
data will be fine in the end no matter how many intermediate steps you 
add.</p>
<p>So all you need to do to use my code is to find the place between where the data is read and the data is sent (using <code>send()</code>) over the network, and stick some code in there that does the encryption.</p>
<p><strong>What is this “<code>PF_INET</code>” I keep seeing? Is it related to <code>AF_INET</code>?</strong></p>
<p> </p>
<p>Yes, yes it is. See <a href="#socket">the section on <code>socket()</code></a> for details.</p>
<p><strong>How can I write a server that accepts shell commands from a client and executes them?</strong></p>
<p>For simplicity, lets say the client <code>connect()</code>s, <code>send()</code>s, and <code>close()</code>s the connection (that is, there are no subsequent system calls without the client connecting again).</p>
<p>The process the client follows is this:</p>
<ol type="1">
<li><code>connect()</code> to server</li>
<li><code>send("/sbin/ls &gt; /tmp/client.out")</code></li>
<li><code>close()</code> the connection</li>
</ol>
<p>Meanwhile, the server is handling the data and executing it:</p>
<ol type="1">
<li><code>accept()</code> the connection from the client</li>
<li><code>recv(str)</code> the command string</li>
<li><code>close()</code> the connection</li>
<li><code>system(str)</code> to run the command</li>
</ol>
<p> <em>Beware!</em> Having the server execute what the client says is 
like giving remote shell access and people can do things to your account
 when they connect to the server. For instance, in the above example, 
what if the client sends “<code>rm -rf ~</code>”? It deletes everything in your account, that’s what!</p>
<p>So you get wise, and you prevent the client from using any except for a couple utilities that you know are safe, like the <code>foobar</code> utility:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (!strncmp(str, <span class="st">"foobar"</span>, <span class="dv">6</span>)) {</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>        sprintf(sysstr, <span class="st">"%s &gt; /tmp/server.out"</span>, str);</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>        system(sysstr);</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    } </span></code></pre></div>
<p>But you’re still unsafe, unfortunately: what if the client enters “<code>foobar; rm -rf ~</code>”? The safest thing to do is to write a little routine that puts an escape (“<code>\</code>”) character in front of all non-alphanumeric characters (including spaces, if appropriate) in the arguments for the command.</p>
<p>As you can see, security is a pretty big issue when the server starts executing things the client sends.</p>
<p><strong>I’m sending a slew of data, but when I <code>recv()</code>, 
it only receives 536 bytes or 1460 bytes at a time. But if I run it on 
my local machine, it receives all the data at the same time. What’s 
going on?</strong></p>
<p>You’re hitting the  MTU—the maximum size the physical medium can 
handle. On the local machine, you’re using the loopback device which can
 handle 8K or more no problem. But on Ethernet, which can only handle 
1500 bytes with a header, you hit that limit. Over a modem, with 576 MTU
 (again, with header), you hit the even lower limit.</p>
<p>You have to make sure all the data is being sent, first of all. (See the <a href="#sendall"><code>sendall()</code></a> function implementation for details.) Once you’re sure of that, then you need to call <code>recv()</code> in a loop until all your data is read.</p>
<p>Read the section <a href="#sonofdataencap">Son of Data Encapsulation</a> for details on receiving complete packets of data using multiple calls to <code>recv()</code>.</p>
<p><strong>I’m on a Windows box and I don’t have the <code>fork()</code> system call or any kind of <code>struct sigaction</code>. What to do?</strong></p>
<p> If they’re anywhere, they’ll be in POSIX libraries that may have 
shipped with your compiler. Since I don’t have a Windows box, I really 
can’t tell you the answer, but I seem to remember that Microsoft has a 
POSIX compatibility layer and that’s where <code>fork()</code> would be. (And maybe even <code>sigaction</code>.)</p>
<p>Search the help that came with VC++ for “fork” or “POSIX” and see if it gives you any clues.</p>
<p>If that doesn’t work at all, ditch the <code>fork()</code>/<code>sigaction</code> stuff and replace it with the Win32 equivalent:  <code>CreateProcess()</code>. I don’t know how to use <code>CreateProcess()</code>—it takes a bazillion arguments, but it should be covered in the docs that came with VC++.</p>
<p><strong> I’m behind a firewall—how do I let people outside the firewall know my IP address so they can connect to my machine?</strong></p>
<p>Unfortunately, the purpose of a firewall is to prevent people outside
 the firewall from connecting to machines inside the firewall, so 
allowing them to do so is basically considered a breach of security.</p>
<p>This isn’t to say that all is lost. For one thing, you can still often <code>connect()</code>
 through the firewall if it’s doing some kind of masquerading or NAT or 
something like that. Just design your programs so that you’re always the
 one initiating the connection, and you’ll be fine.</p>
<p> If that’s not satisfactory, you can ask your sysadmins to poke a 
hole in the firewall so that people can connect to you. The firewall can
 forward to you either through it’s NAT software, or through a proxy or 
something like that.</p>
<p>Be aware that a hole in the firewall is nothing to be taken lightly. 
You have to make sure you don’t give bad people access to the internal 
network; if you’re a beginner, it’s a lot harder to make software secure
 than you might imagine.</p>
<p>Don’t make your sysadmin mad at me. <code>;-)</code></p>
<p><strong>  How do I write a packet sniffer? How do I put my Ethernet interface into promiscuous mode?</strong></p>
<p>For those not in the know, when a network card is in “promiscuous 
mode”, it will forward ALL packets to the operating system, not just 
those that were addressed to this particular machine. (We’re talking 
Ethernet-layer addresses here, not IP addresses–but since ethernet is 
lower-layer than IP, all IP addresses are effectively forwarded as well.
 See the section <a href="#lowlevel">Low Level Nonsense and Network Theory</a> for more info.)</p>
<p>This is the basis for how a packet sniffer works. It puts the 
interface into promiscuous mode, then the OS gets every single packet 
that goes by on the wire. You’ll have a socket of some type that you can
 read this data from.</p>
<p>Unfortunately, the answer to the question varies depending on the 
platform, but if you Google for, for instance, “windows promiscuous  
ioctl” you’ll probably get somewhere. For Linux, there’s what looks like
 a <a href="https://stackoverflow.com/questions/21323023/">useful Stack Overflow thread</a><a href="#fn46" class="footnote-ref" id="fnref46" role="doc-noteref"><sup>46</sup></a>, as well.</p>
<p><strong>How can I set a custom  timeout value for a TCP or UDP socket?</strong></p>
<p>It depends on your system. You might search the net for  <code>SO_RCVTIMEO</code> and  <code>SO_SNDTIMEO</code> (for use with  <code>setsockopt()</code>) to see if your system supports such functionality.</p>
<p>The Linux man page suggests using <code>alarm()</code> or <code>setitimer()</code> as a substitute.</p>
<p><strong>How can I tell which ports are available to use? Is there a list of “official” port numbers?</strong></p>
<p>Usually this isn’t an issue. If you’re writing, say, a web server, 
then it’s a good idea to use the well-known port 80 for your software. 
If you’re writing just your own specialized server, then choose a port 
at random (but greater than 1023) and give it a try.</p>
<p>If the port is already in use, you’ll get an “Address already in use” error when you try to <code>bind()</code>.
 Choose another port. (It’s a good idea to allow the user of your 
software to specify an alternate port either with a config file or a 
command line switch.)</p>
<p>There is a <a href="https://www.iana.org/assignments/port-numbers">list of official port numbers</a><a href="#fn47" class="footnote-ref" id="fnref47" role="doc-noteref"><sup>47</sup></a>
 maintained by the Internet Assigned Numbers Authority (IANA). Just 
because something (over 1023) is in that list doesn’t mean you can’t use
 the port. For instance, Id Software’s DOOM uses the same port as 
“mdqs”, whatever that is. All that matters is that no one else <em>on the same machine</em> is using that port when you want to use it.</p>
<h1 data-number="9" id="man-pages"><span class="header-section-number">9</span> Man Pages</h1>
<p> In the Unix world, there are a lot of manuals. They have little 
sections that describe individual functions that you have at your 
disposal.</p>
<p>Of course, <code>manual</code> would be too much of a thing to type. I
 mean, no one in the Unix world, including myself, likes to type that 
much. Indeed I could go on and on at great length about how much I 
prefer to be terse but instead I shall be brief and not bore you with 
long-winded diatribes about how utterly amazingly brief I prefer to be 
in virtually all circumstances in their entirety.</p>
<p><em>[Applause]</em></p>
<p>Thank you. What I am getting at is that these pages are called “man 
pages” in the Unix world, and I have included my own personal truncated 
variant here for your reading enjoyment. The thing is, many of these 
functions are way more general purpose than I’m letting on, but I’m only
 going to present the parts that are relevant for Internet Sockets 
Programming.</p>
<p>But wait! That’s not all that’s wrong with my man pages:</p>
<ul>
<li>They are incomplete and only show the basics from the guide.</li>
<li>There are many more man pages than this in the real world.</li>
<li>They are different than the ones on your system.</li>
<li>The header files might be different for certain functions on your system.</li>
<li>The function parameters might be different for certain functions on your system.</li>
</ul>
<p>If you want the real information, check your local Unix man pages by typing <code>man whatever</code>, where “whatever” is something that you’re incredibly interested in, such as “<code>accept</code>”.
 (I’m sure Microsoft Visual Studio has something similar in their help 
section. But “man” is better because it is one byte more concise than 
“help”. Unix wins again!)</p>
<p>So, if these are so flawed, why even include them at all in the 
Guide? Well, there are a few reasons, but the best are that (a) these 
versions are geared specifically toward network programming and are 
easier to digest than the real ones, and (b) these versions contain 
examples!</p>
<p>Oh! And speaking of the examples, I don’t tend to put in all the 
error checking because it really increases the length of the code. But 
you should absolutely do error checking pretty much any time you make 
any of the system calls unless you’re totally 100% sure it’s not going 
to fail, and you should probably do it even then!</p>
<h2 data-number="9.1" id="acceptman"><span class="header-section-number">9.1</span> <code>accept()</code></h2>
<p>Accept an incoming connection on a listening socket</p>
<h4 data-number="9.1.0.1" id="synopsis"><span class="header-section-number">9.1.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb80"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> accept(<span class="dt">int</span> s, <span class="kw">struct</span> sockaddr *addr, socklen_t *addrlen);</span></code></pre></div>
<h4 data-number="9.1.0.2" id="description"><span class="header-section-number">9.1.0.2</span> Description</h4>
<p> Once you’ve gone through the trouble of getting a  <code>SOCK_STREAM</code> socket and setting it up for incoming connections with <code>listen()</code>, then you call <code>accept()</code> to actually get yourself a new socket descriptor to use for subsequent communication with the newly connected client.</p>
<p>The old socket that you are using for listening is still there, and will be used for further <code>accept()</code> calls as they come in.</p>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 85%">
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>s</code></td>
<td>The <code>listen()</code>ing socket descriptor.</td>
</tr>
<tr class="even">
<td><code>addr</code></td>
<td>This is filled in with the address of the site that’s connecting to you.</td>
</tr>
<tr class="odd">
<td><code>addrlen</code></td>
<td>This is filled in with the <code>sizeof()</code> the structure returned in the <code>addr</code> parameter. You can safely ignore it if you assume you’re getting a  <code>struct sockaddr_in</code> back, which you know you are, because that’s the type you passed in for <code>addr</code>.</td>
</tr>
</tbody>
</table>
<p><code>accept()</code> will normally block, and you can use <code>select()</code>
 to peek on the listening socket descriptor ahead of time to see if it’s
 “ready to read”. If so, then there’s a new connection waiting to be <code>accept()</code>ed! Yay! Alternatively, you could set the  <code>O_NONBLOCK</code> flag on the listening socket using  <code>fcntl()</code>, and then it will never block, choosing instead to return <code>-1</code> with <code>errno</code> set to  <code>EWOULDBLOCK</code>.</p>
<p>The socket descriptor returned by <code>accept()</code> is a bona fide socket descriptor, open and connected to the remote host. You have to <code>close()</code> it when you’re done with it.</p>
<h4 data-number="9.1.0.3" id="return-value"><span class="header-section-number">9.1.0.3</span> Return Value</h4>
<p><code>accept()</code> returns the newly connected socket descriptor, or <code>-1</code> on error, with <code>errno</code> set appropriately.</p>
<h4 data-number="9.1.0.4" id="example"><span class="header-section-number">9.1.0.4</span> Example</h4>
<div class="sourceCode" id="cb81"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb81-1"><a href="#cb81-1"></a><span class="kw">struct</span> sockaddr_storage their_addr;</span>
<span id="cb81-2"><a href="#cb81-2"></a>socklen_t addr_size;</span>
<span id="cb81-3"><a href="#cb81-3"></a><span class="kw">struct</span> addrinfo hints, *res;</span>
<span id="cb81-4"><a href="#cb81-4"></a><span class="dt">int</span> sockfd, new_fd;</span>
<span id="cb81-5"><a href="#cb81-5"></a></span>
<span id="cb81-6"><a href="#cb81-6"></a><span class="co">// first, load up address structs with getaddrinfo():</span></span>
<span id="cb81-7"><a href="#cb81-7"></a></span>
<span id="cb81-8"><a href="#cb81-8"></a>memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb81-9"><a href="#cb81-9"></a>hints.ai_family = AF_UNSPEC;  <span class="co">// use IPv4 or IPv6, whichever</span></span>
<span id="cb81-10"><a href="#cb81-10"></a>hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb81-11"><a href="#cb81-11"></a>hints.ai_flags = AI_PASSIVE;     <span class="co">// fill in my IP for me</span></span>
<span id="cb81-12"><a href="#cb81-12"></a></span>
<span id="cb81-13"><a href="#cb81-13"></a>getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);</span>
<span id="cb81-14"><a href="#cb81-14"></a></span>
<span id="cb81-15"><a href="#cb81-15"></a><span class="co">// make a socket, bind it, and listen on it:</span></span>
<span id="cb81-16"><a href="#cb81-16"></a></span>
<span id="cb81-17"><a href="#cb81-17"></a>sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span>
<span id="cb81-18"><a href="#cb81-18"></a>bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</span>
<span id="cb81-19"><a href="#cb81-19"></a>listen(sockfd, BACKLOG);</span>
<span id="cb81-20"><a href="#cb81-20"></a></span>
<span id="cb81-21"><a href="#cb81-21"></a><span class="co">// now accept an incoming connection:</span></span>
<span id="cb81-22"><a href="#cb81-22"></a></span>
<span id="cb81-23"><a href="#cb81-23"></a>addr_size = <span class="kw">sizeof</span> their_addr;</span>
<span id="cb81-24"><a href="#cb81-24"></a>new_fd = accept(sockfd, (<span class="kw">struct</span> sockaddr *)&amp;their_addr, &amp;addr_size);</span>
<span id="cb81-25"><a href="#cb81-25"></a></span>
<span id="cb81-26"><a href="#cb81-26"></a><span class="co">// ready to communicate on socket descriptor new_fd!</span></span></code></pre></div>
<h4 data-number="9.1.0.5" id="see-also"><span class="header-section-number">9.1.0.5</span> See Also</h4>
<p><a href="#socketman"><code>socket()</code></a>, <a href="#getaddrinfoman"><code>getaddrinfo()</code></a>, <a href="#listenman"><code>listen()</code></a>, <a href="#sockaddr_inman"><code>struct sockaddr_in</code></a></p>
<h2 data-number="9.2" id="bindman"><span class="header-section-number">9.2</span> <code>bind()</code></h2>
<p>Associate a socket with an IP address and port number</p>
<h4 data-number="9.2.0.1" id="synopsis-1"><span class="header-section-number">9.2.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb82"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> bind(<span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *my_addr, socklen_t addrlen);</span></code></pre></div>
<h4 data-number="9.2.0.2" id="description-1"><span class="header-section-number">9.2.0.2</span> Description</h4>
<p> When a remote machine wants to connect to your server program, it 
needs two pieces of information: the  IP address and the  port number. 
The <code>bind()</code> call allows you to do just that.</p>
<p>First, you call <code>getaddrinfo()</code> to load up a <code>struct sockaddr</code> with the destination address and port information. Then you call <code>socket()</code> to get a socket descriptor, and then you pass the socket and address into <code>bind()</code>, and the IP address and port are magically (using actual magic) bound to the socket!</p>
<p>If you don’t know your IP address, or you know you only have one IP 
address on the machine, or you don’t care which of the machine’s IP 
addresses is used, you can simply pass the <code>AI_PASSIVE</code> flag in the <code>hints</code> parameter to <code>getaddrinfo()</code>. What this does is fill in the IP address part of the <code>struct sockaddr</code> with a special value that tells <code>bind()</code> that it should automatically fill in this host’s IP address.</p>
<p>What what? What special value is loaded into the <code>struct sockaddr</code>’s
 IP address to cause it to auto-fill the address with the current host? 
I’ll tell you, but keep in mind this is only if you’re filling out the <code>struct sockaddr</code> by hand; if not, use the results from <code>getaddrinfo()</code>, as per above. In IPv4, the <code>sin_addr.s_addr</code> field of the <code>struct sockaddr_in</code> structure is set to <code>INADDR_ANY</code>. In IPv6, the <code>sin6_addr</code> field of the <code>struct sockaddr_in6</code> structure is assigned into from the global variable <code>in6addr_any</code>. Or, if you’re declaring a new <code>struct in6_addr</code>, you can initialize it to <code>IN6ADDR_ANY_INIT</code>.</p>
<p>Lastly, the <code>addrlen</code> parameter should be set to <code>sizeof my_addr</code>.</p>
<h4 data-number="9.2.0.3" id="return-value-1"><span class="header-section-number">9.2.0.3</span> Return Value</h4>
<p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p>
<h4 data-number="9.2.0.4" id="example-1"><span class="header-section-number">9.2.0.4</span> Example</h4>
<div class="sourceCode" id="cb83"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb83-1"><a href="#cb83-1"></a><span class="co">// modern way of doing things with getaddrinfo()</span></span>
<span id="cb83-2"><a href="#cb83-2"></a></span>
<span id="cb83-3"><a href="#cb83-3"></a><span class="kw">struct</span> addrinfo hints, *res;</span>
<span id="cb83-4"><a href="#cb83-4"></a><span class="dt">int</span> sockfd;</span>
<span id="cb83-5"><a href="#cb83-5"></a></span>
<span id="cb83-6"><a href="#cb83-6"></a><span class="co">// first, load up address structs with getaddrinfo():</span></span>
<span id="cb83-7"><a href="#cb83-7"></a></span>
<span id="cb83-8"><a href="#cb83-8"></a>memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb83-9"><a href="#cb83-9"></a>hints.ai_family = AF_UNSPEC;  <span class="co">// use IPv4 or IPv6, whichever</span></span>
<span id="cb83-10"><a href="#cb83-10"></a>hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb83-11"><a href="#cb83-11"></a>hints.ai_flags = AI_PASSIVE;     <span class="co">// fill in my IP for me</span></span>
<span id="cb83-12"><a href="#cb83-12"></a></span>
<span id="cb83-13"><a href="#cb83-13"></a>getaddrinfo(NULL, <span class="st">"3490"</span>, &amp;hints, &amp;res);</span>
<span id="cb83-14"><a href="#cb83-14"></a></span>
<span id="cb83-15"><a href="#cb83-15"></a><span class="co">// make a socket:</span></span>
<span id="cb83-16"><a href="#cb83-16"></a><span class="co">// (you should actually walk the "res" linked list and error-check!)</span></span>
<span id="cb83-17"><a href="#cb83-17"></a></span>
<span id="cb83-18"><a href="#cb83-18"></a>sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span>
<span id="cb83-19"><a href="#cb83-19"></a></span>
<span id="cb83-20"><a href="#cb83-20"></a><span class="co">// bind it to the port we passed in to getaddrinfo():</span></span>
<span id="cb83-21"><a href="#cb83-21"></a></span>
<span id="cb83-22"><a href="#cb83-22"></a>bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</span></code></pre></div>
<div class="sourceCode" id="cb84"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb84-1"><a href="#cb84-1"></a><span class="co">// example of packing a struct by hand, IPv4</span></span>
<span id="cb84-2"><a href="#cb84-2"></a></span>
<span id="cb84-3"><a href="#cb84-3"></a><span class="kw">struct</span> sockaddr_in myaddr;</span>
<span id="cb84-4"><a href="#cb84-4"></a><span class="dt">int</span> s;</span>
<span id="cb84-5"><a href="#cb84-5"></a></span>
<span id="cb84-6"><a href="#cb84-6"></a>myaddr.sin_family = AF_INET;</span>
<span id="cb84-7"><a href="#cb84-7"></a>myaddr.sin_port = htons(<span class="dv">3490</span>);</span>
<span id="cb84-8"><a href="#cb84-8"></a></span>
<span id="cb84-9"><a href="#cb84-9"></a><span class="co">// you can specify an IP address:</span></span>
<span id="cb84-10"><a href="#cb84-10"></a>inet_pton(AF_INET, <span class="st">"63.161.169.137"</span>, &amp;(myaddr.sin_addr));</span>
<span id="cb84-11"><a href="#cb84-11"></a></span>
<span id="cb84-12"><a href="#cb84-12"></a><span class="co">// or you can let it automatically select one:</span></span>
<span id="cb84-13"><a href="#cb84-13"></a>myaddr.sin_addr.s_addr = INADDR_ANY;</span>
<span id="cb84-14"><a href="#cb84-14"></a></span>
<span id="cb84-15"><a href="#cb84-15"></a>s = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</span>
<span id="cb84-16"><a href="#cb84-16"></a>bind(s, (<span class="kw">struct</span> sockaddr*)&amp;myaddr, <span class="kw">sizeof</span> myaddr);</span></code></pre></div>
<h4 data-number="9.2.0.5" id="see-also-1"><span class="header-section-number">9.2.0.5</span> See Also</h4>
<p><a href="#getaddrinfoman"><code>getaddrinfo()</code></a>, <a href="#socketman"><code>socket()</code></a>, <a href="#sockaddr_inman"><code>struct sockaddr_in</code></a>, <a href="#sockaddr_inman"><code>struct in_addr</code></a></p>
<h2 data-number="9.3" id="connectman"><span class="header-section-number">9.3</span> <code>connect()</code></h2>
<p>Connect a socket to a server</p>
<h4 data-number="9.3.0.1" id="synopsis-2"><span class="header-section-number">9.3.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb85"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> connect(<span class="dt">int</span> sockfd, <span class="dt">const</span> <span class="kw">struct</span> sockaddr *serv_addr,</span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>                socklen_t addrlen);</span></code></pre></div>
<h4 data-number="9.3.0.2" id="description-2"><span class="header-section-number">9.3.0.2</span> Description</h4>
<p> Once you’ve built a socket descriptor with the <code>socket()</code> call, you can <code>connect()</code> that socket to a remote server using the well-named <code>connect()</code>
 system call. All you need to do is pass it the socket descriptor and 
the address of the server you’re interested in getting to know better. 
(Oh, and the length of the address, which is commonly passed to 
functions like this.)</p>
<p>Usually this information comes along as the result of a call to <code>getaddrinfo()</code>, but you can fill out your own <code>struct sockaddr</code> if you want to.</p>
<p>If you haven’t yet called <code>bind()</code> on the socket 
descriptor, it is automatically bound to your IP address and a random 
local port. This is usually just fine with you if you’re not a server, 
since you really don’t care what your local port is; you only care what 
the remote port is so you can put it in the <code>serv_addr</code> parameter. You <em>can</em> call <code>bind()</code> if you really want your client socket to be on a specific IP address and port, but this is pretty rare.</p>
<p>Once the socket is <code>connect()</code>ed, you’re free to <code>send()</code> and <code>recv()</code> data on it to your heart’s content.</p>
<p> Special note: if you <code>connect()</code> a <code>SOCK_DGRAM</code> UDP socket to a remote host, you can use <code>send()</code> and <code>recv()</code> as well as <code>sendto()</code> and <code>recvfrom()</code>. If you want.</p>
<h4 data-number="9.3.0.3" id="return-value-2"><span class="header-section-number">9.3.0.3</span> Return Value</h4>
<p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p>
<h4 data-number="9.3.0.4" id="example-2"><span class="header-section-number">9.3.0.4</span> Example</h4>
<div class="sourceCode" id="cb86"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb86-1"><a href="#cb86-1"></a><span class="co">// connect to www.example.com port 80 (http)</span></span>
<span id="cb86-2"><a href="#cb86-2"></a></span>
<span id="cb86-3"><a href="#cb86-3"></a><span class="kw">struct</span> addrinfo hints, *res;</span>
<span id="cb86-4"><a href="#cb86-4"></a><span class="dt">int</span> sockfd;</span>
<span id="cb86-5"><a href="#cb86-5"></a></span>
<span id="cb86-6"><a href="#cb86-6"></a><span class="co">// first, load up address structs with getaddrinfo():</span></span>
<span id="cb86-7"><a href="#cb86-7"></a></span>
<span id="cb86-8"><a href="#cb86-8"></a>memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb86-9"><a href="#cb86-9"></a>hints.ai_family = AF_UNSPEC;  <span class="co">// use IPv4 or IPv6, whichever</span></span>
<span id="cb86-10"><a href="#cb86-10"></a>hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb86-11"><a href="#cb86-11"></a></span>
<span id="cb86-12"><a href="#cb86-12"></a><span class="co">// we could put "80" instead on "http" on the next line:</span></span>
<span id="cb86-13"><a href="#cb86-13"></a>getaddrinfo(<span class="st">"www.example.com"</span>, <span class="st">"http"</span>, &amp;hints, &amp;res);</span>
<span id="cb86-14"><a href="#cb86-14"></a></span>
<span id="cb86-15"><a href="#cb86-15"></a><span class="co">// make a socket:</span></span>
<span id="cb86-16"><a href="#cb86-16"></a></span>
<span id="cb86-17"><a href="#cb86-17"></a>sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span>
<span id="cb86-18"><a href="#cb86-18"></a></span>
<span id="cb86-19"><a href="#cb86-19"></a><span class="co">// connect it to the address and port we passed in to getaddrinfo():</span></span>
<span id="cb86-20"><a href="#cb86-20"></a></span>
<span id="cb86-21"><a href="#cb86-21"></a>connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</span></code></pre></div>
<h4 data-number="9.3.0.5" id="see-also-2"><span class="header-section-number">9.3.0.5</span> See Also</h4>
<p><a href="#socketman"><code>socket()</code></a>, <a href="#bindman"><code>bind()</code></a></p>
<h2 data-number="9.4" id="closeman"><span class="header-section-number">9.4</span> <code>close()</code></h2>
<p>Close a socket descriptor</p>
<h4 data-number="9.4.0.1" id="synopsis-3"><span class="header-section-number">9.4.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb87"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> close(<span class="dt">int</span> s);</span></code></pre></div>
<h4 data-number="9.4.0.2" id="description-3"><span class="header-section-number">9.4.0.2</span> Description</h4>
<p> After you’ve finished using the socket for whatever demented scheme you have concocted and you don’t want to <code>send()</code> or <code>recv()</code> or, indeed, do <em>anything else</em> at all with the socket, you can <code>close()</code> it, and it’ll be freed up, never to be used again.</p>
<p>The remote side can tell if this happens one of two ways. One: if the remote side calls <code>recv()</code>, it will return <code>0</code>. Two: if the remote side calls <code>send()</code>, it’ll receive a signal  <code>SIGPIPE</code> and send() will return <code>-1</code> and <code>errno</code> will be set to  <code>EPIPE</code>.</p>
<p> <strong>Windows users</strong>: the function you need to use is called  <code>closesocket()</code>, not <code>close()</code>. If you try to use <code>close()</code> on a socket descriptor, it’s possible Windows will get angry… And you wouldn’t like it when it’s angry.</p>
<h4 data-number="9.4.0.3" id="return-value-3"><span class="header-section-number">9.4.0.3</span> Return Value</h4>
<p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p>
<h4 data-number="9.4.0.4" id="example-3"><span class="header-section-number">9.4.0.4</span> Example</h4>
<div class="sourceCode" id="cb88"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb88-1"><a href="#cb88-1"></a>s = socket(PF_INET, SOCK_DGRAM, <span class="dv">0</span>);</span>
<span id="cb88-2"><a href="#cb88-2"></a>.</span>
<span id="cb88-3"><a href="#cb88-3"></a>.</span>
<span id="cb88-4"><a href="#cb88-4"></a>.</span>
<span id="cb88-5"><a href="#cb88-5"></a><span class="co">// a whole lotta stuff...*BRRRONNNN!*</span></span>
<span id="cb88-6"><a href="#cb88-6"></a>.</span>
<span id="cb88-7"><a href="#cb88-7"></a>.</span>
<span id="cb88-8"><a href="#cb88-8"></a>.</span>
<span id="cb88-9"><a href="#cb88-9"></a>close(s);  <span class="co">// not much to it, really.</span></span></code></pre></div>
<h4 data-number="9.4.0.5" id="see-also-3"><span class="header-section-number">9.4.0.5</span> See Also</h4>
<p><a href="#socketman"><code>socket()</code></a>, <a href="#shutdownman"><code>shutdown()</code></a></p>
<h2 data-number="9.5" id="getaddrinfoman"><span class="header-section-number">9.5</span> <code>getaddrinfo()</code>, <code>freeaddrinfo()</code>, <code>gai_strerror()</code></h2>
<p>Get information about a host name and/or service and load up a <code>struct sockaddr</code> with the result.</p>
<h4 data-number="9.5.0.1" id="synopsis-4"><span class="header-section-number">9.5.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb89"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> getaddrinfo(<span class="dt">const</span> <span class="dt">char</span> *nodename, <span class="dt">const</span> <span class="dt">char</span> *servname,</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">const</span> <span class="kw">struct</span> addrinfo *hints, <span class="kw">struct</span> addrinfo **res);</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> freeaddrinfo(<span class="kw">struct</span> addrinfo *ai);</span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> *gai_strerror(<span class="dt">int</span> ecode);</span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> addrinfo {</span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span>     ai_flags;          <span class="co">// AI_PASSIVE, AI_CANONNAME, ...</span></span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span>     ai_family;         <span class="co">// AF_xxx</span></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span>     ai_socktype;       <span class="co">// SOCK_xxx</span></span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span>     ai_protocol;       <span class="co">// 0 (auto) or IPPROTO_TCP, IPPROTO_UDP </span></span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a>      socklen_t  ai_addrlen;     <span class="co">// length of ai_addr</span></span>
<span id="cb89-19"><a href="#cb89-19" aria-hidden="true" tabindex="-1"></a>      <span class="dt">char</span>   *ai_canonname;      <span class="co">// canonical name for nodename</span></span>
<span id="cb89-20"><a href="#cb89-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> sockaddr  *ai_addr; <span class="co">// binary address</span></span>
<span id="cb89-21"><a href="#cb89-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> addrinfo  *ai_next; <span class="co">// next structure in linked list</span></span>
<span id="cb89-22"><a href="#cb89-22" aria-hidden="true" tabindex="-1"></a>    };</span></code></pre></div>
<h4 data-number="9.5.0.2" id="description-4"><span class="header-section-number">9.5.0.2</span> Description</h4>
<p><code>getaddrinfo()</code> is an excellent function that will return information on a particular host name (such as its IP address) and load up a <code>struct sockaddr</code> for you, taking care of the gritty details (like if it’s IPv4 or IPv6). It replaces the old functions <code>gethostbyname()</code> and <code>getservbyname()</code>.The
 description, below, contains a lot of information that might be a 
little daunting, but actual usage is pretty simple. It might be worth it
 to check out the examples first.</p>
<p>The host name that you’re interested in goes in the <code>nodename</code>
 parameter. The address can be either a host name, like 
“www.example.com”, or an IPv4 or IPv6 address (passed as a string). This
 parameter can also be <code>NULL</code> if you’re using the <code>AI_PASSIVE</code> flag (see below).</p>
<p>The <code>servname</code> parameter is basically the port number. It 
can be a port number (passed as a string, like “80”), or it can be a 
service name, like “http” or “tftp” or “smtp” or “pop”, etc. Well-known 
service names can be found in the <a href="https://www.iana.org/assignments/port-numbers">IANA Port List</a><a href="#fn48" class="footnote-ref" id="fnref48" role="doc-noteref"><sup>48</sup></a> or in your <code>/etc/services</code> file.</p>
<p>Lastly, for input parameters, we have <code>hints</code>. This is really where you get to define what the <code>getaddrinfo()</code> function is going to do. Zero the whole structure before use with <code>memset()</code>. Let’s take a look at the fields you need to set up before use.</p>
<p>The <code>ai_flags</code> can be set to a variety of things, but here
 are a couple important ones. (Multiple flags can be specified by 
bitwise-ORing them together with the <code>|</code> operator). Check your man page for the complete list of flags.</p>
<p><code>AI_CANONNAME</code> causes the <code>ai_canonname</code> of the result to the filled out with the host’s canonical (real) name. <code>AI_PASSIVE</code> causes the result’s IP address to be filled out with <code>INADDR_ANY</code> (IPv4) or <code>in6addr_any</code> (IPv6); this causes a subsequent call to <code>bind()</code> to auto-fill the IP address of the <code>struct sockaddr</code> with the address of the current host. That’s excellent for setting up a server when you don’t want to hardcode the address.</p>
<p>If you do use the <code>AI_PASSIVE</code>, flag, then you can pass <code>NULL</code> in the <code>nodename</code> (since <code>bind()</code> will fill it in for you later).</p>
<p>Continuing on with the input paramters, you’ll likely want to set <code>ai_family</code> to <code>AF_UNSPEC</code> which tells <code>getaddrinfo()</code> to look for both IPv4 and IPv6 addresses. You can also restrict yourself to one or the other with <code>AF_INET</code> or <code>AF_INET6</code>.</p>
<p>Next, the <code>socktype</code> field should be set to <code>SOCK_STREAM</code> or <code>SOCK_DGRAM</code>, depending on which type of socket you want.</p>
<p>Finally, just leave <code>ai_protocol</code> at <code>0</code> to automatically choose your protocol type.</p>
<p>Now, after you get all that stuff in there, you can <em>finally</em> make the call to <code>getaddrinfo()</code>!</p>
<p>Of course, this is where the fun begins. The <code>res</code> will now point to a linked list of <code>struct addrinfo</code>s, and you can go through this list to get all the addresses that match what you passed in with the hints.</p>
<p>Now, it’s possible to get some addresses that don’t work for one 
reason or another, so what the Linux man page does is loops through the 
list doing a call to <code>socket()</code> and <code>connect()</code> (or <code>bind()</code> if you’re setting up a server with the <code>AI_PASSIVE</code> flag) until it succeeds.</p>
<p>Finally, when you’re done with the linked list, you need to call <code>freeaddrinfo()</code> to free up the memory (or it will be leaked, and Some People will get upset).</p>
<h4 data-number="9.5.0.3" id="return-value-4"><span class="header-section-number">9.5.0.3</span> Return Value</h4>
<p>Returns zero on success, or nonzero on error. If it returns nonzero, you can use the function <code>gai_strerror()</code> to get a printable version of the error code in the return value.</p>
<h4 data-number="9.5.0.4" id="example-4"><span class="header-section-number">9.5.0.4</span> Example</h4>
<div class="sourceCode" id="cb90"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb90-1"><a href="#cb90-1"></a><span class="co">// code for a client connecting to a server</span></span>
<span id="cb90-2"><a href="#cb90-2"></a><span class="co">// namely a stream socket to www.example.com on port 80 (http)</span></span>
<span id="cb90-3"><a href="#cb90-3"></a><span class="co">// either IPv4 or IPv6</span></span>
<span id="cb90-4"><a href="#cb90-4"></a></span>
<span id="cb90-5"><a href="#cb90-5"></a><span class="dt">int</span> sockfd;  </span>
<span id="cb90-6"><a href="#cb90-6"></a><span class="kw">struct</span> addrinfo hints, *servinfo, *p;</span>
<span id="cb90-7"><a href="#cb90-7"></a><span class="dt">int</span> rv;</span>
<span id="cb90-8"><a href="#cb90-8"></a></span>
<span id="cb90-9"><a href="#cb90-9"></a>memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb90-10"><a href="#cb90-10"></a>hints.ai_family = AF_UNSPEC; <span class="co">// use AF_INET6 to force IPv6</span></span>
<span id="cb90-11"><a href="#cb90-11"></a>hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb90-12"><a href="#cb90-12"></a></span>
<span id="cb90-13"><a href="#cb90-13"></a><span class="cf">if</span> ((rv = getaddrinfo(<span class="st">"www.example.com"</span>, <span class="st">"http"</span>, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</span>
<span id="cb90-14"><a href="#cb90-14"></a>    fprintf(stderr, <span class="st">"getaddrinfo: %s</span><span class="sc">\n</span><span class="st">"</span>, gai_strerror(rv));</span>
<span id="cb90-15"><a href="#cb90-15"></a>    exit(<span class="dv">1</span>);</span>
<span id="cb90-16"><a href="#cb90-16"></a>}</span>
<span id="cb90-17"><a href="#cb90-17"></a></span>
<span id="cb90-18"><a href="#cb90-18"></a><span class="co">// loop through all the results and connect to the first we can</span></span>
<span id="cb90-19"><a href="#cb90-19"></a><span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</span>
<span id="cb90-20"><a href="#cb90-20"></a>    <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span>
<span id="cb90-21"><a href="#cb90-21"></a>            p-&gt;ai_protocol)) == -<span class="dv">1</span>) {</span>
<span id="cb90-22"><a href="#cb90-22"></a>        perror(<span class="st">"socket"</span>);</span>
<span id="cb90-23"><a href="#cb90-23"></a>        <span class="cf">continue</span>;</span>
<span id="cb90-24"><a href="#cb90-24"></a>    }</span>
<span id="cb90-25"><a href="#cb90-25"></a></span>
<span id="cb90-26"><a href="#cb90-26"></a>    <span class="cf">if</span> (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -<span class="dv">1</span>) {</span>
<span id="cb90-27"><a href="#cb90-27"></a>        perror(<span class="st">"connect"</span>);</span>
<span id="cb90-28"><a href="#cb90-28"></a>        close(sockfd);</span>
<span id="cb90-29"><a href="#cb90-29"></a>        <span class="cf">continue</span>;</span>
<span id="cb90-30"><a href="#cb90-30"></a>    }</span>
<span id="cb90-31"><a href="#cb90-31"></a></span>
<span id="cb90-32"><a href="#cb90-32"></a>    <span class="cf">break</span>; <span class="co">// if we get here, we must have connected successfully</span></span>
<span id="cb90-33"><a href="#cb90-33"></a>}</span>
<span id="cb90-34"><a href="#cb90-34"></a></span>
<span id="cb90-35"><a href="#cb90-35"></a><span class="cf">if</span> (p == NULL) {</span>
<span id="cb90-36"><a href="#cb90-36"></a>    <span class="co">// looped off the end of the list with no connection</span></span>
<span id="cb90-37"><a href="#cb90-37"></a>    fprintf(stderr, <span class="st">"failed to connect</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb90-38"><a href="#cb90-38"></a>    exit(<span class="dv">2</span>);</span>
<span id="cb90-39"><a href="#cb90-39"></a>}</span>
<span id="cb90-40"><a href="#cb90-40"></a></span>
<span id="cb90-41"><a href="#cb90-41"></a>freeaddrinfo(servinfo); <span class="co">// all done with this structure</span></span></code></pre></div>
<div class="sourceCode" id="cb91"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb91-1"><a href="#cb91-1"></a><span class="co">// code for a server waiting for connections</span></span>
<span id="cb91-2"><a href="#cb91-2"></a><span class="co">// namely a stream socket on port 3490, on this host's IP</span></span>
<span id="cb91-3"><a href="#cb91-3"></a><span class="co">// either IPv4 or IPv6.</span></span>
<span id="cb91-4"><a href="#cb91-4"></a></span>
<span id="cb91-5"><a href="#cb91-5"></a><span class="dt">int</span> sockfd;  </span>
<span id="cb91-6"><a href="#cb91-6"></a><span class="kw">struct</span> addrinfo hints, *servinfo, *p;</span>
<span id="cb91-7"><a href="#cb91-7"></a><span class="dt">int</span> rv;</span>
<span id="cb91-8"><a href="#cb91-8"></a></span>
<span id="cb91-9"><a href="#cb91-9"></a>memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb91-10"><a href="#cb91-10"></a>hints.ai_family = AF_UNSPEC; <span class="co">// use AF_INET6 to force IPv6</span></span>
<span id="cb91-11"><a href="#cb91-11"></a>hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb91-12"><a href="#cb91-12"></a>hints.ai_flags = AI_PASSIVE; <span class="co">// use my IP address</span></span>
<span id="cb91-13"><a href="#cb91-13"></a></span>
<span id="cb91-14"><a href="#cb91-14"></a><span class="cf">if</span> ((rv = getaddrinfo(NULL, <span class="st">"3490"</span>, &amp;hints, &amp;servinfo)) != <span class="dv">0</span>) {</span>
<span id="cb91-15"><a href="#cb91-15"></a>    fprintf(stderr, <span class="st">"getaddrinfo: %s</span><span class="sc">\n</span><span class="st">"</span>, gai_strerror(rv));</span>
<span id="cb91-16"><a href="#cb91-16"></a>    exit(<span class="dv">1</span>);</span>
<span id="cb91-17"><a href="#cb91-17"></a>}</span>
<span id="cb91-18"><a href="#cb91-18"></a></span>
<span id="cb91-19"><a href="#cb91-19"></a><span class="co">// loop through all the results and bind to the first we can</span></span>
<span id="cb91-20"><a href="#cb91-20"></a><span class="cf">for</span>(p = servinfo; p != NULL; p = p-&gt;ai_next) {</span>
<span id="cb91-21"><a href="#cb91-21"></a>    <span class="cf">if</span> ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span>
<span id="cb91-22"><a href="#cb91-22"></a>            p-&gt;ai_protocol)) == -<span class="dv">1</span>) {</span>
<span id="cb91-23"><a href="#cb91-23"></a>        perror(<span class="st">"socket"</span>);</span>
<span id="cb91-24"><a href="#cb91-24"></a>        <span class="cf">continue</span>;</span>
<span id="cb91-25"><a href="#cb91-25"></a>    }</span>
<span id="cb91-26"><a href="#cb91-26"></a></span>
<span id="cb91-27"><a href="#cb91-27"></a>    <span class="cf">if</span> (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -<span class="dv">1</span>) {</span>
<span id="cb91-28"><a href="#cb91-28"></a>        close(sockfd);</span>
<span id="cb91-29"><a href="#cb91-29"></a>        perror(<span class="st">"bind"</span>);</span>
<span id="cb91-30"><a href="#cb91-30"></a>        <span class="cf">continue</span>;</span>
<span id="cb91-31"><a href="#cb91-31"></a>    }</span>
<span id="cb91-32"><a href="#cb91-32"></a></span>
<span id="cb91-33"><a href="#cb91-33"></a>    <span class="cf">break</span>; <span class="co">// if we get here, we must have connected successfully</span></span>
<span id="cb91-34"><a href="#cb91-34"></a>}</span>
<span id="cb91-35"><a href="#cb91-35"></a></span>
<span id="cb91-36"><a href="#cb91-36"></a><span class="cf">if</span> (p == NULL) {</span>
<span id="cb91-37"><a href="#cb91-37"></a>    <span class="co">// looped off the end of the list with no successful bind</span></span>
<span id="cb91-38"><a href="#cb91-38"></a>    fprintf(stderr, <span class="st">"failed to bind socket</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb91-39"><a href="#cb91-39"></a>    exit(<span class="dv">2</span>);</span>
<span id="cb91-40"><a href="#cb91-40"></a>}</span>
<span id="cb91-41"><a href="#cb91-41"></a></span>
<span id="cb91-42"><a href="#cb91-42"></a>freeaddrinfo(servinfo); <span class="co">// all done with this structure</span></span></code></pre></div>
<h4 data-number="9.5.0.5" id="see-also-4"><span class="header-section-number">9.5.0.5</span> See Also</h4>
<p><a href="#gethostbynameman"><code>gethostbyname()</code></a>, <a href="#getnameinfoman"><code>getnameinfo()</code></a></p>
<h2 data-number="9.6" id="gethostnameman"><span class="header-section-number">9.6</span> <code>gethostname()</code></h2>
<p>Returns the name of the system</p>
<h4 data-number="9.6.0.1" id="synopsis-5"><span class="header-section-number">9.6.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb92"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/unistd.h&gt;</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> gethostname(<span class="dt">char</span> *name, <span class="dt">size_t</span> len);</span></code></pre></div>
<h4 data-number="9.6.0.2" id="description-5"><span class="header-section-number">9.6.0.2</span> Description</h4>
<p> Your system has a name. They all do. This is a slightly more Unixy 
thing than the rest of the networky stuff we’ve been talking about, but 
it still has its uses.</p>
<p>For instance, you can get your host name, and then call  <code>gethostbyname()</code> to find out your  IP address.</p>
<p>The parameter <code>name</code> should point to a buffer that will hold the host name, and <code>len</code> is the size of that buffer in bytes. <code>gethostname()</code> won’t overwrite the end of the buffer (it might return an error, or it might just stop writing), and it will <code>NUL</code>-terminate the string if there’s room for it in the buffer.</p>
<h4 data-number="9.6.0.3" id="return-value-5"><span class="header-section-number">9.6.0.3</span> Return Value</h4>
<p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p>
<h4 data-number="9.6.0.4" id="example-5"><span class="header-section-number">9.6.0.4</span> Example</h4>
<div class="sourceCode" id="cb93"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb93-1"><a href="#cb93-1"></a><span class="dt">char</span> hostname[<span class="dv">128</span>];</span>
<span id="cb93-2"><a href="#cb93-2"></a></span>
<span id="cb93-3"><a href="#cb93-3"></a>gethostname(hostname, <span class="kw">sizeof</span> hostname);</span>
<span id="cb93-4"><a href="#cb93-4"></a>printf(<span class="st">"My hostname: %s</span><span class="sc">\n</span><span class="st">"</span>, hostname);</span></code></pre></div>
<h4 data-number="9.6.0.5" id="see-also-5"><span class="header-section-number">9.6.0.5</span> See Also</h4>
<p><a href="#gethostbynameman"><code>gethostbyname()</code></a></p>
<h2 data-number="9.7" id="gethostbynameman"><span class="header-section-number">9.7</span> <code>gethostbyname()</code>, <code>gethostbyaddr()</code></h2>
<p>Get an IP address for a hostname, or vice-versa</p>
<h4 data-number="9.7.0.1" id="synopsis-6"><span class="header-section-number">9.7.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb94"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> hostent *gethostbyname(<span class="dt">const</span> <span class="dt">char</span> *name); <span class="co">// </span><span class="al">DEPRECATED</span><span class="co">!</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> hostent *gethostbyaddr(<span class="dt">const</span> <span class="dt">char</span> *addr, <span class="dt">int</span> len, <span class="dt">int</span> type);</span></code></pre></div>
<h4 data-number="9.7.0.2" id="description-6"><span class="header-section-number">9.7.0.2</span> Description</h4>
<p>  <em>PLEASE NOTE: these two functions are superseded by <code>getaddrinfo()</code> and <code>getnameinfo()</code>!</em> In particular, <code>gethostbyname()</code> doesn’t work well with IPv6.</p>
<p>These functions map back and forth between host names and IP 
addresses. For instance, if you have “www.example.com”, you can use <code>gethostbyname()</code> to get its IP address and store it in a <code>struct in_addr</code>.</p>
<p>Conversely, if you have a <code>struct in_addr</code> or a <code>struct in6_addr</code>, you can use <code>gethostbyaddr()</code> to get the hostname back. <code>gethostbyaddr()</code> <em>is</em> IPv6 compatible, but you should use the newer shinier <code>getnameinfo()</code> instead.</p>
<p>(If you have a string containing an IP address in dots-and-numbers 
format that you want to look up the hostname of, you’d be better off 
using <code>getaddrinfo()</code> with the <code>AI_CANONNAME</code> flag.)</p>
<p><code>gethostbyname()</code> takes a string like “www.yahoo.com”, and returns a <code>struct hostent</code>
 which contains tons of information, including the  IP address. (Other 
information is the official host name, a list of aliases, the address 
type, the length of the addresses, and the list of addresses—it’s a 
general-purpose structure that’s pretty easy to use for our specific 
purposes once you see how.)</p>
<p><code>gethostbyaddr()</code> takes a <code>struct in_addr</code> or <code>struct in6_addr</code> and brings you up a corresponding host name (if there is one), so it’s sort of the reverse of <code>gethostbyname()</code>. As for parameters, even though <code>addr</code> is a <code>char*</code>, you actually want to pass in a pointer to a <code>struct in_addr</code>. <code>len</code> should be <code>sizeof(struct in_addr)</code>, and <code>type</code> should be <code>AF_INET</code>.</p>
<p>So what is this  <code>struct hostent</code> that gets returned? It has a number of fields that contain information about the host in question.</p>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 69%">
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>char *h_name</code></td>
<td>The real canonical host name.</td>
</tr>
<tr class="even">
<td><code>char **h_aliases</code></td>
<td>A list of aliases that can be accessed with arrays—the last element is <code>NULL</code></td>
</tr>
<tr class="odd">
<td><code>int h_addrtype</code></td>
<td>The result’s address type, which really should be <code>AF_INET</code> for our purposes.</td>
</tr>
<tr class="even">
<td><code>int length</code></td>
<td>The length of the addresses in bytes, which is 4 for IP (version 4) addresses.</td>
</tr>
<tr class="odd">
<td><code>char **h_addr_list</code></td>
<td>A list of IP addresses for this host. Although this is a <code>char**</code>, it’s really an array of <code>struct in_addr*</code>s in disguise. The last array element is <code>NULL</code>.</td>
</tr>
<tr class="even">
<td><code>h_addr</code></td>
<td>A commonly defined alias for <code>h_addr_list[0]</code>. If you just want any old IP address for this host (yeah, they can have more than one) just use this field.</td>
</tr>
</tbody>
</table>
<h4 data-number="9.7.0.3" id="return-value-6"><span class="header-section-number">9.7.0.3</span> Return Value</h4>
<p>Returns a pointer to a resultant <code>struct hostent</code> on success, or <code>NULL</code> on error.</p>
<p>Instead of the normal <code>perror()</code> and all that stuff you’d normally use for error reporting, these functions have parallel results in the variable <code>h_errno</code>, which can be printed using the functions  <code>herror()</code> or  <code>hstrerror()</code>. These work just like the classic <code>errno</code>, <code>perror()</code>, and <code>strerror()</code> functions you’re used to.</p>
<h4 data-number="9.7.0.4" id="example-6"><span class="header-section-number">9.7.0.4</span> Example</h4>
<div class="sourceCode" id="cb95"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb95-1"><a href="#cb95-1"></a><span class="co">// THIS IS A </span><span class="al">DEPRECATED</span><span class="co"> METHOD OF GETTING HOST NAMES</span></span>
<span id="cb95-2"><a href="#cb95-2"></a><span class="co">// use getaddrinfo() instead!</span></span>
<span id="cb95-3"><a href="#cb95-3"></a></span>
<span id="cb95-4"><a href="#cb95-4"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb95-5"><a href="#cb95-5"></a><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></span>
<span id="cb95-6"><a href="#cb95-6"></a><span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></span>
<span id="cb95-7"><a href="#cb95-7"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb95-8"><a href="#cb95-8"></a><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb95-9"><a href="#cb95-9"></a><span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></span>
<span id="cb95-10"><a href="#cb95-10"></a><span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></span>
<span id="cb95-11"><a href="#cb95-11"></a></span>
<span id="cb95-12"><a href="#cb95-12"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</span>
<span id="cb95-13"><a href="#cb95-13"></a>{</span>
<span id="cb95-14"><a href="#cb95-14"></a>    <span class="dt">int</span> i;</span>
<span id="cb95-15"><a href="#cb95-15"></a>    <span class="kw">struct</span> hostent *he;</span>
<span id="cb95-16"><a href="#cb95-16"></a>    <span class="kw">struct</span> in_addr **addr_list;</span>
<span id="cb95-17"><a href="#cb95-17"></a></span>
<span id="cb95-18"><a href="#cb95-18"></a>    <span class="cf">if</span> (argc != <span class="dv">2</span>) {</span>
<span id="cb95-19"><a href="#cb95-19"></a>        fprintf(stderr,<span class="st">"usage: ghbn hostname</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb95-20"><a href="#cb95-20"></a>        <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb95-21"><a href="#cb95-21"></a>    }</span>
<span id="cb95-22"><a href="#cb95-22"></a></span>
<span id="cb95-23"><a href="#cb95-23"></a>    <span class="cf">if</span> ((he = gethostbyname(argv[<span class="dv">1</span>])) == NULL) {  <span class="co">// get the host info</span></span>
<span id="cb95-24"><a href="#cb95-24"></a>        herror(<span class="st">"gethostbyname"</span>);</span>
<span id="cb95-25"><a href="#cb95-25"></a>        <span class="cf">return</span> <span class="dv">2</span>;</span>
<span id="cb95-26"><a href="#cb95-26"></a>    }</span>
<span id="cb95-27"><a href="#cb95-27"></a></span>
<span id="cb95-28"><a href="#cb95-28"></a>    <span class="co">// print information about this host:</span></span>
<span id="cb95-29"><a href="#cb95-29"></a>    printf(<span class="st">"Official name is: %s</span><span class="sc">\n</span><span class="st">"</span>, he-&gt;h_name);</span>
<span id="cb95-30"><a href="#cb95-30"></a>    printf(<span class="st">"    IP addresses: "</span>);</span>
<span id="cb95-31"><a href="#cb95-31"></a>    addr_list = (<span class="kw">struct</span> in_addr **)he-&gt;h_addr_list;</span>
<span id="cb95-32"><a href="#cb95-32"></a>    <span class="cf">for</span>(i = <span class="dv">0</span>; addr_list[i] != NULL; i++) {</span>
<span id="cb95-33"><a href="#cb95-33"></a>        printf(<span class="st">"%s "</span>, inet_ntoa(*addr_list[i]));</span>
<span id="cb95-34"><a href="#cb95-34"></a>    }</span>
<span id="cb95-35"><a href="#cb95-35"></a>    printf(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb95-36"><a href="#cb95-36"></a></span>
<span id="cb95-37"><a href="#cb95-37"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb95-38"><a href="#cb95-38"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb96"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb96-1"><a href="#cb96-1"></a><span class="co">// THIS HAS BEEN SUPERCEDED</span></span>
<span id="cb96-2"><a href="#cb96-2"></a><span class="co">// use getnameinfo() instead!</span></span>
<span id="cb96-3"><a href="#cb96-3"></a></span>
<span id="cb96-4"><a href="#cb96-4"></a><span class="kw">struct</span> hostent *he;</span>
<span id="cb96-5"><a href="#cb96-5"></a><span class="kw">struct</span> in_addr ipv4addr;</span>
<span id="cb96-6"><a href="#cb96-6"></a><span class="kw">struct</span> in6_addr ipv6addr;</span>
<span id="cb96-7"><a href="#cb96-7"></a></span>
<span id="cb96-8"><a href="#cb96-8"></a>inet_pton(AF_INET, <span class="st">"192.0.2.34"</span>, &amp;ipv4addr);</span>
<span id="cb96-9"><a href="#cb96-9"></a>he = gethostbyaddr(&amp;ipv4addr, <span class="kw">sizeof</span> ipv4addr, AF_INET);</span>
<span id="cb96-10"><a href="#cb96-10"></a>printf(<span class="st">"Host name: %s</span><span class="sc">\n</span><span class="st">"</span>, he-&gt;h_name);</span>
<span id="cb96-11"><a href="#cb96-11"></a></span>
<span id="cb96-12"><a href="#cb96-12"></a>inet_pton(AF_INET6, <span class="st">"2001:db8:63b3:1::beef"</span>, &amp;ipv6addr);</span>
<span id="cb96-13"><a href="#cb96-13"></a>he = gethostbyaddr(&amp;ipv6addr, <span class="kw">sizeof</span> ipv6addr, AF_INET6);</span>
<span id="cb96-14"><a href="#cb96-14"></a>printf(<span class="st">"Host name: %s</span><span class="sc">\n</span><span class="st">"</span>, he-&gt;h_name);</span></code></pre></div>
<h4 data-number="9.7.0.5" id="see-also-6"><span class="header-section-number">9.7.0.5</span> See Also</h4>
<p><a href="#getaddrinfoman"><code>getaddrinfo()</code></a>, <a href="#getnameinfoman"><code>getnameinfo()</code></a>, <a href="#gethostnameman"><code>gethostname()</code></a>, <a href="#errnoman"><code>errno</code></a>, <a href="#perrorman"><code>perror()</code></a>, <a href="#perrorman"><code>strerror()</code></a>, <a href="#sockaddr_inman"><code>struct in_addr</code></a></p>
<h2 data-number="9.8" id="getnameinfoman"><span class="header-section-number">9.8</span> <code>getnameinfo()</code></h2>
<p>Look up the host name and service name information for a given <code>struct sockaddr</code>.</p>
<h4 data-number="9.8.0.1" id="synopsis-7"><span class="header-section-number">9.8.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb97"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;netdb.h&gt;</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> getnameinfo(<span class="dt">const</span> <span class="kw">struct</span> sockaddr *sa, socklen_t salen,</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">char</span> *host, <span class="dt">size_t</span> hostlen,</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">char</span> *serv, <span class="dt">size_t</span> servlen, <span class="dt">int</span> flags);</span></code></pre></div>
<h4 data-number="9.8.0.2" id="description-7"><span class="header-section-number">9.8.0.2</span> Description</h4>
<p>This function is the opposite of <code>getaddrinfo()</code>, that is, this function takes an already loaded <code>struct sockaddr</code> and does a name and service name lookup on it. It replaces the old <code>gethostbyaddr()</code> and <code>getservbyport()</code> functions.</p>
<p>You have to pass in a pointer to a <code>struct sockaddr</code> (which in actuality is probably a <code>struct sockaddr_in</code> or <code>struct sockaddr_in6</code> that you’ve cast) in the <code>sa</code> parameter, and the length of that <code>struct</code> in the <code>salen</code>.</p>
<p>The resultant host name and service name will be written to the area pointed to by the <code>host</code> and <code>serv</code> parameters. Of course, you have to specify the max lengths of these buffers in <code>hostlen</code> and <code>servlen</code>.</p>
<p>Finally, there are several flags you can pass, but here a a couple good ones. <code>NI_NOFQDN</code> will cause the <code>host</code> to only contain the host name, not the whole domain name. <code>NI_NAMEREQD</code>
 will cause the function to fail if the name cannot be found with a DNS 
lookup (if you don’t specify this flag and the name can’t be found, <code>getnameinfo()</code> will put a string version of the IP address in <code>host</code> instead).</p>
<p>As always, check your local man pages for the full scoop.</p>
<h4 data-number="9.8.0.3" id="return-value-7"><span class="header-section-number">9.8.0.3</span> Return Value</h4>
<p>Returns zero on success, or non-zero on error. If the return value is non-zero, it can be passed to <code>gai_strerror()</code> to get a human-readable string. See <code>getaddrinfo</code> for more information.</p>
<h4 data-number="9.8.0.4" id="example-7"><span class="header-section-number">9.8.0.4</span> Example</h4>
<div class="sourceCode" id="cb98"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb98-1"><a href="#cb98-1"></a><span class="kw">struct</span> sockaddr_in6 sa; <span class="co">// could be IPv4 if you want</span></span>
<span id="cb98-2"><a href="#cb98-2"></a><span class="dt">char</span> host[<span class="dv">1024</span>];</span>
<span id="cb98-3"><a href="#cb98-3"></a><span class="dt">char</span> service[<span class="dv">20</span>];</span>
<span id="cb98-4"><a href="#cb98-4"></a></span>
<span id="cb98-5"><a href="#cb98-5"></a><span class="co">// pretend sa is full of good information about the host and port...</span></span>
<span id="cb98-6"><a href="#cb98-6"></a></span>
<span id="cb98-7"><a href="#cb98-7"></a>getnameinfo(&amp;sa, <span class="kw">sizeof</span> sa, host, <span class="kw">sizeof</span> host, service, <span class="kw">sizeof</span> service, <span class="dv">0</span>);</span>
<span id="cb98-8"><a href="#cb98-8"></a></span>
<span id="cb98-9"><a href="#cb98-9"></a>printf(<span class="st">"   host: %s</span><span class="sc">\n</span><span class="st">"</span>, host);    <span class="co">// e.g. "www.example.com"</span></span>
<span id="cb98-10"><a href="#cb98-10"></a>printf(<span class="st">"service: %s</span><span class="sc">\n</span><span class="st">"</span>, service); <span class="co">// e.g. "http"</span></span></code></pre></div>
<h4 data-number="9.8.0.5" id="see-also-7"><span class="header-section-number">9.8.0.5</span> See Also</h4>
<p><a href="#getaddrinfoman"><code>getaddrinfo()</code></a>, <a href="#gethostbynameman"><code>gethostbyaddr()</code></a></p>
<h2 data-number="9.9" id="getpeernameman"><span class="header-section-number">9.9</span> <code>getpeername()</code></h2>
<p>Return address info about the remote side of the connection</p>
<h4 data-number="9.9.0.1" id="synopsis-8"><span class="header-section-number">9.9.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb99"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> getpeername(<span class="dt">int</span> s, <span class="kw">struct</span> sockaddr *addr, socklen_t *len);</span></code></pre></div>
<h4 data-number="9.9.0.2" id="description-8"><span class="header-section-number">9.9.0.2</span> Description</h4>
<p> Once you have either <code>accept()</code>ed a remote connection, or <code>connect()</code>ed to a server, you now have what is known as a <em>peer</em>. Your peer is simply the computer you’re connected to, identified by an  IP address and a  port. So…</p>
<p><code>getpeername()</code> simply returns a <code>struct sockaddr_in</code> filled with information about the machine you’re connected to.</p>
<p>Why is it called a “name”? Well, there are a lot of different kinds 
of sockets, not just Internet Sockets like we’re using in this guide, 
and so “name” was a nice generic term that covered all cases. In our 
case, though, the peer’s “name” is it’s IP address and port.</p>
<p>Although the function returns the size of the resultant address in <code>len</code>, you must preload <code>len</code> with the size of <code>addr</code>.</p>
<h4 data-number="9.9.0.3" id="return-value-8"><span class="header-section-number">9.9.0.3</span> Return Value</h4>
<p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p>
<h4 data-number="9.9.0.4" id="example-8"><span class="header-section-number">9.9.0.4</span> Example</h4>
<div class="sourceCode" id="cb100"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb100-1"><a href="#cb100-1"></a><span class="co">// assume s is a connected socket</span></span>
<span id="cb100-2"><a href="#cb100-2"></a></span>
<span id="cb100-3"><a href="#cb100-3"></a>socklen_t len;</span>
<span id="cb100-4"><a href="#cb100-4"></a><span class="kw">struct</span> sockaddr_storage addr;</span>
<span id="cb100-5"><a href="#cb100-5"></a><span class="dt">char</span> ipstr[INET6_ADDRSTRLEN];</span>
<span id="cb100-6"><a href="#cb100-6"></a><span class="dt">int</span> port;</span>
<span id="cb100-7"><a href="#cb100-7"></a></span>
<span id="cb100-8"><a href="#cb100-8"></a>len = <span class="kw">sizeof</span> addr;</span>
<span id="cb100-9"><a href="#cb100-9"></a>getpeername(s, (<span class="kw">struct</span> sockaddr*)&amp;addr, &amp;len);</span>
<span id="cb100-10"><a href="#cb100-10"></a></span>
<span id="cb100-11"><a href="#cb100-11"></a><span class="co">// deal with both IPv4 and IPv6:</span></span>
<span id="cb100-12"><a href="#cb100-12"></a><span class="cf">if</span> (addr.ss_family == AF_INET) {</span>
<span id="cb100-13"><a href="#cb100-13"></a>    <span class="kw">struct</span> sockaddr_in *s = (<span class="kw">struct</span> sockaddr_in *)&amp;addr;</span>
<span id="cb100-14"><a href="#cb100-14"></a>    port = ntohs(s-&gt;sin_port);</span>
<span id="cb100-15"><a href="#cb100-15"></a>    inet_ntop(AF_INET, &amp;s-&gt;sin_addr, ipstr, <span class="kw">sizeof</span> ipstr);</span>
<span id="cb100-16"><a href="#cb100-16"></a>} <span class="cf">else</span> { <span class="co">// AF_INET6</span></span>
<span id="cb100-17"><a href="#cb100-17"></a>    <span class="kw">struct</span> sockaddr_in6 *s = (<span class="kw">struct</span> sockaddr_in6 *)&amp;addr;</span>
<span id="cb100-18"><a href="#cb100-18"></a>    port = ntohs(s-&gt;sin6_port);</span>
<span id="cb100-19"><a href="#cb100-19"></a>    inet_ntop(AF_INET6, &amp;s-&gt;sin6_addr, ipstr, <span class="kw">sizeof</span> ipstr);</span>
<span id="cb100-20"><a href="#cb100-20"></a>}</span>
<span id="cb100-21"><a href="#cb100-21"></a></span>
<span id="cb100-22"><a href="#cb100-22"></a>printf(<span class="st">"Peer IP address: %s</span><span class="sc">\n</span><span class="st">"</span>, ipstr);</span>
<span id="cb100-23"><a href="#cb100-23"></a>printf(<span class="st">"Peer port      : %d</span><span class="sc">\n</span><span class="st">"</span>, port);</span></code></pre></div>
<h4 data-number="9.9.0.5" id="see-also-8"><span class="header-section-number">9.9.0.5</span> See Also</h4>
<p><a href="#gethostnameman"><code>gethostname()</code></a>, <a href="#gethostbynameman"><code>gethostbyname()</code></a>, <a href="#gethostbynameman"><code>gethostbyaddr()</code></a></p>
<h2 data-number="9.10" id="errnoman"><span class="header-section-number">9.10</span> <code>errno</code></h2>
<p>Holds the error code for the last system call</p>
<h4 data-number="9.10.0.1" id="synopsis-9"><span class="header-section-number">9.10.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb101"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> errno;</span></code></pre></div>
<h4 data-number="9.10.0.2" id="description-9"><span class="header-section-number">9.10.0.2</span> Description</h4>
<p> This is the variable that holds error information for a lot of system calls. If you’ll recall, things like <code>socket()</code> and <code>listen()</code> return <code>-1</code> on error, and they set the exact value of <code>errno</code> to let you know specifically which error occurred.</p>
<p>The header file <code>errno.h</code> lists a bunch of constant symbolic names for errors, such as <code>EADDRINUSE</code>, <code>EPIPE</code>, <code>ECONNREFUSED</code>,
 etc. Your local man pages will tell you what codes can be returned as 
an error, and you can use these at run time to handle different errors 
in different ways.</p>
<p>Or, more commonly, you can call  <code>perror()</code> or  <code>strerror()</code> to get a human-readable version of the error.</p>
<p>One thing to note, for you multithreading enthusiasts, is that on most systems <code>errno</code>
 is defined in a threadsafe manner. (That is, it’s not actually a global
 variable, but it behaves just like a global variable would in a 
single-threaded environment.)</p>
<h4 data-number="9.10.0.3" id="return-value-9"><span class="header-section-number">9.10.0.3</span> Return Value</h4>
<p>The value of the variable is the latest error to have transpired, 
which might be the code for “success” if the last action succeeded.</p>
<h4 data-number="9.10.0.4" id="example-9"><span class="header-section-number">9.10.0.4</span> Example</h4>
<div class="sourceCode" id="cb102"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb102-1"><a href="#cb102-1"></a>s = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</span>
<span id="cb102-2"><a href="#cb102-2"></a><span class="cf">if</span> (s == -<span class="dv">1</span>) {</span>
<span id="cb102-3"><a href="#cb102-3"></a>    perror(<span class="st">"socket"</span>); <span class="co">// or use strerror()</span></span>
<span id="cb102-4"><a href="#cb102-4"></a>}</span>
<span id="cb102-5"><a href="#cb102-5"></a></span>
<span id="cb102-6"><a href="#cb102-6"></a>tryagain:</span>
<span id="cb102-7"><a href="#cb102-7"></a><span class="cf">if</span> (select(n, &amp;readfds, NULL, NULL) == -<span class="dv">1</span>) {</span>
<span id="cb102-8"><a href="#cb102-8"></a>    <span class="co">// an error has occurred!!</span></span>
<span id="cb102-9"><a href="#cb102-9"></a></span>
<span id="cb102-10"><a href="#cb102-10"></a>    <span class="co">// if we were only interrupted, just restart the select() call:</span></span>
<span id="cb102-11"><a href="#cb102-11"></a>    <span class="cf">if</span> (errno == EINTR) <span class="cf">goto</span> tryagain;  <span class="co">// AAAA! goto!!!</span></span>
<span id="cb102-12"><a href="#cb102-12"></a></span>
<span id="cb102-13"><a href="#cb102-13"></a>    <span class="co">// otherwise it's a more serious error:</span></span>
<span id="cb102-14"><a href="#cb102-14"></a>    perror(<span class="st">"select"</span>);</span>
<span id="cb102-15"><a href="#cb102-15"></a>    exit(<span class="dv">1</span>);</span>
<span id="cb102-16"><a href="#cb102-16"></a>}</span></code></pre></div>
<h4 data-number="9.10.0.5" id="see-also-9"><span class="header-section-number">9.10.0.5</span> See Also</h4>
<p><a href="#perrorman"><code>perror()</code></a>, <a href="#perrorman"><code>strerror()</code></a></p>
<h2 data-number="9.11" id="fcntlman"><span class="header-section-number">9.11</span> <code>fcntl()</code></h2>
<p>Control socket descriptors</p>
<h4 data-number="9.11.0.1" id="synopsis-10"><span class="header-section-number">9.11.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb103"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/unistd.h&gt;</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/fcntl.h&gt;</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fcntl(<span class="dt">int</span> s, <span class="dt">int</span> cmd, <span class="dt">long</span> arg);</span></code></pre></div>
<h4 data-number="9.11.0.2" id="description-10"><span class="header-section-number">9.11.0.2</span> Description</h4>
<p> This function is typically used to do file locking and other 
file-oriented stuff, but it also has a couple socket-related functions 
that you might see or use from time to time.</p>
<p>Parameter <code>s</code> is the socket descriptor you wish to operate on, <code>cmd</code> should be set to  <code>F_SETFL</code>, and <code>arg</code> can be one of the following commands. (Like I said, there’s more to <code>fcntl()</code> than I’m letting on here, but I’m trying to stay socket-oriented.)</p>
<p>  </p>
<table>
<colgroup>
<col style="width: 18%">
<col style="width: 81%">
</colgroup>
<thead>
<tr class="header">
<th><code>cmd</code></th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>O_NONBLOCK</code></td>
<td>Set the socket to be non-blocking. See the section on <a href="#blocking">blocking</a> for more details.</td>
</tr>
<tr class="even">
<td><code>O_ASYNC</code></td>
<td>Set the socket to do asynchronous I/O. When data is ready to be <code>recv()</code>’d on the socket, the signal <code>SIGIO</code> will be raised. This is rare to see, and beyond the scope of the guide. And I think it’s only available on certain systems.</td>
</tr>
</tbody>
</table>
<h4 data-number="9.11.0.3" id="return-value-10"><span class="header-section-number">9.11.0.3</span> Return Value</h4>
<p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p>
<p>Different uses of the <code>fcntl()</code> system call actually have 
different return values, but I haven’t covered them here because they’re
 not socket-related. See your local <code>fcntl()</code> man page for more information.</p>
<h4 data-number="9.11.0.4" id="example-10"><span class="header-section-number">9.11.0.4</span> Example</h4>
<div class="sourceCode" id="cb104"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb104-1"><a href="#cb104-1"></a><span class="dt">int</span> s = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</span>
<span id="cb104-2"><a href="#cb104-2"></a></span>
<span id="cb104-3"><a href="#cb104-3"></a>fcntl(s, F_SETFL, O_NONBLOCK);  <span class="co">// set to non-blocking</span></span>
<span id="cb104-4"><a href="#cb104-4"></a>fcntl(s, F_SETFL, O_ASYNC);     <span class="co">// set to asynchronous I/O</span></span></code></pre></div>
<h4 data-number="9.11.0.5" id="see-also-10"><span class="header-section-number">9.11.0.5</span> See Also</h4>
<p><a href="#blocking">Blocking</a>, <a href="#sendman"><code>send()</code></a></p>
<h2 data-number="9.12" id="htonsman"><span class="header-section-number">9.12</span> <code>htons()</code>, <code>htonl()</code>, <code>ntohs()</code>, <code>ntohl()</code></h2>
<p>Convert multi-byte integer types from host byte order to network byte order</p>
<h4 data-number="9.12.0.1" id="synopsis-11"><span class="header-section-number">9.12.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb105"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> htonl(<span class="dt">uint32_t</span> hostlong);</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint16_t</span> htons(<span class="dt">uint16_t</span> hostshort);</span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> ntohl(<span class="dt">uint32_t</span> netlong);</span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint16_t</span> ntohs(<span class="dt">uint16_t</span> netshort);</span></code></pre></div>
<h4 data-number="9.12.0.2" id="description-11"><span class="header-section-number">9.12.0.2</span> Description</h4>
<p>    Just to make you really unhappy, different computers use 
different byte orderings internally for their multibyte integers 
(i.e.&nbsp;any integer that’s larger than a <code>char</code>). The upshot of this is that if you <code>send()</code> a two-byte <code>short int</code> from an Intel box to a Mac (before they became Intel boxes, too, I mean), what one computer thinks is the number <code>1</code>, the other will think is the number <code>256</code>, and vice-versa.</p>
<p> The way to get around this problem is for everyone to put aside 
their differences and agree that Motorola and IBM had it right, and 
Intel did it the weird way, and so we all convert our byte orderings to 
“big-endian” before sending them out. Since Intel is a “little-endian” 
machine, it’s far more politically correct to call our preferred byte 
ordering “Network Byte Order”. So these functions convert from your 
native byte order to network byte order and back again.</p>
<p>(This means on Intel these functions swap all the bytes around, and 
on PowerPC they do nothing because the bytes are already in Network Byte
 Order. But you should always use them in your code anyway, since 
someone might want to build it on an Intel machine and still have things
 work properly.)</p>
<p>Note that the types involved are 32-bit (4 byte, probably <code>int</code>) and 16-bit (2 byte, very likely <code>short</code>) numbers. 64-bit machines might have a <code>htonll()</code> for 64-bit <code>int</code>s, but I’ve not seen it. You’ll just have to write your own.</p>
<p>Anyway, the way these functions work is that you first decide if you’re converting <em>from</em>
 host (your machine’s) byte order or from network byte order. If “host”,
 the the first letter of the function you’re going to call is “h”. 
Otherwise it’s “n” for “network”. The middle of the function name is 
always “to” because you’re converting from one “to” another, and the 
penultimate letter shows what you’re converting <em>to</em>. The last letter is the size of the data, “s” for short, or “l” for long. Thus:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>htons()</code></td>
<td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>s</code>hort</td>
</tr>
<tr class="even">
<td><code>htonl()</code></td>
<td><code>h</code>ost <code>to</code> <code>n</code>etwork <code>l</code>ong</td>
</tr>
<tr class="odd">
<td><code>ntohs()</code></td>
<td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>s</code>hort</td>
</tr>
<tr class="even">
<td><code>ntohl()</code></td>
<td><code>n</code>etwork <code>to</code> <code>h</code>ost <code>l</code>ong</td>
</tr>
</tbody>
</table>
<h4 data-number="9.12.0.3" id="return-value-11"><span class="header-section-number">9.12.0.3</span> Return Value</h4>
<p>Each function returns the converted value.</p>
<h4 data-number="9.12.0.4" id="example-11"><span class="header-section-number">9.12.0.4</span> Example</h4>
<div class="sourceCode" id="cb106"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb106-1"><a href="#cb106-1"></a><span class="dt">uint32_t</span> some_long = <span class="dv">10</span>;</span>
<span id="cb106-2"><a href="#cb106-2"></a><span class="dt">uint16_t</span> some_short = <span class="dv">20</span>;</span>
<span id="cb106-3"><a href="#cb106-3"></a></span>
<span id="cb106-4"><a href="#cb106-4"></a><span class="dt">uint32_t</span> network_byte_order;</span>
<span id="cb106-5"><a href="#cb106-5"></a></span>
<span id="cb106-6"><a href="#cb106-6"></a><span class="co">// convert and send</span></span>
<span id="cb106-7"><a href="#cb106-7"></a>network_byte_order = htonl(some_long);</span>
<span id="cb106-8"><a href="#cb106-8"></a>send(s, &amp;network_byte_order, <span class="kw">sizeof</span>(<span class="dt">uint32_t</span>), <span class="dv">0</span>);</span>
<span id="cb106-9"><a href="#cb106-9"></a></span>
<span id="cb106-10"><a href="#cb106-10"></a>some_short == ntohs(htons(some_short)); <span class="co">// this expression is true</span></span></code></pre></div>
<h2 data-number="9.13" id="inet_ntoaman"><span class="header-section-number">9.13</span> <code>inet_ntoa()</code>, <code>inet_aton()</code>, <code>inet_addr</code></h2>
<p>Convert IP addresses from a dots-and-number string to a <code>struct in_addr</code> and back</p>
<h4 data-number="9.13.0.1" id="synopsis-12"><span class="header-section-number">9.13.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb107"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ALL THESE ARE </span><span class="al">DEPRECATED</span><span class="co">! Use inet_pton()  or inet_ntop() instead!!</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> *inet_ntoa(<span class="kw">struct</span> in_addr in);</span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> inet_aton(<span class="dt">const</span> <span class="dt">char</span> *cp, <span class="kw">struct</span> in_addr *inp);</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>    in_addr_t inet_addr(<span class="dt">const</span> <span class="dt">char</span> *cp);</span></code></pre></div>
<h4 data-number="9.13.0.2" id="description-12"><span class="header-section-number">9.13.0.2</span> Description</h4>
<p><em>These functions are deprecated because they don’t handle IPv6! Use <code>inet_ntop()</code> or <code>inet_pton()</code> instead! They are included here because they can still be found in the wild.</em></p>
<p>   All of these functions convert from a <code>struct in_addr</code> (part of your <code>struct sockaddr_in</code>,
 most likely) to a string in dots-and-numbers format (e.g. 
“192.168.5.10”) and vice-versa. If you have an IP address passed on the 
command line or something, this is the easiest way to get a <code>struct in_addr</code> to <code>connect()</code> to, or whatever. If you need more power, try some of the DNS functions like <code>gethostbyname()</code> or attempt a <em>coup d’État</em> in your local country.</p>
<p>The function <code>inet_ntoa()</code> converts a network address in a <code>struct in_addr</code>
 to a dots-and-numbers format string. The “n” in “ntoa” stands for 
network, and the “a” stands for ASCII for historical reasons (so it’s 
“Network To ASCII”—the “toa” suffix has an analogous friend in the C 
library called <code>atoi()</code> which converts an ASCII string to an integer).</p>
<p>The function <code>inet_aton()</code> is the opposite, converting from a dots-and-numbers string into a <code>in_addr_t</code> (which is the type of the field <code>s_addr</code> in your <code>struct in_addr</code>).</p>
<p>Finally, the function <code>inet_addr()</code> is an older function that does basically the same thing as <code>inet_aton()</code>. It’s theoretically deprecated, but you’ll see it a lot and the police won’t come get you if you use it.</p>
<h4 data-number="9.13.0.3" id="return-value-12"><span class="header-section-number">9.13.0.3</span> Return Value</h4>
<p><code>inet_aton()</code> returns non-zero if the address is a valid one, and it returns zero if the address is invalid.</p>
<p><code>inet_ntoa()</code> returns the dots-and-numbers string in a static buffer that is overwritten with each call to the function.</p>
<p><code>inet_addr()</code> returns the address as an <code>in_addr_t</code>, or <code>-1</code> if there’s an error. (That is the same result as if you tried to convert the string  “<code>255.255.255.255</code>”, which is a valid IP address. This is why <code>inet_aton()</code> is better.)</p>
<h4 data-number="9.13.0.4" id="example-12"><span class="header-section-number">9.13.0.4</span> Example</h4>
<div class="sourceCode" id="cb108"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb108-1"><a href="#cb108-1"></a><span class="kw">struct</span> sockaddr_in antelope;</span>
<span id="cb108-2"><a href="#cb108-2"></a><span class="dt">char</span> *some_addr;</span>
<span id="cb108-3"><a href="#cb108-3"></a></span>
<span id="cb108-4"><a href="#cb108-4"></a>inet_aton(<span class="st">"10.0.0.1"</span>, &amp;antelope.sin_addr); <span class="co">// store IP in antelope</span></span>
<span id="cb108-5"><a href="#cb108-5"></a></span>
<span id="cb108-6"><a href="#cb108-6"></a>some_addr = inet_ntoa(antelope.sin_addr); <span class="co">// return the IP</span></span>
<span id="cb108-7"><a href="#cb108-7"></a>printf(<span class="st">"%s</span><span class="sc">\n</span><span class="st">"</span>, some_addr); <span class="co">// prints "10.0.0.1"</span></span>
<span id="cb108-8"><a href="#cb108-8"></a></span>
<span id="cb108-9"><a href="#cb108-9"></a><span class="co">// and this call is the same as the inet_aton() call, above:</span></span>
<span id="cb108-10"><a href="#cb108-10"></a>antelope.sin_addr.s_addr = inet_addr(<span class="st">"10.0.0.1"</span>);</span></code></pre></div>
<h4 data-number="9.13.0.5" id="see-also-11"><span class="header-section-number">9.13.0.5</span> See Also</h4>
<p><a href="#inet_ntopman"><code>inet_ntop()</code></a>, <a href="#inet_ntopman"><code>inet_pton()</code></a>, <a href="#gethostbynameman"><code>gethostbyname()</code></a>, <a href="#gethostbynameman"><code>gethostbyaddr()</code></a></p>
<h2 data-number="9.14" id="inet_ntopman"><span class="header-section-number">9.14</span> <code>inet_ntop()</code>, <code>inet_pton()</code></h2>
<p>Convert IP addresses to human-readable form and back.</p>
<h4 data-number="9.14.0.1" id="synopsis-13"><span class="header-section-number">9.14.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb109"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;arpa/inet.h&gt;</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> *inet_ntop(<span class="dt">int</span> af, <span class="dt">const</span> <span class="dt">void</span> *src,</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>                          <span class="dt">char</span> *dst, socklen_t size);</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> inet_pton(<span class="dt">int</span> af, <span class="dt">const</span> <span class="dt">char</span> *src, <span class="dt">void</span> *dst);</span></code></pre></div>
<h4 data-number="9.14.0.2" id="description-13"><span class="header-section-number">9.14.0.2</span> Description</h4>
<p>These functions are for dealing with human-readable IP addresses and 
converting them to their binary representation for use with various 
functions and system calls. The “n” stands for “network”, and “p” for 
“presentation”. Or “text presentation”. But you can think of it as 
“printable”. “ntop” is “network to printable”. See?</p>
<p>Sometimes you don’t want to look at a pile of binary numbers when 
looking at an IP address. You want it in a nice printable form, like <code>192.0.2.180</code>, or <code>2001:db8:8714:3a90::12</code>. In that case, <code>inet_ntop()</code> is for you.</p>
<p><code>inet_ntop()</code> takes the address family in the <code>af</code> parameter (either <code>AF_INET</code> or <code>AF_INET6</code>). The <code>src</code> parameter should be a pointer to either a <code>struct in_addr</code> or <code>struct in6_addr</code> containing the address you wish to convert to a string. Finally <code>dst</code> and <code>size</code> are the pointer to the destination string and the maximum length of that string.</p>
<p>What should the maximum length of the <code>dst</code> string be? 
What is the maximum length for IPv4 and IPv6 addresses? Fortunately 
there are a couple of macros to help you out. The maximum lengths are: <code>INET_ADDRSTRLEN</code> and <code>INET6_ADDRSTRLEN</code>.</p>
<p>Other times, you might have a string containing an IP address in readable form, and you want to pack it into a <code>struct sockaddr_in</code> or a <code>struct sockaddr_in6</code>. In that case, the opposite funcion <code>inet_pton()</code> is what you’re after.</p>
<p><code>inet_pton()</code> also takes an address family (either <code>AF_INET</code> or <code>AF_INET6</code>) in the <code>af</code> parameter. The <code>src</code> parameter is a pointer to a string containing the IP address in printable form. Lastly the <code>dst</code> parameter points to where the result should be stored, which is probably a <code>struct in_addr</code> or <code>struct in6_addr</code>.</p>
<p>These functions don’t do DNS lookups—you’ll need <code>getaddrinfo()</code> for that.</p>
<h4 data-number="9.14.0.3" id="return-value-13"><span class="header-section-number">9.14.0.3</span> Return Value</h4>
<p><code>inet_ntop()</code> returns the <code>dst</code> parameter on success, or <code>NULL</code> on failure (and <code>errno</code> is set).</p>
<p><code>inet_pton()</code> returns <code>1</code> on success. It returns <code>-1</code> if there was an error (<code>errno</code> is set), or <code>0</code> if the input isn’t a valid IP address.</p>
<h4 data-number="9.14.0.4" id="example-13"><span class="header-section-number">9.14.0.4</span> Example</h4>
<div class="sourceCode" id="cb110"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb110-1"><a href="#cb110-1"></a><span class="co">// IPv4 demo of inet_ntop() and inet_pton()</span></span>
<span id="cb110-2"><a href="#cb110-2"></a></span>
<span id="cb110-3"><a href="#cb110-3"></a><span class="kw">struct</span> sockaddr_in sa;</span>
<span id="cb110-4"><a href="#cb110-4"></a><span class="dt">char</span> str[INET_ADDRSTRLEN];</span>
<span id="cb110-5"><a href="#cb110-5"></a></span>
<span id="cb110-6"><a href="#cb110-6"></a><span class="co">// store this IP address in sa:</span></span>
<span id="cb110-7"><a href="#cb110-7"></a>inet_pton(AF_INET, <span class="st">"192.0.2.33"</span>, &amp;(sa.sin_addr));</span>
<span id="cb110-8"><a href="#cb110-8"></a></span>
<span id="cb110-9"><a href="#cb110-9"></a><span class="co">// now get it back and print it</span></span>
<span id="cb110-10"><a href="#cb110-10"></a>inet_ntop(AF_INET, &amp;(sa.sin_addr), str, INET_ADDRSTRLEN);</span>
<span id="cb110-11"><a href="#cb110-11"></a></span>
<span id="cb110-12"><a href="#cb110-12"></a>printf(<span class="st">"%s</span><span class="sc">\n</span><span class="st">"</span>, str); <span class="co">// prints "192.0.2.33"</span></span></code></pre></div>
<div class="sourceCode" id="cb111"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb111-1"><a href="#cb111-1"></a><span class="co">// IPv6 demo of inet_ntop() and inet_pton()</span></span>
<span id="cb111-2"><a href="#cb111-2"></a><span class="co">// (basically the same except with a bunch of 6s thrown around)</span></span>
<span id="cb111-3"><a href="#cb111-3"></a></span>
<span id="cb111-4"><a href="#cb111-4"></a><span class="kw">struct</span> sockaddr_in6 sa;</span>
<span id="cb111-5"><a href="#cb111-5"></a><span class="dt">char</span> str[INET6_ADDRSTRLEN];</span>
<span id="cb111-6"><a href="#cb111-6"></a></span>
<span id="cb111-7"><a href="#cb111-7"></a><span class="co">// store this IP address in sa:</span></span>
<span id="cb111-8"><a href="#cb111-8"></a>inet_pton(AF_INET6, <span class="st">"2001:db8:8714:3a90::12"</span>, &amp;(sa.sin6_addr));</span>
<span id="cb111-9"><a href="#cb111-9"></a></span>
<span id="cb111-10"><a href="#cb111-10"></a><span class="co">// now get it back and print it</span></span>
<span id="cb111-11"><a href="#cb111-11"></a>inet_ntop(AF_INET6, &amp;(sa.sin6_addr), str, INET6_ADDRSTRLEN);</span>
<span id="cb111-12"><a href="#cb111-12"></a></span>
<span id="cb111-13"><a href="#cb111-13"></a>printf(<span class="st">"%s</span><span class="sc">\n</span><span class="st">"</span>, str); <span class="co">// prints "2001:db8:8714:3a90::12"</span></span></code></pre></div>
<div class="sourceCode" id="cb112"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb112-1"><a href="#cb112-1"></a><span class="co">// Helper function you can use:</span></span>
<span id="cb112-2"><a href="#cb112-2"></a></span>
<span id="cb112-3"><a href="#cb112-3"></a><span class="co">//Convert a struct sockaddr address to a string, IPv4 and IPv6:</span></span>
<span id="cb112-4"><a href="#cb112-4"></a></span>
<span id="cb112-5"><a href="#cb112-5"></a><span class="dt">char</span> *get_ip_str(<span class="dt">const</span> <span class="kw">struct</span> sockaddr *sa, <span class="dt">char</span> *s, <span class="dt">size_t</span> maxlen)</span>
<span id="cb112-6"><a href="#cb112-6"></a>{</span>
<span id="cb112-7"><a href="#cb112-7"></a>    <span class="cf">switch</span>(sa-&gt;sa_family) {</span>
<span id="cb112-8"><a href="#cb112-8"></a>        <span class="cf">case</span> AF_INET:</span>
<span id="cb112-9"><a href="#cb112-9"></a>            inet_ntop(AF_INET, &amp;(((<span class="kw">struct</span> sockaddr_in *)sa)-&gt;sin_addr),</span>
<span id="cb112-10"><a href="#cb112-10"></a>                    s, maxlen);</span>
<span id="cb112-11"><a href="#cb112-11"></a>            <span class="cf">break</span>;</span>
<span id="cb112-12"><a href="#cb112-12"></a></span>
<span id="cb112-13"><a href="#cb112-13"></a>        <span class="cf">case</span> AF_INET6:</span>
<span id="cb112-14"><a href="#cb112-14"></a>            inet_ntop(AF_INET6, &amp;(((<span class="kw">struct</span> sockaddr_in6 *)sa)-&gt;sin6_addr),</span>
<span id="cb112-15"><a href="#cb112-15"></a>                    s, maxlen);</span>
<span id="cb112-16"><a href="#cb112-16"></a>            <span class="cf">break</span>;</span>
<span id="cb112-17"><a href="#cb112-17"></a></span>
<span id="cb112-18"><a href="#cb112-18"></a>        <span class="cf">default</span>:</span>
<span id="cb112-19"><a href="#cb112-19"></a>            strncpy(s, <span class="st">"Unknown AF"</span>, maxlen);</span>
<span id="cb112-20"><a href="#cb112-20"></a>            <span class="cf">return</span> NULL;</span>
<span id="cb112-21"><a href="#cb112-21"></a>    }</span>
<span id="cb112-22"><a href="#cb112-22"></a></span>
<span id="cb112-23"><a href="#cb112-23"></a>    <span class="cf">return</span> s;</span>
<span id="cb112-24"><a href="#cb112-24"></a>}</span></code></pre></div>
<h4 data-number="9.14.0.5" id="see-also-12"><span class="header-section-number">9.14.0.5</span> See Also</h4>
<p><a href="#getaddrinfoman"><code>getaddrinfo()</code></a></p>
<h2 data-number="9.15" id="listenman"><span class="header-section-number">9.15</span> <code>listen()</code></h2>
<p>Tell a socket to listen for incoming connections</p>
<h4 data-number="9.15.0.1" id="synopsis-14"><span class="header-section-number">9.15.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb113"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> listen(<span class="dt">int</span> s, <span class="dt">int</span> backlog);</span></code></pre></div>
<h4 data-number="9.15.0.2" id="description-14"><span class="header-section-number">9.15.0.2</span> Description</h4>
<p> You can take your socket descriptor (made with the <code>socket()</code> system call) and tell it to listen for incoming connections. This is what differentiates the servers from the clients, guys.</p>
<p>The <code>backlog</code> parameter can mean a couple different things
 depending on the system you on, but loosely it is how many pending 
connections you can have before the kernel starts rejecting new ones. So
 as the new connections come in, you should be quick to <code>accept()</code>
 them so that the backlog doesn’t fill. Try setting it to 10 or so, and 
if your clients start getting “Connection refused” under heavy load, set
 it higher.</p>
<p>Before calling <code>listen()</code>, your server should call <code>bind()</code>
 to attach itself to a specific port number. That port number (on the 
server’s IP address) will be the one that clients connect to.</p>
<h4 data-number="9.15.0.3" id="return-value-14"><span class="header-section-number">9.15.0.3</span> Return Value</h4>
<p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p>
<h4 data-number="9.15.0.4" id="example-14"><span class="header-section-number">9.15.0.4</span> Example</h4>
<div class="sourceCode" id="cb114"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb114-1"><a href="#cb114-1"></a><span class="kw">struct</span> addrinfo hints, *res;</span>
<span id="cb114-2"><a href="#cb114-2"></a><span class="dt">int</span> sockfd;</span>
<span id="cb114-3"><a href="#cb114-3"></a></span>
<span id="cb114-4"><a href="#cb114-4"></a><span class="co">// first, load up address structs with getaddrinfo():</span></span>
<span id="cb114-5"><a href="#cb114-5"></a></span>
<span id="cb114-6"><a href="#cb114-6"></a>memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb114-7"><a href="#cb114-7"></a>hints.ai_family = AF_UNSPEC;  <span class="co">// use IPv4 or IPv6, whichever</span></span>
<span id="cb114-8"><a href="#cb114-8"></a>hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb114-9"><a href="#cb114-9"></a>hints.ai_flags = AI_PASSIVE;     <span class="co">// fill in my IP for me</span></span>
<span id="cb114-10"><a href="#cb114-10"></a></span>
<span id="cb114-11"><a href="#cb114-11"></a>getaddrinfo(NULL, <span class="st">"3490"</span>, &amp;hints, &amp;res);</span>
<span id="cb114-12"><a href="#cb114-12"></a></span>
<span id="cb114-13"><a href="#cb114-13"></a><span class="co">// make a socket:</span></span>
<span id="cb114-14"><a href="#cb114-14"></a></span>
<span id="cb114-15"><a href="#cb114-15"></a>sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span>
<span id="cb114-16"><a href="#cb114-16"></a></span>
<span id="cb114-17"><a href="#cb114-17"></a><span class="co">// bind it to the port we passed in to getaddrinfo():</span></span>
<span id="cb114-18"><a href="#cb114-18"></a></span>
<span id="cb114-19"><a href="#cb114-19"></a>bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</span>
<span id="cb114-20"><a href="#cb114-20"></a></span>
<span id="cb114-21"><a href="#cb114-21"></a>listen(sockfd, <span class="dv">10</span>); <span class="co">// set s up to be a server (listening) socket</span></span>
<span id="cb114-22"><a href="#cb114-22"></a></span>
<span id="cb114-23"><a href="#cb114-23"></a><span class="co">// then have an accept() loop down here somewhere</span></span></code></pre></div>
<h4 data-number="9.15.0.5" id="see-also-13"><span class="header-section-number">9.15.0.5</span> See Also</h4>
<p><a href="#acceptman"><code>accept()</code></a>, <a href="#bindman"><code>bind()</code></a>, <a href="#socketman"><code>socket()</code></a></p>
<h2 data-number="9.16" id="perrorman"><span class="header-section-number">9.16</span> <code>perror()</code>, <code>strerror()</code></h2>
<p>Print an error as a human-readable string</p>
<h4 data-number="9.16.0.1" id="synopsis-15"><span class="header-section-number">9.16.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb115"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;string.h&gt;</span><span class="pp">   </span><span class="co">// for strerror()</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> perror(<span class="dt">const</span> <span class="dt">char</span> *s);</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> *strerror(<span class="dt">int</span> errnum);</span></code></pre></div>
<h4 data-number="9.16.0.2" id="description-15"><span class="header-section-number">9.16.0.2</span> Description</h4>
<p>  Since so many functions return <code>-1</code> on error and set the value of the variable  <code>errno</code> to be some number, it would sure be nice if you could easily print that in a form that made sense to you.</p>
<p>Mercifully, <code>perror()</code> does that. If you want more description to be printed before the error, you can point the parameter <code>s</code> to it (or you can leave <code>s</code> as <code>NULL</code> and nothing additional will be printed).</p>
<p>In a nutshell, this function takes <code>errno</code> values, like <code>ECONNRESET</code>, and prints them nicely, like “Connection reset by peer.”</p>
<p>The function <code>strerror()</code> is very similar to <code>perror()</code>, except it returns a pointer to the error message string for a given value (you usually pass in the variable <code>errno</code>).</p>
<h4 data-number="9.16.0.3" id="return-value-15"><span class="header-section-number">9.16.0.3</span> Return Value</h4>
<p><code>strerror()</code> returns a pointer to the error message string.</p>
<h4 data-number="9.16.0.4" id="example-15"><span class="header-section-number">9.16.0.4</span> Example</h4>
<div class="sourceCode" id="cb116"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb116-1"><a href="#cb116-1"></a><span class="dt">int</span> s;</span>
<span id="cb116-2"><a href="#cb116-2"></a></span>
<span id="cb116-3"><a href="#cb116-3"></a>s = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</span>
<span id="cb116-4"><a href="#cb116-4"></a></span>
<span id="cb116-5"><a href="#cb116-5"></a><span class="cf">if</span> (s == -<span class="dv">1</span>) { <span class="co">// some error has occurred</span></span>
<span id="cb116-6"><a href="#cb116-6"></a>    <span class="co">// prints "socket error: " + the error message:</span></span>
<span id="cb116-7"><a href="#cb116-7"></a>    perror(<span class="st">"socket error"</span>);</span>
<span id="cb116-8"><a href="#cb116-8"></a>}</span>
<span id="cb116-9"><a href="#cb116-9"></a></span>
<span id="cb116-10"><a href="#cb116-10"></a><span class="co">// similarly:</span></span>
<span id="cb116-11"><a href="#cb116-11"></a><span class="cf">if</span> (listen(s, <span class="dv">10</span>) == -<span class="dv">1</span>) {</span>
<span id="cb116-12"><a href="#cb116-12"></a>    <span class="co">// this prints "an error: " + the error message from errno:</span></span>
<span id="cb116-13"><a href="#cb116-13"></a>    printf(<span class="st">"an error: %s</span><span class="sc">\n</span><span class="st">"</span>, strerror(errno));</span>
<span id="cb116-14"><a href="#cb116-14"></a>}</span></code></pre></div>
<h4 data-number="9.16.0.5" id="see-also-14"><span class="header-section-number">9.16.0.5</span> See Also</h4>
<p><a href="#errnoman"><code>errno</code></a></p>
<h2 data-number="9.17" id="pollman"><span class="header-section-number">9.17</span> <code>poll()</code></h2>
<p>Test for events on multiple sockets simultaneously</p>
<h4 data-number="9.17.0.1" id="synopsis-16"><span class="header-section-number">9.17.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb117"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/poll.h&gt;</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> poll(<span class="kw">struct</span> pollfd *ufds, <span class="dt">unsigned</span> <span class="dt">int</span> nfds, <span class="dt">int</span> timeout);</span></code></pre></div>
<h4 data-number="9.17.0.2" id="description-16"><span class="header-section-number">9.17.0.2</span> Description</h4>
<p> This function is very similar to <code>select()</code> in that they both watch sets of file descriptors for events, such as incoming data ready to <code>recv()</code>, socket ready to <code>send()</code> data to, out-of-band data ready to <code>recv()</code>, errors, etc.</p>
<p>The basic idea is that you pass an array of <code>nfds</code> <code>struct pollfd</code>s in <code>ufds</code>, along with a timeout in milliseconds (1000 milliseconds in a second). The <code>timeout</code> can be negative if you want to wait forever. If no event happens on any of the socket descriptors by the timeout, <code>poll()</code> will return.</p>
<p>Each element in the array of <code>struct pollfd</code>s represents one socket descriptor, and contains the following fields:</p>
<p></p>
<div class="sourceCode" id="cb118"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> pollfd {</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> fd;         <span class="co">// the socket descriptor</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">short</span> events;   <span class="co">// bitmap of events we're interested in</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">short</span> revents;  <span class="co">// when poll() returns, bitmap of events that occurred</span></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>    };</span></code></pre></div>
<p>Before calling <code>poll()</code>, load <code>fd</code> with the socket descriptor (if you set <code>fd</code> to a negative number, this <code>struct pollfd</code> is ignored and its <code>revents</code> field is set to zero) and then construct the <code>events</code> field by bitwise-ORing the following macros:</p>
<table>
<thead>
<tr class="header">
<th>Macro</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>POLLIN</code></td>
<td>Alert me when data is ready to <code>recv()</code> on this socket.</td>
</tr>
<tr class="even">
<td><code>POLLOUT</code></td>
<td>Alert me when I can <code>send()</code> data to this socket without blocking.</td>
</tr>
<tr class="odd">
<td><code>POLLPRI</code></td>
<td>Alert me when out-of-band data is ready to <code>recv()</code> on this socket.</td>
</tr>
</tbody>
</table>
<p>Once the <code>poll()</code> call returns, the <code>revents</code> 
field will be constructed as a bitwise-OR of the above fields, telling 
you which descriptors actually have had that event occur. Additionally, 
these other fields might be present:</p>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 83%">
</colgroup>
<thead>
<tr class="header">
<th>Macro</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>POLLERR</code></td>
<td>An error has occurred on this socket.</td>
</tr>
<tr class="even">
<td><code>POLLHUP</code></td>
<td>The remote side of the connection hung up.</td>
</tr>
<tr class="odd">
<td><code>POLLNVAL</code></td>
<td>Something was wrong with the socket descriptor <code>fd</code>—maybe it’s uninitialized?</td>
</tr>
</tbody>
</table>
<h4 data-number="9.17.0.3" id="return-value-16"><span class="header-section-number">9.17.0.3</span> Return Value</h4>
<p>Returns the number of elements in the <code>ufds</code> array that have had event occur on them; this can be zero if the timeout occurred. Also returns <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p>
<h4 data-number="9.17.0.4" id="example-16"><span class="header-section-number">9.17.0.4</span> Example</h4>
<div class="sourceCode" id="cb119"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb119-1"><a href="#cb119-1"></a><span class="dt">int</span> s1, s2;</span>
<span id="cb119-2"><a href="#cb119-2"></a><span class="dt">int</span> rv;</span>
<span id="cb119-3"><a href="#cb119-3"></a><span class="dt">char</span> buf1[<span class="dv">256</span>], buf2[<span class="dv">256</span>];</span>
<span id="cb119-4"><a href="#cb119-4"></a><span class="kw">struct</span> pollfd ufds[<span class="dv">2</span>];</span>
<span id="cb119-5"><a href="#cb119-5"></a></span>
<span id="cb119-6"><a href="#cb119-6"></a>s1 = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</span>
<span id="cb119-7"><a href="#cb119-7"></a>s2 = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</span>
<span id="cb119-8"><a href="#cb119-8"></a></span>
<span id="cb119-9"><a href="#cb119-9"></a><span class="co">// pretend we've connected both to a server at this point</span></span>
<span id="cb119-10"><a href="#cb119-10"></a><span class="co">//connect(s1, ...)...</span></span>
<span id="cb119-11"><a href="#cb119-11"></a><span class="co">//connect(s2, ...)...</span></span>
<span id="cb119-12"><a href="#cb119-12"></a></span>
<span id="cb119-13"><a href="#cb119-13"></a><span class="co">// set up the array of file descriptors.</span></span>
<span id="cb119-14"><a href="#cb119-14"></a><span class="co">//</span></span>
<span id="cb119-15"><a href="#cb119-15"></a><span class="co">// in this example, we want to know when there's normal or out-of-band</span></span>
<span id="cb119-16"><a href="#cb119-16"></a><span class="co">// data ready to be recv()'d...</span></span>
<span id="cb119-17"><a href="#cb119-17"></a></span>
<span id="cb119-18"><a href="#cb119-18"></a>ufds[<span class="dv">0</span>].fd = s1;</span>
<span id="cb119-19"><a href="#cb119-19"></a>ufds[<span class="dv">0</span>].events = POLLIN | POLLPRI; <span class="co">// check for normal or out-of-band</span></span>
<span id="cb119-20"><a href="#cb119-20"></a></span>
<span id="cb119-21"><a href="#cb119-21"></a>ufds[<span class="dv">1</span>].fd = s2;</span>
<span id="cb119-22"><a href="#cb119-22"></a>ufds[<span class="dv">1</span>].events = POLLIN; <span class="co">// check for just normal data</span></span>
<span id="cb119-23"><a href="#cb119-23"></a></span>
<span id="cb119-24"><a href="#cb119-24"></a><span class="co">// wait for events on the sockets, 3.5 second timeout</span></span>
<span id="cb119-25"><a href="#cb119-25"></a>rv = poll(ufds, <span class="dv">2</span>, <span class="dv">3500</span>);</span>
<span id="cb119-26"><a href="#cb119-26"></a></span>
<span id="cb119-27"><a href="#cb119-27"></a><span class="cf">if</span> (rv == -<span class="dv">1</span>) {</span>
<span id="cb119-28"><a href="#cb119-28"></a>    perror(<span class="st">"poll"</span>); <span class="co">// error occurred in poll()</span></span>
<span id="cb119-29"><a href="#cb119-29"></a>} <span class="cf">else</span> <span class="cf">if</span> (rv == <span class="dv">0</span>) {</span>
<span id="cb119-30"><a href="#cb119-30"></a>    printf(<span class="st">"Timeout occurred! No data after 3.5 seconds.</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb119-31"><a href="#cb119-31"></a>} <span class="cf">else</span> {</span>
<span id="cb119-32"><a href="#cb119-32"></a>    <span class="co">// check for events on s1:</span></span>
<span id="cb119-33"><a href="#cb119-33"></a>    <span class="cf">if</span> (ufds[<span class="dv">0</span>].revents &amp; POLLIN) {</span>
<span id="cb119-34"><a href="#cb119-34"></a>        recv(s1, buf1, <span class="kw">sizeof</span> buf1, <span class="dv">0</span>); <span class="co">// receive normal data</span></span>
<span id="cb119-35"><a href="#cb119-35"></a>    }</span>
<span id="cb119-36"><a href="#cb119-36"></a>    <span class="cf">if</span> (ufds[<span class="dv">0</span>].revents &amp; POLLPRI) {</span>
<span id="cb119-37"><a href="#cb119-37"></a>        recv(s1, buf1, <span class="kw">sizeof</span> buf1, MSG_OOB); <span class="co">// out-of-band data</span></span>
<span id="cb119-38"><a href="#cb119-38"></a>    }</span>
<span id="cb119-39"><a href="#cb119-39"></a></span>
<span id="cb119-40"><a href="#cb119-40"></a>    <span class="co">// check for events on s2:</span></span>
<span id="cb119-41"><a href="#cb119-41"></a>    <span class="cf">if</span> (ufds[<span class="dv">1</span>].revents &amp; POLLIN) {</span>
<span id="cb119-42"><a href="#cb119-42"></a>        recv(s1, buf2, <span class="kw">sizeof</span> buf2, <span class="dv">0</span>);</span>
<span id="cb119-43"><a href="#cb119-43"></a>    }</span>
<span id="cb119-44"><a href="#cb119-44"></a>}</span></code></pre></div>
<h4 data-number="9.17.0.5" id="see-also-15"><span class="header-section-number">9.17.0.5</span> See Also</h4>
<p><a href="#selectman"><code>select()</code></a></p>
<h2 data-number="9.18" id="recvman"><span class="header-section-number">9.18</span> <code>recv()</code>, <code>recvfrom()</code></h2>
<p>Receive data on a socket</p>
<h4 data-number="9.18.0.1" id="synopsis-17"><span class="header-section-number">9.18.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb120"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ssize_t</span> recv(<span class="dt">int</span> s, <span class="dt">void</span> *buf, <span class="dt">size_t</span> len, <span class="dt">int</span> flags);</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ssize_t</span> recvfrom(<span class="dt">int</span> s, <span class="dt">void</span> *buf, <span class="dt">size_t</span> len, <span class="dt">int</span> flags,</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">struct</span> sockaddr *from, socklen_t *fromlen);</span></code></pre></div>
<h4 data-number="9.18.0.2" id="description-17"><span class="header-section-number">9.18.0.2</span> Description</h4>
<p>  Once you have a socket up and connected, you can read incoming data from the remote side using the <code>recv()</code> (for TCP  <code>SOCK_STREAM</code> sockets) and <code>recvfrom()</code> (for UDP  <code>SOCK_DGRAM</code> sockets).</p>
<p>Both functions take the socket descriptor <code>s</code>, a pointer to the buffer <code>buf</code>, the size (in bytes) of the buffer <code>len</code>, and a set of <code>flags</code> that control how the functions work.</p>
<p>Additionally, the <code>recvfrom()</code> takes a  <code>struct sockaddr*</code>, <code>from</code> that will tell you where the data came from, and will fill in <code>fromlen</code> with the size of <code>struct sockaddr</code>. (You must also initialize <code>fromlen</code> to be the size of <code>from</code> or <code>struct sockaddr</code>.)</p>
<p>So what wondrous flags can you pass into this function? Here are some
 of them, but you should check your local man pages for more information
 and what is actually supported on your system. You bitwise-or these 
together, or just set <code>flags</code> to <code>0</code> if you want it to be a regular vanilla <code>recv()</code>.</p>
<p>   </p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 79%">
</colgroup>
<thead>
<tr class="header">
<th>Macro</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>MSG_OOB</code></td>
<td>Receive Out of Band data. This is how to get data that has been sent to you with the <code>MSG_OOB</code> flag in <code>send()</code>. As the receiving side, you will have had signal  <code>SIGURG</code> raised telling you there is urgent data. In your handler for that signal, you could call <code>recv()</code> with this <code>MSG_OOB</code> flag.</td>
</tr>
<tr class="even">
<td><code>MSG_PEEK</code></td>
<td>If you want to call <code>recv()</code> “just for pretend”, you can call it with this flag. This will tell you what’s waiting in the buffer for when you call <code>recv()</code> “for real” (i.e.&nbsp;<em>without</em> the <code>MSG_PEEK</code> flag. It’s like a sneak preview into the next <code>recv()</code> call.</td>
</tr>
<tr class="odd">
<td><code>MSG_WAITALL</code></td>
<td>Tell <code>recv()</code> to not return until all the data you specified in the <code>len</code>
 parameter. It will ignore your wishes in extreme circumstances, 
however, like if a signal interrupts the call or if some error occurs or
 if the remote side closes the connection, etc. Don’t be mad with it.</td>
</tr>
</tbody>
</table>
<p>When you call <code>recv()</code>, it will block until there is some data to read. If you want to not block, set the socket to non-blocking or check with <code>select()</code> or <code>poll()</code> to see if there is incoming data before calling <code>recv()</code> or <code>recvfrom()</code>.</p>
<h4 data-number="9.18.0.3" id="return-value-17"><span class="header-section-number">9.18.0.3</span> Return Value</h4>
<p>Returns the number of bytes actually received (which might be less than you requested in the <code>len</code> parameter), or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p>
<p>If the remote side has closed the connection, <code>recv()</code> will return <code>0</code>. This is the normal method for determining if the remote side has closed the connection. Normality is good, rebel!</p>
<h4 data-number="9.18.0.4" id="example-17"><span class="header-section-number">9.18.0.4</span> Example</h4>
<div class="sourceCode" id="cb121"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb121-1"><a href="#cb121-1"></a><span class="co">// stream sockets and recv()</span></span>
<span id="cb121-2"><a href="#cb121-2"></a></span>
<span id="cb121-3"><a href="#cb121-3"></a><span class="kw">struct</span> addrinfo hints, *res;</span>
<span id="cb121-4"><a href="#cb121-4"></a><span class="dt">int</span> sockfd;</span>
<span id="cb121-5"><a href="#cb121-5"></a><span class="dt">char</span> buf[<span class="dv">512</span>];</span>
<span id="cb121-6"><a href="#cb121-6"></a><span class="dt">int</span> byte_count;</span>
<span id="cb121-7"><a href="#cb121-7"></a></span>
<span id="cb121-8"><a href="#cb121-8"></a><span class="co">// get host info, make socket, and connect it</span></span>
<span id="cb121-9"><a href="#cb121-9"></a>memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb121-10"><a href="#cb121-10"></a>hints.ai_family = AF_UNSPEC;  <span class="co">// use IPv4 or IPv6, whichever</span></span>
<span id="cb121-11"><a href="#cb121-11"></a>hints.ai_socktype = SOCK_STREAM;</span>
<span id="cb121-12"><a href="#cb121-12"></a>getaddrinfo(<span class="st">"www.example.com"</span>, <span class="st">"3490"</span>, &amp;hints, &amp;res);</span>
<span id="cb121-13"><a href="#cb121-13"></a>sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span>
<span id="cb121-14"><a href="#cb121-14"></a>connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</span>
<span id="cb121-15"><a href="#cb121-15"></a></span>
<span id="cb121-16"><a href="#cb121-16"></a><span class="co">// all right! now that we're connected, we can receive some data!</span></span>
<span id="cb121-17"><a href="#cb121-17"></a>byte_count = recv(sockfd, buf, <span class="kw">sizeof</span> buf, <span class="dv">0</span>);</span>
<span id="cb121-18"><a href="#cb121-18"></a>printf(<span class="st">"recv()'d %d bytes of data in buf</span><span class="sc">\n</span><span class="st">"</span>, byte_count);</span></code></pre></div>
<div class="sourceCode" id="cb122"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb122-1"><a href="#cb122-1"></a><span class="co">// datagram sockets and recvfrom()</span></span>
<span id="cb122-2"><a href="#cb122-2"></a></span>
<span id="cb122-3"><a href="#cb122-3"></a><span class="kw">struct</span> addrinfo hints, *res;</span>
<span id="cb122-4"><a href="#cb122-4"></a><span class="dt">int</span> sockfd;</span>
<span id="cb122-5"><a href="#cb122-5"></a><span class="dt">int</span> byte_count;</span>
<span id="cb122-6"><a href="#cb122-6"></a>socklen_t fromlen;</span>
<span id="cb122-7"><a href="#cb122-7"></a><span class="kw">struct</span> sockaddr_storage addr;</span>
<span id="cb122-8"><a href="#cb122-8"></a><span class="dt">char</span> buf[<span class="dv">512</span>];</span>
<span id="cb122-9"><a href="#cb122-9"></a><span class="dt">char</span> ipstr[INET6_ADDRSTRLEN];</span>
<span id="cb122-10"><a href="#cb122-10"></a></span>
<span id="cb122-11"><a href="#cb122-11"></a><span class="co">// get host info, make socket, bind it to port 4950</span></span>
<span id="cb122-12"><a href="#cb122-12"></a>memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb122-13"><a href="#cb122-13"></a>hints.ai_family = AF_UNSPEC;  <span class="co">// use IPv4 or IPv6, whichever</span></span>
<span id="cb122-14"><a href="#cb122-14"></a>hints.ai_socktype = SOCK_DGRAM;</span>
<span id="cb122-15"><a href="#cb122-15"></a>hints.ai_flags = AI_PASSIVE;</span>
<span id="cb122-16"><a href="#cb122-16"></a>getaddrinfo(NULL, <span class="st">"4950"</span>, &amp;hints, &amp;res);</span>
<span id="cb122-17"><a href="#cb122-17"></a>sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span>
<span id="cb122-18"><a href="#cb122-18"></a>bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</span>
<span id="cb122-19"><a href="#cb122-19"></a></span>
<span id="cb122-20"><a href="#cb122-20"></a><span class="co">// no need to accept(), just recvfrom():</span></span>
<span id="cb122-21"><a href="#cb122-21"></a></span>
<span id="cb122-22"><a href="#cb122-22"></a>fromlen = <span class="kw">sizeof</span> addr;</span>
<span id="cb122-23"><a href="#cb122-23"></a>byte_count = recvfrom(sockfd, buf, <span class="kw">sizeof</span> buf, <span class="dv">0</span>, &amp;addr, &amp;fromlen);</span>
<span id="cb122-24"><a href="#cb122-24"></a></span>
<span id="cb122-25"><a href="#cb122-25"></a>printf(<span class="st">"recv()'d %d bytes of data in buf</span><span class="sc">\n</span><span class="st">"</span>, byte_count);</span>
<span id="cb122-26"><a href="#cb122-26"></a>printf(<span class="st">"from IP address %s</span><span class="sc">\n</span><span class="st">"</span>,</span>
<span id="cb122-27"><a href="#cb122-27"></a>    inet_ntop(addr.ss_family,</span>
<span id="cb122-28"><a href="#cb122-28"></a>        addr.ss_family == AF_INET?</span>
<span id="cb122-29"><a href="#cb122-29"></a>            ((<span class="kw">struct</span> sockadd_in *)&amp;addr)-&gt;sin_addr:</span>
<span id="cb122-30"><a href="#cb122-30"></a>            ((<span class="kw">struct</span> sockadd_in6 *)&amp;addr)-&gt;sin6_addr,</span>
<span id="cb122-31"><a href="#cb122-31"></a>        ipstr, <span class="kw">sizeof</span> ipstr);</span></code></pre></div>
<h4 data-number="9.18.0.5" id="see-also-16"><span class="header-section-number">9.18.0.5</span> See Also</h4>
<p><a href="#sendman"><code>send()</code></a>, <a href="#sendman"><code>sendto()</code></a>, <a href="#selectman"><code>select()</code></a>, <a href="#pollman"><code>poll()</code></a>, <a href="#blocking">Blocking</a></p>
<h2 data-number="9.19" id="selectman"><span class="header-section-number">9.19</span> <code>select()</code></h2>
<p>Check if sockets descriptors are ready to read/write</p>
<h4 data-number="9.19.0.1" id="synopsis-18"><span class="header-section-number">9.19.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb123"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/select.h&gt;</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> select(<span class="dt">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>               <span class="kw">struct</span> timeval *timeout);</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>    FD_SET(<span class="dt">int</span> fd, fd_set *set);</span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a>    FD_CLR(<span class="dt">int</span> fd, fd_set *set);</span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>    FD_ISSET(<span class="dt">int</span> fd, fd_set *set);</span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a>    FD_ZERO(fd_set *set);</span></code></pre></div>
<h4 data-number="9.19.0.2" id="description-18"><span class="header-section-number">9.19.0.2</span> Description</h4>
<p> The <code>select()</code> function gives you a way to simultaneously check multiple sockets to see if they have data waiting to be <code>recv()</code>d, or if you can <code>send()</code> data to them without blocking, or if some exception has occurred.</p>
<p>You populate your sets of socket descriptors using the macros, like <code>FD_SET()</code>, above. Once you have the set, you pass it into the function as one of the following parameters: <code>readfds</code> if you want to know when any of the sockets in the set is ready to <code>recv()</code> data, <code>writefds</code> if any of the sockets is ready to <code>send()</code> data to, and/or <code>exceptfds</code> if you need to know when an exception (error) occurs on any of the sockets. Any or all of these parameters can be <code>NULL</code> if you’re not interested in those types of events. After <code>select()</code> returns, the values in the sets will be changed to show which are ready for reading or writing, and which have exceptions.</p>
<p>The first parameter, <code>n</code> is the highest-numbered socket descriptor (they’re just <code>int</code>s, remember?) plus one.</p>
<p>Lastly, the  <code>struct timeval</code>, <code>timeout</code>, at the end—this lets you tell <code>select()</code> how long to check these sets for. It’ll return after the timeout, or when an event occurs, whichever is first. The <code>struct timeval</code> has two fields: <code>tv_sec</code> is the number of seconds, to which is added <code>tv_usec</code>, the number of microseconds (1,000,000 microseconds in a second).</p>
<p>The helper macros do the following:</p>
<table>
<thead>
<tr class="header">
<th>Macro</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td> <code>FD_SET(int fd, fd_set *set);</code></td>
<td>Add <code>fd</code> to the <code>set</code>.</td>
</tr>
<tr class="even">
<td> <code>FD_CLR(int fd, fd_set *set);</code></td>
<td>Remove <code>fd</code> from the <code>set</code>.</td>
</tr>
<tr class="odd">
<td> <code>FD_ISSET(int fd, fd_set *set);</code></td>
<td>Return true if <code>fd</code> is in the <code>set</code>.</td>
</tr>
<tr class="even">
<td> <code>FD_ZERO(fd_set *set);</code></td>
<td>Clear all entries from the <code>set</code>.</td>
</tr>
</tbody>
</table>
<p>Note for Linux users: Linux’s <code>select()</code> can return “ready-to-read” and then not actually be ready to read, thus causing the subsequent <code>read()</code> call to block. You can work around this bug by setting  <code>O_NONBLOCK</code> flag on the receiving socket so it errors with <code>EWOULDBLOCK</code>, then ignoring this error if it occurs. See the <a href="#fcntlman"><code>fcntl()</code> reference page</a> for more info on setting a socket to non-blocking.</p>
<h4 data-number="9.19.0.3" id="return-value-18"><span class="header-section-number">9.19.0.3</span> Return Value</h4>
<p>Returns the number of descriptors in the set on success, <code>0</code> if the timeout was reached, or <code>-1</code> on error (and <code>errno</code> will be set accordingly). Also, the sets are modified to show which sockets are ready.</p>
<h4 data-number="9.19.0.4" id="example-18"><span class="header-section-number">9.19.0.4</span> Example</h4>
<div class="sourceCode" id="cb124"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb124-1"><a href="#cb124-1"></a><span class="dt">int</span> s1, s2, n;</span>
<span id="cb124-2"><a href="#cb124-2"></a>fd_set readfds;</span>
<span id="cb124-3"><a href="#cb124-3"></a><span class="kw">struct</span> timeval tv;</span>
<span id="cb124-4"><a href="#cb124-4"></a><span class="dt">char</span> buf1[<span class="dv">256</span>], buf2[<span class="dv">256</span>];</span>
<span id="cb124-5"><a href="#cb124-5"></a></span>
<span id="cb124-6"><a href="#cb124-6"></a><span class="co">// pretend we've connected both to a server at this point</span></span>
<span id="cb124-7"><a href="#cb124-7"></a><span class="co">//s1 = socket(...);</span></span>
<span id="cb124-8"><a href="#cb124-8"></a><span class="co">//s2 = socket(...);</span></span>
<span id="cb124-9"><a href="#cb124-9"></a><span class="co">//connect(s1, ...)...</span></span>
<span id="cb124-10"><a href="#cb124-10"></a><span class="co">//connect(s2, ...)...</span></span>
<span id="cb124-11"><a href="#cb124-11"></a></span>
<span id="cb124-12"><a href="#cb124-12"></a><span class="co">// clear the set ahead of time</span></span>
<span id="cb124-13"><a href="#cb124-13"></a>FD_ZERO(&amp;readfds);</span>
<span id="cb124-14"><a href="#cb124-14"></a></span>
<span id="cb124-15"><a href="#cb124-15"></a><span class="co">// add our descriptors to the set</span></span>
<span id="cb124-16"><a href="#cb124-16"></a>FD_SET(s1, &amp;readfds);</span>
<span id="cb124-17"><a href="#cb124-17"></a>FD_SET(s2, &amp;readfds);</span>
<span id="cb124-18"><a href="#cb124-18"></a></span>
<span id="cb124-19"><a href="#cb124-19"></a><span class="co">// since we got s2 second, it's the "greater", so we use that for</span></span>
<span id="cb124-20"><a href="#cb124-20"></a><span class="co">// the n param in select()</span></span>
<span id="cb124-21"><a href="#cb124-21"></a>n = s2 + <span class="dv">1</span>;</span>
<span id="cb124-22"><a href="#cb124-22"></a></span>
<span id="cb124-23"><a href="#cb124-23"></a><span class="co">// wait until either socket has data ready to be recv()d (timeout 10.5 secs)</span></span>
<span id="cb124-24"><a href="#cb124-24"></a>tv.tv_sec = <span class="dv">10</span>;</span>
<span id="cb124-25"><a href="#cb124-25"></a>tv.tv_usec = <span class="dv">500000</span>;</span>
<span id="cb124-26"><a href="#cb124-26"></a>rv = select(n, &amp;readfds, NULL, NULL, &amp;tv);</span>
<span id="cb124-27"><a href="#cb124-27"></a></span>
<span id="cb124-28"><a href="#cb124-28"></a><span class="cf">if</span> (rv == -<span class="dv">1</span>) {</span>
<span id="cb124-29"><a href="#cb124-29"></a>    perror(<span class="st">"select"</span>); <span class="co">// error occurred in select()</span></span>
<span id="cb124-30"><a href="#cb124-30"></a>} <span class="cf">else</span> <span class="cf">if</span> (rv == <span class="dv">0</span>) {</span>
<span id="cb124-31"><a href="#cb124-31"></a>    printf(<span class="st">"Timeout occurred! No data after 10.5 seconds.</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb124-32"><a href="#cb124-32"></a>} <span class="cf">else</span> {</span>
<span id="cb124-33"><a href="#cb124-33"></a>    <span class="co">// one or both of the descriptors have data</span></span>
<span id="cb124-34"><a href="#cb124-34"></a>    <span class="cf">if</span> (FD_ISSET(s1, &amp;readfds)) {</span>
<span id="cb124-35"><a href="#cb124-35"></a>        recv(s1, buf1, <span class="kw">sizeof</span> buf1, <span class="dv">0</span>);</span>
<span id="cb124-36"><a href="#cb124-36"></a>    }</span>
<span id="cb124-37"><a href="#cb124-37"></a>    <span class="cf">if</span> (FD_ISSET(s2, &amp;readfds)) {</span>
<span id="cb124-38"><a href="#cb124-38"></a>        recv(s2, buf2, <span class="kw">sizeof</span> buf2, <span class="dv">0</span>);</span>
<span id="cb124-39"><a href="#cb124-39"></a>    }</span>
<span id="cb124-40"><a href="#cb124-40"></a>}</span></code></pre></div>
<h4 data-number="9.19.0.5" id="see-also-17"><span class="header-section-number">9.19.0.5</span> See Also</h4>
<p><a href="#pollman"><code>poll()</code></a></p>
<h2 data-number="9.20" id="setsockoptman"><span class="header-section-number">9.20</span> <code>setsockopt()</code>, <code>getsockopt()</code></h2>
<p>Set various options for a socket</p>
<h4 data-number="9.20.0.1" id="synopsis-19"><span class="header-section-number">9.20.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb125"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> getsockopt(<span class="dt">int</span> s, <span class="dt">int</span> level, <span class="dt">int</span> optname, <span class="dt">void</span> *optval,</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a>                   socklen_t *optlen);</span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> setsockopt(<span class="dt">int</span> s, <span class="dt">int</span> level, <span class="dt">int</span> optname, <span class="dt">const</span> <span class="dt">void</span> *optval,</span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a>                   socklen_t optlen);</span></code></pre></div>
<h4 data-number="9.20.0.2" id="description-19"><span class="header-section-number">9.20.0.2</span> Description</h4>
<p>  Sockets are fairly configurable beasts. In fact, they are so 
configurable, I’m not even going to cover it all here. It’s probably 
system-dependent anyway. But I will talk about the basics.</p>
<p>Obviously, these functions get and set certain options on a socket. 
On a Linux box, all the socket information is in the man page for socket
 in section 7. (Type: “<code>man 7 socket</code>” to get all these goodies.)</p>
<p>As for parameters, <code>s</code> is the socket you’re talking about, level should be set to  <code>SOL_SOCKET</code>. Then you set the <code>optname</code> to the name you’re interested in. Again, see your man page for all the options, but here are some of the most fun ones:</p>
<table>
<colgroup>
<col style="width: 26%">
<col style="width: 73%">
</colgroup>
<thead>
<tr class="header">
<th><code>optname</code></th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td> <code>SO_BINDTODEVICE</code></td>
<td>Bind this socket to a symbolic device name like <code>eth0</code> instead of using <code>bind()</code> to bind it to an IP address. Type the command <code>ifconfig</code> under Unix to see the device names.</td>
</tr>
<tr class="even">
<td> <code>SO_REUSEADDR</code></td>
<td>Allows other sockets to <code>bind()</code> to this port, unless 
there is an active listening socket bound to the port already. This 
enables you to get around those “Address already in use” error messages 
when you try to restart your server after a crash.</td>
</tr>
<tr class="odd">
<td> <code>SOCK_DGRAM</code></td>
<td>Allows UDP datagram  (<code>SOCK_DGRAM</code>) sockets to send and receive packets sent to and from the broadcast address. Does nothing—<em>NOTHING!!</em>—to TCP stream sockets! Hahaha!</td>
</tr>
</tbody>
</table>
<p>As for the parameter <code>optval</code>, it’s usually a pointer to an <code>int</code>
 indicating the value in question. For booleans, zero is false, and 
non-zero is true. And that’s an absolute fact, unless it’s different on 
your system. If there is no parameter to be passed, <code>optval</code> can be <code>NULL</code>.</p>
<p>The final parameter, <code>optlen</code>, should be set to the length of <code>optval</code>, probably <code>sizeof(int)</code>, but varies depending on the option. Note that in the case of <code>getsockopt()</code>, this is a pointer to a <code>socklen_t</code>, and it specifies the maximum size object that will be stored in <code>optval</code> (to prevent buffer overflows). And <code>getsockopt()</code> will modify the value of <code>optlen</code> to reflect the number of bytes actually set.</p>
<p><strong>Warning</strong>: on some systems (notably   Sun and  Windows), the option can be a <code>char</code> instead of an <code>int</code>, and is set to, for example, a character value of <code>'1'</code> instead of an <code>int</code> value of <code>1</code>. Again, check your own man pages for more info with “<code>man setsockopt</code>” and “<code>man 7 socket</code>”!</p>
<h4 data-number="9.20.0.3" id="return-value-19"><span class="header-section-number">9.20.0.3</span> Return Value</h4>
<p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p>
<h4 data-number="9.20.0.4" id="example-19"><span class="header-section-number">9.20.0.4</span> Example</h4>
<div class="sourceCode" id="cb126"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb126-1"><a href="#cb126-1"></a><span class="dt">int</span> optval;</span>
<span id="cb126-2"><a href="#cb126-2"></a><span class="dt">int</span> optlen;</span>
<span id="cb126-3"><a href="#cb126-3"></a><span class="dt">char</span> *optval2;</span>
<span id="cb126-4"><a href="#cb126-4"></a></span>
<span id="cb126-5"><a href="#cb126-5"></a><span class="co">// set SO_REUSEADDR on a socket to true (1):</span></span>
<span id="cb126-6"><a href="#cb126-6"></a>optval = <span class="dv">1</span>;</span>
<span id="cb126-7"><a href="#cb126-7"></a>setsockopt(s1, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="kw">sizeof</span> optval);</span>
<span id="cb126-8"><a href="#cb126-8"></a></span>
<span id="cb126-9"><a href="#cb126-9"></a><span class="co">// bind a socket to a device name (might not work on all systems):</span></span>
<span id="cb126-10"><a href="#cb126-10"></a>optval2 = <span class="st">"eth1"</span>; <span class="co">// 4 bytes long, so 4, below:</span></span>
<span id="cb126-11"><a href="#cb126-11"></a>setsockopt(s2, SOL_SOCKET, SO_BINDTODEVICE, optval2, <span class="dv">4</span>);</span>
<span id="cb126-12"><a href="#cb126-12"></a></span>
<span id="cb126-13"><a href="#cb126-13"></a><span class="co">// see if the SO_BROADCAST flag is set:</span></span>
<span id="cb126-14"><a href="#cb126-14"></a>getsockopt(s3, SOL_SOCKET, SO_BROADCAST, &amp;optval, &amp;optlen);</span>
<span id="cb126-15"><a href="#cb126-15"></a><span class="cf">if</span> (optval != <span class="dv">0</span>) {</span>
<span id="cb126-16"><a href="#cb126-16"></a>    print(<span class="st">"SO_BROADCAST enabled on s3!</span><span class="sc">\n</span><span class="st">"</span>);</span>
<span id="cb126-17"><a href="#cb126-17"></a>}</span></code></pre></div>
<h4 data-number="9.20.0.5" id="see-also-18"><span class="header-section-number">9.20.0.5</span> See Also</h4>
<p><a href="#fcntlman"><code>fcntl()</code></a></p>
<h2 data-number="9.21" id="sendman"><span class="header-section-number">9.21</span> <code>send()</code>, <code>sendto()</code></h2>
<p>Send data out over a socket</p>
<h4 data-number="9.21.0.1" id="synopsis-20"><span class="header-section-number">9.21.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb127"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ssize_t</span> send(<span class="dt">int</span> s, <span class="dt">const</span> <span class="dt">void</span> *buf, <span class="dt">size_t</span> len, <span class="dt">int</span> flags);</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ssize_t</span> sendto(<span class="dt">int</span> s, <span class="dt">const</span> <span class="dt">void</span> *buf, <span class="dt">size_t</span> len,</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>                   <span class="dt">int</span> flags, <span class="dt">const</span> <span class="kw">struct</span> sockaddr *to,</span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a>                   socklen_t tolen);</span></code></pre></div>
<h4 data-number="9.21.0.2" id="description-20"><span class="header-section-number">9.21.0.2</span> Description</h4>
<p>  These functions send data to a socket. Generally speaking, <code>send()</code> is used for TCP  <code>SOCK_STREAM</code> connected sockets, and <code>sendto()</code> is used for UDP  <code>SOCK_DGRAM</code>
 unconnected datagram sockets. With the unconnected sockets, you must 
specify the destination of a packet each time you send one, and that’s 
why the last parameters of <code>sendto()</code> define where the packet is going.</p>
<p>With both <code>send()</code> and <code>sendto()</code>, the parameter <code>s</code> is the socket, <code>buf</code> is a pointer to the data you want to send, <code>len</code> is the number of bytes you want to send, and <code>flags</code> allows you to specify more information about how the data is to be sent. Set <code>flags</code> to zero if you want it to be “normal” data. Here are some of the commonly used flags, but check your local <code>send()</code> man pages for more details:</p>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr class="header">
<th>Macro</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td> <code>MSG_OOB</code></td>
<td>Send as  “out of band” data. TCP supports this, and it’s a way to 
tell the receiving system that this data has a higher priority than the 
normal data. The receiver will receive the signal  <code>SIGURG</code> and it can then receive this data without first receiving all the rest of the normal data in the queue.</td>
</tr>
<tr class="even">
<td> <code>MSG_DONTROUTE</code></td>
<td>Don’t send this data over a router, just keep it local.</td>
</tr>
<tr class="odd">
<td> <code>MSG_DONTWAIT</code></td>
<td>If <code>send()</code> would block because outbound traffic is clogged, have it return  <code>EAGAIN</code>. This is like a “enable  non-blocking just for this send.” See the section on <a href="#blocking">blocking</a> for more details.</td>
</tr>
<tr class="even">
<td> <code>MSG_NOSIGNAL</code></td>
<td>If you <code>send()</code> to a remote host which is no longer <code>recv()</code>ing, you’ll typically get the signal  <code>SIGPIPE</code>. Adding this flag prevents that signal from being raised.</td>
</tr>
</tbody>
</table>
<h4 data-number="9.21.0.3" id="return-value-20"><span class="header-section-number">9.21.0.3</span> Return Value</h4>
<p>Returns the number of bytes actually sent, or <code>-1</code> on error (and <code>errno</code>
 will be set accordingly). Note that the number of bytes actually sent 
might be less than the number you asked it to send! See the section on <a href="#sendall">handling partial <code>send()</code>s</a> for a helper function to get around this.</p>
<p>Also, if the socket has been closed by either side, the process calling <code>send()</code> will get the signal <code>SIGPIPE</code>. (Unless <code>send()</code> was called with the <code>MSG_NOSIGNAL</code> flag.)</p>
<h4 data-number="9.21.0.4" id="example-20"><span class="header-section-number">9.21.0.4</span> Example</h4>
<div class="sourceCode" id="cb128"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb128-1"><a href="#cb128-1"></a><span class="dt">int</span> spatula_count = <span class="dv">3490</span>;</span>
<span id="cb128-2"><a href="#cb128-2"></a><span class="dt">char</span> *secret_message = <span class="st">"The Cheese is in The Toaster"</span>;</span>
<span id="cb128-3"><a href="#cb128-3"></a></span>
<span id="cb128-4"><a href="#cb128-4"></a><span class="dt">int</span> stream_socket, dgram_socket;</span>
<span id="cb128-5"><a href="#cb128-5"></a><span class="kw">struct</span> sockaddr_in dest;</span>
<span id="cb128-6"><a href="#cb128-6"></a><span class="dt">int</span> temp;</span>
<span id="cb128-7"><a href="#cb128-7"></a></span>
<span id="cb128-8"><a href="#cb128-8"></a><span class="co">// first with TCP stream sockets:</span></span>
<span id="cb128-9"><a href="#cb128-9"></a></span>
<span id="cb128-10"><a href="#cb128-10"></a><span class="co">// assume sockets are made and connected</span></span>
<span id="cb128-11"><a href="#cb128-11"></a><span class="co">//stream_socket = socket(...</span></span>
<span id="cb128-12"><a href="#cb128-12"></a><span class="co">//connect(stream_socket, ...</span></span>
<span id="cb128-13"><a href="#cb128-13"></a></span>
<span id="cb128-14"><a href="#cb128-14"></a><span class="co">// convert to network byte order</span></span>
<span id="cb128-15"><a href="#cb128-15"></a>temp = htonl(spatula_count);</span>
<span id="cb128-16"><a href="#cb128-16"></a><span class="co">// send data normally:</span></span>
<span id="cb128-17"><a href="#cb128-17"></a>send(stream_socket, &amp;temp, <span class="kw">sizeof</span> temp, <span class="dv">0</span>);</span>
<span id="cb128-18"><a href="#cb128-18"></a></span>
<span id="cb128-19"><a href="#cb128-19"></a><span class="co">// send secret message out of band:</span></span>
<span id="cb128-20"><a href="#cb128-20"></a>send(stream_socket, secret_message, strlen(secret_message)+<span class="dv">1</span>, MSG_OOB);</span>
<span id="cb128-21"><a href="#cb128-21"></a></span>
<span id="cb128-22"><a href="#cb128-22"></a><span class="co">// now with UDP datagram sockets:</span></span>
<span id="cb128-23"><a href="#cb128-23"></a><span class="co">//getaddrinfo(...</span></span>
<span id="cb128-24"><a href="#cb128-24"></a><span class="co">//dest = ... // assume "dest" holds the address of the destination</span></span>
<span id="cb128-25"><a href="#cb128-25"></a><span class="co">//dgram_socket = socket(...</span></span>
<span id="cb128-26"><a href="#cb128-26"></a></span>
<span id="cb128-27"><a href="#cb128-27"></a><span class="co">// send secret message normally:</span></span>
<span id="cb128-28"><a href="#cb128-28"></a>sendto(dgram_socket, secret_message, strlen(secret_message)+<span class="dv">1</span>, <span class="dv">0</span>, </span>
<span id="cb128-29"><a href="#cb128-29"></a>       (<span class="kw">struct</span> sockaddr*)&amp;dest, <span class="kw">sizeof</span> dest);</span></code></pre></div>
<h4 data-number="9.21.0.5" id="see-also-19"><span class="header-section-number">9.21.0.5</span> See Also</h4>
<p><a href="#recvman"><code>recv()</code></a>, <a href="#recvman"><code>recvfrom()</code></a></p>
<h2 data-number="9.22" id="shutdownman"><span class="header-section-number">9.22</span> <code>shutdown()</code></h2>
<p>Stop further sends and receives on a socket</p>
<h4 data-number="9.22.0.1" id="synopsis-21"><span class="header-section-number">9.22.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb129"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> shutdown(<span class="dt">int</span> s, <span class="dt">int</span> how);</span></code></pre></div>
<h4 data-number="9.22.0.2" id="description-21"><span class="header-section-number">9.22.0.2</span> Description</h4>
<p> That’s it! I’ve had it! No more <code>send()</code>s are allowed on this socket, but I still want to <code>recv()</code> data on it! Or vice-versa! How can I do this?</p>
<p>When you <code>close()</code> a socket descriptor, it closes both 
sides of the socket for reading and writing, and frees the socket 
descriptor. If you just want to close one side or the other, you can use
 this <code>shutdown()</code> call.</p>
<p>As for parameters, <code>s</code> is obviously the socket you want to perform this action on, and what action that is can be specified with the <code>how</code> parameter. How can be <code>SHUT_RD</code> to prevent further <code>recv()</code>s, <code>SHUT_WR</code> to prohibit further <code>send()</code>s, or <code>SHUT_RDWR</code> to do both.</p>
<p>Note that <code>shutdown()</code> doesn’t free up the socket descriptor, so you still have to eventually <code>close()</code> the socket even if it has been fully shut down.</p>
<p>This is a rarely used system call.</p>
<h4 data-number="9.22.0.3" id="return-value-21"><span class="header-section-number">9.22.0.3</span> Return Value</h4>
<p>Returns zero on success, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p>
<h4 data-number="9.22.0.4" id="example-21"><span class="header-section-number">9.22.0.4</span> Example</h4>
<div class="sourceCode" id="cb130"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb130-1"><a href="#cb130-1"></a><span class="dt">int</span> s = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</span>
<span id="cb130-2"><a href="#cb130-2"></a></span>
<span id="cb130-3"><a href="#cb130-3"></a><span class="co">// ...do some send()s and stuff in here...</span></span>
<span id="cb130-4"><a href="#cb130-4"></a></span>
<span id="cb130-5"><a href="#cb130-5"></a><span class="co">// and now that we're done, don't allow any more sends()s:</span></span>
<span id="cb130-6"><a href="#cb130-6"></a>shutdown(s, SHUT_WR);</span></code></pre></div>
<h4 data-number="9.22.0.5" id="see-also-20"><span class="header-section-number">9.22.0.5</span> See Also</h4>
<p><a href="#closeman"><code>close()</code></a></p>
<h2 data-number="9.23" id="socketman"><span class="header-section-number">9.23</span> <code>socket()</code></h2>
<p>Allocate a socket descriptor</p>
<h4 data-number="9.23.0.1" id="synopsis-22"><span class="header-section-number">9.23.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb131"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> socket(<span class="dt">int</span> domain, <span class="dt">int</span> type, <span class="dt">int</span> protocol);</span></code></pre></div>
<h4 data-number="9.23.0.2" id="description-22"><span class="header-section-number">9.23.0.2</span> Description</h4>
<p> Returns a new socket descriptor that you can use to do sockety 
things with. This is generally the first call in the whopping process of
 writing a socket program, and you can use the result for subsequent 
calls to <code>listen()</code>, <code>bind()</code>, <code>accept()</code>, or a variety of other functions.</p>
<p>In usual usage, you get the values for these parameters from a call to <code>getaddrinfo()</code>, as shown in the example below. But you can fill them in by hand if you really want to.</p>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 83%">
</colgroup>
<thead>
<tr class="header">
<th>Macro</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>domain</code></td>
<td><code>domain</code> describes what kind of socket you’re interested 
in. This can, believe me, be a wide variety of things, but since this is
 a socket guide, it’s going to be  <code>PF_INET</code> for IPv4, and <code>PF_INET6</code> for IPv6.</td>
</tr>
<tr class="even">
<td><code>type</code></td>
<td>Also, the <code>type</code> parameter can be a number of things, but you’ll probably be setting it to either  <code>SOCK_STREAM</code> for reliable  TCP sockets (<code>send()</code>, <code>recv()</code>) or  <code>SOCK_DGRAM</code> for unreliable fast  UDP sockets (<code>sendto()</code>, <code>recvfrom()</code>). (Another interesting socket type is  <code>SOCK_RAW</code> which can be used to construct packets by hand. It’s pretty cool.)</td>
</tr>
<tr class="odd">
<td><code>protocol</code></td>
<td>Finally, the <code>protocol</code> parameter tells which protocol to use with a certain socket type. Like I’ve already said, for instance, <code>SOCK_STREAM</code> uses TCP. Fortunately for you, when using <code>SOCK_STREAM</code> or <code>SOCK_DGRAM</code>, you can just set the protocol to 0, and it’ll use the proper protocol automatically. Otherwise, you can use  <code>getprotobyname()</code> to look up the proper protocol number.</td>
</tr>
</tbody>
</table>
<h4 data-number="9.23.0.3" id="return-value-22"><span class="header-section-number">9.23.0.3</span> Return Value</h4>
<p>The new socket descriptor to be used in subsequent calls, or <code>-1</code> on error (and <code>errno</code> will be set accordingly).</p>
<h4 data-number="9.23.0.4" id="example-22"><span class="header-section-number">9.23.0.4</span> Example</h4>
<div class="sourceCode" id="cb132"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb132-1"><a href="#cb132-1"></a><span class="kw">struct</span> addrinfo hints, *res;</span>
<span id="cb132-2"><a href="#cb132-2"></a><span class="dt">int</span> sockfd;</span>
<span id="cb132-3"><a href="#cb132-3"></a></span>
<span id="cb132-4"><a href="#cb132-4"></a><span class="co">// first, load up address structs with getaddrinfo():</span></span>
<span id="cb132-5"><a href="#cb132-5"></a></span>
<span id="cb132-6"><a href="#cb132-6"></a>memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints);</span>
<span id="cb132-7"><a href="#cb132-7"></a>hints.ai_family = AF_UNSPEC;     <span class="co">// AF_INET, AF_INET6, or AF_UNSPEC</span></span>
<span id="cb132-8"><a href="#cb132-8"></a>hints.ai_socktype = SOCK_STREAM; <span class="co">// SOCK_STREAM or SOCK_DGRAM</span></span>
<span id="cb132-9"><a href="#cb132-9"></a></span>
<span id="cb132-10"><a href="#cb132-10"></a>getaddrinfo(<span class="st">"www.example.com"</span>, <span class="st">"3490"</span>, &amp;hints, &amp;res);</span>
<span id="cb132-11"><a href="#cb132-11"></a></span>
<span id="cb132-12"><a href="#cb132-12"></a><span class="co">// make a socket using the information gleaned from getaddrinfo():</span></span>
<span id="cb132-13"><a href="#cb132-13"></a>sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span></code></pre></div>
<h4 data-number="9.23.0.5" id="see-also-21"><span class="header-section-number">9.23.0.5</span> See Also</h4>
<p><a href="#acceptman"><code>accept()</code></a>, <a href="#bindman"><code>bind()</code></a>, <a href="#getaddrinfoman"><code>getaddrinfo()</code></a>, <a href="#listenman"><code>listen()</code></a></p>
<h2 data-number="9.24" id="structsockaddrman"><span class="header-section-number">9.24</span> <code>struct sockaddr</code> and pals</h2>
<p>Structures for handling internet addresses</p>
<h4 data-number="9.24.0.1" id="synopsis-23"><span class="header-section-number">9.24.0.1</span> Synopsis</h4>
<div class="sourceCode" id="cb133"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;netinet/in.h&gt;</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// All pointers to socket address structures are often cast to pointers</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// to this type before use in various functions and system calls:</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sockaddr {</span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">short</span>    sa_family;    <span class="co">// address family, AF_xxx</span></span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span>              sa_data[<span class="dv">14</span>];  <span class="co">// 14 bytes of protocol address</span></span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-11"><a href="#cb133-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-12"><a href="#cb133-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// IPv4 AF_INET sockets:</span></span>
<span id="cb133-13"><a href="#cb133-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-14"><a href="#cb133-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sockaddr_in {</span>
<span id="cb133-15"><a href="#cb133-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">short</span>            sin_family;   <span class="co">// e.g. AF_INET, AF_INET6</span></span>
<span id="cb133-16"><a href="#cb133-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">short</span>   sin_port;     <span class="co">// e.g. htons(3490)</span></span>
<span id="cb133-17"><a href="#cb133-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> in_addr   sin_addr;     <span class="co">// see struct in_addr, below</span></span>
<span id="cb133-18"><a href="#cb133-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span>             sin_zero[<span class="dv">8</span>];  <span class="co">// zero this if you want to</span></span>
<span id="cb133-19"><a href="#cb133-19" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb133-20"><a href="#cb133-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-21"><a href="#cb133-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> in_addr {</span>
<span id="cb133-22"><a href="#cb133-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">long</span> s_addr;          <span class="co">// load with inet_pton()</span></span>
<span id="cb133-23"><a href="#cb133-23" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb133-24"><a href="#cb133-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-25"><a href="#cb133-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-26"><a href="#cb133-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// IPv6 AF_INET6 sockets:</span></span>
<span id="cb133-27"><a href="#cb133-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-28"><a href="#cb133-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sockaddr_in6 {</span>
<span id="cb133-29"><a href="#cb133-29" aria-hidden="true" tabindex="-1"></a>        u_int16_t       sin6_family;   <span class="co">// address family, AF_INET6</span></span>
<span id="cb133-30"><a href="#cb133-30" aria-hidden="true" tabindex="-1"></a>        u_int16_t       sin6_port;     <span class="co">// port number, Network Byte Order</span></span>
<span id="cb133-31"><a href="#cb133-31" aria-hidden="true" tabindex="-1"></a>        u_int32_t       sin6_flowinfo; <span class="co">// IPv6 flow information</span></span>
<span id="cb133-32"><a href="#cb133-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> in6_addr sin6_addr;     <span class="co">// IPv6 address</span></span>
<span id="cb133-33"><a href="#cb133-33" aria-hidden="true" tabindex="-1"></a>        u_int32_t       sin6_scope_id; <span class="co">// Scope ID</span></span>
<span id="cb133-34"><a href="#cb133-34" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb133-35"><a href="#cb133-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-36"><a href="#cb133-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> in6_addr {</span>
<span id="cb133-37"><a href="#cb133-37" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">char</span>   s6_addr[<span class="dv">16</span>];   <span class="co">// load with inet_pton()</span></span>
<span id="cb133-38"><a href="#cb133-38" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb133-39"><a href="#cb133-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-40"><a href="#cb133-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-41"><a href="#cb133-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// General socket address holding structure, big enough to hold either</span></span>
<span id="cb133-42"><a href="#cb133-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// struct sockaddr_in or struct sockaddr_in6 data:</span></span>
<span id="cb133-43"><a href="#cb133-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-44"><a href="#cb133-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> sockaddr_storage {</span>
<span id="cb133-45"><a href="#cb133-45" aria-hidden="true" tabindex="-1"></a>        sa_family_t  ss_family;     <span class="co">// address family</span></span>
<span id="cb133-46"><a href="#cb133-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb133-47"><a href="#cb133-47" aria-hidden="true" tabindex="-1"></a>        <span class="co">// all this is padding, implementation specific, ignore it:</span></span>
<span id="cb133-48"><a href="#cb133-48" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span>      __ss_pad1[_SS_PAD1SIZE];</span>
<span id="cb133-49"><a href="#cb133-49" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int64_t</span>   __ss_align;</span>
<span id="cb133-50"><a href="#cb133-50" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span>      __ss_pad2[_SS_PAD2SIZE];</span>
<span id="cb133-51"><a href="#cb133-51" aria-hidden="true" tabindex="-1"></a>    };</span></code></pre></div>
<h4 data-number="9.24.0.2" id="description-23"><span class="header-section-number">9.24.0.2</span> Description</h4>
<p>  These are the basic structures for all syscalls and functions that deal with internet addresses. Often you’ll use <code>getaddrinfo()</code> to fill these structures out, and then will read them when you have to.</p>
<p>In memory, the <code>struct sockaddr_in</code> and <code>struct sockaddr_in6</code> share the same beginning structure as  <code>struct sockaddr</code>, and you can freely cast the pointer of one type to the other without any harm, except the possible end of the universe.</p>
<p>Just kidding on that end-of-the-universe thing…if the universe does end when you cast a <code>struct sockaddr_in*</code> to a <code>struct sockaddr*</code>, I promise you it’s pure coincidence and you shouldn’t even worry about it.</p>
<p>So, with that in mind, remember that whenever a function says it takes a <code>struct sockaddr*</code> you can cast your <code>struct sockaddr_in*</code>, <code>struct sockaddr_in6*</code>, or <code>struct sockadd_storage*</code> to that type with ease and safety.</p>
<p><code>struct sockaddr_in</code> is the structure used with IPv4 addresses (e.g. “192.0.2.10”). It holds an address family (<code>AF_INET</code>), a port in <code>sin_port</code>, and an IPv4 address in <code>sin_addr</code>.</p>
<p>There’s also this <code>sin_zero</code> field in <code>struct sockaddr_in</code>
 which some people claim must be set to zero. Other people don’t claim 
anything about it (the Linux documentation doesn’t even mention it at 
all), and setting it to zero doesn’t seem to be actually necessary. So, 
if you feel like it, set it to zero using <code>memset()</code>.</p>
<p>Now, that <code>struct in_addr</code> is a weird beast on different systems. Sometimes it’s a crazy <code>union</code> with all kinds of <code>#define</code>s and other nonsense. But what you should do is only use the <code>s_addr</code> field in this structure, because many systems only implement that one.</p>
<p><code>struct sockadd_in6</code> and <code>struct in6_addr</code> are very similar, except they’re used for IPv6.</p>
<p><code>struct sockaddr_storage</code> is a struct you can pass to <code>accept()</code> or <code>recvfrom()</code> when you’re trying to write IP version-agnostic code and you don’t know if the new address is going to be IPv4 or IPv6. The <code>struct sockaddr_storage</code> structure is large enough to hold both types, unlike the original small <code>struct sockaddr</code>.</p>
<h4 data-number="9.24.0.3" id="example-23"><span class="header-section-number">9.24.0.3</span> Example</h4>
<div class="sourceCode" id="cb134"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb134-1"><a href="#cb134-1"></a><span class="co">// IPv4:</span></span>
<span id="cb134-2"><a href="#cb134-2"></a></span>
<span id="cb134-3"><a href="#cb134-3"></a><span class="kw">struct</span> sockaddr_in ip4addr;</span>
<span id="cb134-4"><a href="#cb134-4"></a><span class="dt">int</span> s;</span>
<span id="cb134-5"><a href="#cb134-5"></a></span>
<span id="cb134-6"><a href="#cb134-6"></a>ip4addr.sin_family = AF_INET;</span>
<span id="cb134-7"><a href="#cb134-7"></a>ip4addr.sin_port = htons(<span class="dv">3490</span>);</span>
<span id="cb134-8"><a href="#cb134-8"></a>inet_pton(AF_INET, <span class="st">"10.0.0.1"</span>, &amp;ip4addr.sin_addr);</span>
<span id="cb134-9"><a href="#cb134-9"></a></span>
<span id="cb134-10"><a href="#cb134-10"></a>s = socket(PF_INET, SOCK_STREAM, <span class="dv">0</span>);</span>
<span id="cb134-11"><a href="#cb134-11"></a>bind(s, (<span class="kw">struct</span> sockaddr*)&amp;ip4addr, <span class="kw">sizeof</span> ip4addr);</span></code></pre></div>
<div class="sourceCode" id="cb135"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb135-1"><a href="#cb135-1"></a><span class="co">// IPv6:</span></span>
<span id="cb135-2"><a href="#cb135-2"></a></span>
<span id="cb135-3"><a href="#cb135-3"></a><span class="kw">struct</span> sockaddr_in6 ip6addr;</span>
<span id="cb135-4"><a href="#cb135-4"></a><span class="dt">int</span> s;</span>
<span id="cb135-5"><a href="#cb135-5"></a></span>
<span id="cb135-6"><a href="#cb135-6"></a>ip6addr.sin6_family = AF_INET6;</span>
<span id="cb135-7"><a href="#cb135-7"></a>ip6addr.sin6_port = htons(<span class="dv">4950</span>);</span>
<span id="cb135-8"><a href="#cb135-8"></a>inet_pton(AF_INET6, <span class="st">"2001:db8:8714:3a90::12"</span>, &amp;ip6addr.sin6_addr);</span>
<span id="cb135-9"><a href="#cb135-9"></a></span>
<span id="cb135-10"><a href="#cb135-10"></a>s = socket(PF_INET6, SOCK_STREAM, <span class="dv">0</span>);</span>
<span id="cb135-11"><a href="#cb135-11"></a>bind(s, (<span class="kw">struct</span> sockaddr*)&amp;ip6addr, <span class="kw">sizeof</span> ip6addr);</span></code></pre></div>
<h4 data-number="9.24.0.4" id="see-also-22"><span class="header-section-number">9.24.0.4</span> See Also</h4>
<p><a href="#acceptman"><code>accept()</code></a>, <a href="#bindman"><code>bind()</code></a>, <a href="#connectman"><code>connect()</code></a>, <a href="#inet_ntoaman"><code>inet_aton()</code></a>, <a href="#inet_ntoaman"><code>inet_ntoa()</code></a></p>
<h1 data-number="10" id="more-references"><span class="header-section-number">10</span> More References</h1>
<p>You’ve come this far, and now you’re screaming for more! Where else can you go to learn more about all this stuff?</p>
<h2 data-number="10.1" id="books"><span class="header-section-number">10.1</span> Books</h2>
<p>  For old-school actual hold-it-in-your-hand pulp paper books, try 
some of the following excellent books. These redirect to affiliate links
 with a popular bookseller, giving me nice kickbacks. If you’re merely 
feeling generous, you can paypal a donation to <a href="mailto:beej@beej.us"><code>beej@beej.us</code></a>. <code>:-)</code></p>
<p><strong>Unix Network Programming, volumes 1-2</strong> by W. Richard Stevens. Published by Addison-Wesley Professional and Prentice Hall. ISBNs for volumes 1-2: <a href="https://beej.us/guide/url/unixnet1">978-0131411555</a><a href="#fn49" class="footnote-ref" id="fnref49" role="doc-noteref"><sup>49</sup></a>, <a href="https://beej.us/guide/url/unixnet2">978-0130810816</a><a href="#fn50" class="footnote-ref" id="fnref50" role="doc-noteref"><sup>50</sup></a>.</p>
<p><strong>Internetworking with TCP/IP, volume I</strong> by Douglas E. Comer. Published by Pearson. ISBN <a href="https://beej.us/guide/url/intertcp1">978-0136085300</a><a href="#fn51" class="footnote-ref" id="fnref51" role="doc-noteref"><sup>51</sup></a>.</p>
<p><strong>TCP/IP Illustrated, volumes 1-3</strong> by W. Richard Stevens and Gary R. Wright. Published by Addison Wesley. ISBNs for volumes 1, 2, and 3 (and a 3-volume set): <a href="https://beej.us/guide/url/tcpi1">978-0201633467</a><a href="#fn52" class="footnote-ref" id="fnref52" role="doc-noteref"><sup>52</sup></a>, <a href="https://beej.us/guide/url/tcpi2">978-0201633542</a><a href="#fn53" class="footnote-ref" id="fnref53" role="doc-noteref"><sup>53</sup></a>, <a href="https://beej.us/guide/url/tcpi3">978-0201634952</a><a href="#fn54" class="footnote-ref" id="fnref54" role="doc-noteref"><sup>54</sup></a>, (<a href="https://beej.us/guide/url/tcpi123">978-0201776317</a><a href="#fn55" class="footnote-ref" id="fnref55" role="doc-noteref"><sup>55</sup></a>).</p>
<p><strong>TCP/IP Network Administration</strong> by Craig Hunt. Published by O’Reilly &amp; Associates, Inc. ISBN <a href="https://beej.us/guide/url/tcpna">978-0596002978</a><a href="#fn56" class="footnote-ref" id="fnref56" role="doc-noteref"><sup>56</sup></a>.</p>
<p><strong>Advanced Programming in the UNIX Environment</strong> by W. Richard Stevens. Published by Addison Wesley. ISBN <a href="https://beej.us/guide/url/advunix">978-0321637734</a><a href="#fn57" class="footnote-ref" id="fnref57" role="doc-noteref"><sup>57</sup></a>.</p>
<h2 data-number="10.2" id="web-references"><span class="header-section-number">10.2</span> Web References</h2>
<p> On the web:</p>
<p><strong><a href="https://cis.temple.edu/~giorgio/old/cis307s96/readings/docs/sockets.html">BSD Sockets: A Quick And Dirty Primer</a><a href="#fn58" class="footnote-ref" id="fnref58" role="doc-noteref"><sup>58</sup></a></strong> (Unix system programming info, too!)</p>
<p><strong><a href="https://developerweb.net/?f=70">The Unix Socket FAQ</a><a href="#fn59" class="footnote-ref" id="fnref59" role="doc-noteref"><sup>59</sup></a></strong></p>
<p><strong><a href="http://www.faqs.org/faqs/internet/tcp-ip/tcp-ip-faq/part1/">TCP/IP FAQ</a><a href="#fn60" class="footnote-ref" id="fnref60" role="doc-noteref"><sup>60</sup></a></strong></p>
<p><strong><a href="https://tangentsoft.net/wskfaq/">The Winsock FAQ</a><a href="#fn61" class="footnote-ref" id="fnref61" role="doc-noteref"><sup>61</sup></a></strong></p>
<p>And here are some relevant Wikipedia pages:</p>
<p><strong><a href="https://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley Sockets</a><a href="#fn62" class="footnote-ref" id="fnref62" role="doc-noteref"><sup>62</sup></a></strong></p>
<p><strong><a href="https://en.wikipedia.org/wiki/Internet_Protocol">Internet Protocol (IP)</a><a href="#fn63" class="footnote-ref" id="fnref63" role="doc-noteref"><sup>63</sup></a></strong></p>
<p><strong><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol (TCP)</a><a href="#fn64" class="footnote-ref" id="fnref64" role="doc-noteref"><sup>64</sup></a></strong></p>
<p><strong><a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">User Datagram Protocol (UDP)</a><a href="#fn65" class="footnote-ref" id="fnref65" role="doc-noteref"><sup>65</sup></a></strong></p>
<p><strong><a href="https://en.wikipedia.org/wiki/Client-server">Client-Server</a><a href="#fn66" class="footnote-ref" id="fnref66" role="doc-noteref"><sup>66</sup></a></strong></p>
<p><strong><a href="https://en.wikipedia.org/wiki/Serialization">Serialization</a><a href="#fn67" class="footnote-ref" id="fnref67" role="doc-noteref"><sup>67</sup></a></strong> (packing and unpacking data)</p>
<h2 data-number="10.3" id="rfcs"><span class="header-section-number">10.3</span> RFCs</h2>
<p></p>
<p><a href="https://www.rfc-editor.org/">RFCs</a><a href="#fn68" class="footnote-ref" id="fnref68" role="doc-noteref"><sup>68</sup></a>—the
 real dirt! These are documents that describe assigned numbers, 
programming APIs, and protocols that are used on the Internet. I’ve 
included links to a few of them here for your enjoyment, so grab a 
bucket of popcorn and put on your thinking cap:</p>
<p><strong><a href="https://tools.ietf.org/html/rfc1">RFC 1</a><a href="#fn69" class="footnote-ref" id="fnref69" role="doc-noteref"><sup>69</sup></a></strong>
 —The First RFC; this gives you an idea of what the “Internet” was like 
just as it was coming to life, and an insight into how it was being 
designed from the ground up. (This RFC is completely obsolete, 
obviously!)</p>
<p> <strong><a href="https://tools.ietf.org/html/rfc768">RFC 768</a><a href="#fn70" class="footnote-ref" id="fnref70" role="doc-noteref"><sup>70</sup></a></strong> —The User Datagram Protocol (UDP)</p>
<p> <strong><a href="https://tools.ietf.org/html/rfc791">RFC 791</a><a href="#fn71" class="footnote-ref" id="fnref71" role="doc-noteref"><sup>71</sup></a></strong> —The Internet Protocol (IP)</p>
<p> <strong><a href="https://tools.ietf.org/html/rfc793">RFC 793</a><a href="#fn72" class="footnote-ref" id="fnref72" role="doc-noteref"><sup>72</sup></a></strong> —The Transmission Control Protocol (TCP)</p>
<p> <strong><a href="https://tools.ietf.org/html/rfc854">RFC 854</a><a href="#fn73" class="footnote-ref" id="fnref73" role="doc-noteref"><sup>73</sup></a></strong> —The Telnet Protocol</p>
<p> <strong><a href="https://tools.ietf.org/html/rfc959">RFC 959</a><a href="#fn74" class="footnote-ref" id="fnref74" role="doc-noteref"><sup>74</sup></a></strong> —File Transfer Protocol (FTP)</p>
<p> <strong><a href="https://tools.ietf.org/html/rfc1350">RFC 1350</a><a href="#fn75" class="footnote-ref" id="fnref75" role="doc-noteref"><sup>75</sup></a></strong> —The Trivial File Transfer Protocol (TFTP)</p>
<p> <strong><a href="https://tools.ietf.org/html/rfc1459">RFC 1459</a><a href="#fn76" class="footnote-ref" id="fnref76" role="doc-noteref"><sup>76</sup></a></strong> —Internet Relay Chat Protocol (IRC)</p>
<p><strong><a href="https://tools.ietf.org/html/rfc1918">RFC 1918</a><a href="#fn77" class="footnote-ref" id="fnref77" role="doc-noteref"><sup>77</sup></a></strong> —Address Allocation for Private Internets</p>
<p> <strong><a href="https://tools.ietf.org/html/rfc2131">RFC 2131</a><a href="#fn78" class="footnote-ref" id="fnref78" role="doc-noteref"><sup>78</sup></a></strong> —Dynamic Host Configuration Protocol (DHCP)</p>
<p> <strong><a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a><a href="#fn79" class="footnote-ref" id="fnref79" role="doc-noteref"><sup>79</sup></a></strong> —Hypertext Transfer Protocol (HTTP)</p>
<p> <strong><a href="https://tools.ietf.org/html/rfc2821">RFC 2821</a><a href="#fn80" class="footnote-ref" id="fnref80" role="doc-noteref"><sup>80</sup></a></strong> —Simple Mail Transfer Protocol (SMTP)</p>
<p><strong><a href="https://tools.ietf.org/html/rfc3330">RFC 3330</a><a href="#fn81" class="footnote-ref" id="fnref81" role="doc-noteref"><sup>81</sup></a></strong> —Special-Use IPv4 Addresses</p>
<p><strong><a href="https://tools.ietf.org/html/rfc3493">RFC 3493</a><a href="#fn82" class="footnote-ref" id="fnref82" role="doc-noteref"><sup>82</sup></a></strong> —Basic Socket Interface Extensions for IPv6</p>
<p><strong><a href="https://tools.ietf.org/html/rfc3542">RFC 3542</a><a href="#fn83" class="footnote-ref" id="fnref83" role="doc-noteref"><sup>83</sup></a></strong> —Advanced Sockets Application Program Interface (API) for IPv6</p>
<p><strong><a href="https://tools.ietf.org/html/rfc3849">RFC 3849</a><a href="#fn84" class="footnote-ref" id="fnref84" role="doc-noteref"><sup>84</sup></a></strong> —IPv6 Address Prefix Reserved for Documentation</p>
<p> <strong><a href="https://tools.ietf.org/html/rfc3920">RFC 3920</a><a href="#fn85" class="footnote-ref" id="fnref85" role="doc-noteref"><sup>85</sup></a></strong> —Extensible Messaging and Presence Protocol (XMPP)</p>
<p> <strong><a href="https://tools.ietf.org/html/rfc3977">RFC 3977</a><a href="#fn86" class="footnote-ref" id="fnref86" role="doc-noteref"><sup>86</sup></a></strong> —Network News Transfer Protocol (NNTP)</p>
<p><strong><a href="https://tools.ietf.org/html/rfc4193">RFC 4193</a><a href="#fn87" class="footnote-ref" id="fnref87" role="doc-noteref"><sup>87</sup></a></strong> —Unique Local IPv6 Unicast Addresses</p>
<p> <strong><a href="https://tools.ietf.org/html/rfc4506">RFC 4506</a><a href="#fn88" class="footnote-ref" id="fnref88" role="doc-noteref"><sup>88</sup></a></strong> —External Data Representation Standard (XDR)</p>
<p>The IETF has a nice online tool for <a href="https://tools.ietf.org/rfc/">searching and browsing RFCs</a><a href="#fn89" class="footnote-ref" id="fnref89" role="doc-noteref"><sup>89</sup></a>.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn1" role="doc-endnote"><p>https://www.linux.com/<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>https://bsd.org/<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>https://cygwin.com/<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>https://docs.microsoft.com/en-us/windows/wsl/about<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>https://tangentsoft.net/wskfaq/<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>http://www.catb.org/~esr/faqs/smart-questions.html<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/telnot.c<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>https://tools.ietf.org/html/rfc854<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>https://tools.ietf.org/html/rfc793<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>https://tools.ietf.org/html/rfc791<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>https://tools.ietf.org/html/rfc768<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>https://tools.ietf.org/html/rfc791<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>https://en.wikipedia.org/wiki/Vint_Cerf<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p>https://en.wikipedia.org/wiki/ELIZA<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15" role="doc-endnote"><p>https://www.iana.org/assignments/port-numbers<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16" role="doc-endnote"><p>https://en.wikipedia.org/wiki/Doom_(1993_video_game)<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17" role="doc-endnote"><p>https://en.wikipedia.org/wiki/Wilford_Brimley<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18" role="doc-endnote"><p>https://tools.ietf.org/html/rfc1918<a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19" role="doc-endnote"><p>https://tools.ietf.org/html/rfc4193<a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20" role="doc-endnote"><p>https://www.iana.org/assignments/port-numbers<a href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/showip.c<a href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn22" role="doc-endnote"><p>https://tools.ietf.org/html/rfc1413<a href="#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn23" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/server.c<a href="#fnref23" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn24" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/client.c<a href="#fnref24" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn25" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/listener.c<a href="#fnref25" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn26" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/talker.c<a href="#fnref26" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn27" role="doc-endnote"><p>https://libevent.org/<a href="#fnref27" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn28" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/poll.c<a href="#fnref28" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn29" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/pollserver.c<a href="#fnref29" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn30" role="doc-endnote"><p>https://libevent.org/<a href="#fnref30" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn31" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/select.c<a href="#fnref31" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn32" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/selectserver.c<a href="#fnref32" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn33" role="doc-endnote"><p>https://en.wikipedia.org/wiki/Internet_Relay_Chat<a href="#fnref33" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn34" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/pack.c<a href="#fnref34" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn35" role="doc-endnote"><p>https://en.wikipedia.org/wiki/IEEE_754<a href="#fnref35" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn36" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/ieee754.c<a href="#fnref36" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn37" role="doc-endnote"><p>https://beej.us/guide/url/tpop<a href="#fnref37" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn38" role="doc-endnote"><p>https://github.com/protobuf-c/protobuf-c<a href="#fnref38" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn39" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/pack2.c<a href="#fnref39" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn40" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/pack2.c<a href="#fnref40" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn41" role="doc-endnote"><p>https://tools.ietf.org/html/rfc4506<a href="#fnref41" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn42" role="doc-endnote"><p>https://beej.us/guide/bgnet/examples/broadcaster.c<a href="#fnref42" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn43" role="doc-endnote"><p>http://www.unpbook.com/src.html<a href="#fnref43" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn44" role="doc-endnote"><p>http://www.unpbook.com/src.html<a href="#fnref44" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn45" role="doc-endnote"><p>https://www.openssl.org/<a href="#fnref45" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn46" role="doc-endnote"><p>https://stackoverflow.com/questions/21323023/<a href="#fnref46" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn47" role="doc-endnote"><p>https://www.iana.org/assignments/port-numbers<a href="#fnref47" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn48" role="doc-endnote"><p>https://www.iana.org/assignments/port-numbers<a href="#fnref48" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn49" role="doc-endnote"><p>https://beej.us/guide/url/unixnet1<a href="#fnref49" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn50" role="doc-endnote"><p>https://beej.us/guide/url/unixnet2<a href="#fnref50" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn51" role="doc-endnote"><p>https://beej.us/guide/url/intertcp1<a href="#fnref51" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn52" role="doc-endnote"><p>https://beej.us/guide/url/tcpi1<a href="#fnref52" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn53" role="doc-endnote"><p>https://beej.us/guide/url/tcpi2<a href="#fnref53" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn54" role="doc-endnote"><p>https://beej.us/guide/url/tcpi3<a href="#fnref54" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn55" role="doc-endnote"><p>https://beej.us/guide/url/tcpi123<a href="#fnref55" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn56" role="doc-endnote"><p>https://beej.us/guide/url/tcpna<a href="#fnref56" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn57" role="doc-endnote"><p>https://beej.us/guide/url/advunix<a href="#fnref57" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn58" role="doc-endnote"><p>https://cis.temple.edu/~giorgio/old/cis307s96/readings/docs/sockets.html<a href="#fnref58" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn59" role="doc-endnote"><p>https://developerweb.net/?f=70<a href="#fnref59" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn60" role="doc-endnote"><p>http://www.faqs.org/faqs/internet/tcp-ip/tcp-ip-faq/part1/<a href="#fnref60" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn61" role="doc-endnote"><p>https://tangentsoft.net/wskfaq/<a href="#fnref61" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn62" role="doc-endnote"><p>https://en.wikipedia.org/wiki/Berkeley_sockets<a href="#fnref62" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn63" role="doc-endnote"><p>https://en.wikipedia.org/wiki/Internet_Protocol<a href="#fnref63" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn64" role="doc-endnote"><p>https://en.wikipedia.org/wiki/Transmission_Control_Protocol<a href="#fnref64" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn65" role="doc-endnote"><p>https://en.wikipedia.org/wiki/User_Datagram_Protocol<a href="#fnref65" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn66" role="doc-endnote"><p>https://en.wikipedia.org/wiki/Client-server<a href="#fnref66" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn67" role="doc-endnote"><p>https://en.wikipedia.org/wiki/Serialization<a href="#fnref67" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn68" role="doc-endnote"><p>https://www.rfc-editor.org/<a href="#fnref68" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn69" role="doc-endnote"><p>https://tools.ietf.org/html/rfc1<a href="#fnref69" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn70" role="doc-endnote"><p>https://tools.ietf.org/html/rfc768<a href="#fnref70" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn71" role="doc-endnote"><p>https://tools.ietf.org/html/rfc791<a href="#fnref71" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn72" role="doc-endnote"><p>https://tools.ietf.org/html/rfc793<a href="#fnref72" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn73" role="doc-endnote"><p>https://tools.ietf.org/html/rfc854<a href="#fnref73" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn74" role="doc-endnote"><p>https://tools.ietf.org/html/rfc959<a href="#fnref74" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn75" role="doc-endnote"><p>https://tools.ietf.org/html/rfc1350<a href="#fnref75" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn76" role="doc-endnote"><p>https://tools.ietf.org/html/rfc1459<a href="#fnref76" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn77" role="doc-endnote"><p>https://tools.ietf.org/html/rfc1918<a href="#fnref77" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn78" role="doc-endnote"><p>https://tools.ietf.org/html/rfc2131<a href="#fnref78" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn79" role="doc-endnote"><p>https://tools.ietf.org/html/rfc2616<a href="#fnref79" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn80" role="doc-endnote"><p>https://tools.ietf.org/html/rfc2821<a href="#fnref80" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn81" role="doc-endnote"><p>https://tools.ietf.org/html/rfc3330<a href="#fnref81" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn82" role="doc-endnote"><p>https://tools.ietf.org/html/rfc3493<a href="#fnref82" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn83" role="doc-endnote"><p>https://tools.ietf.org/html/rfc3542<a href="#fnref83" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn84" role="doc-endnote"><p>https://tools.ietf.org/html/rfc3849<a href="#fnref84" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn85" role="doc-endnote"><p>https://tools.ietf.org/html/rfc3920<a href="#fnref85" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn86" role="doc-endnote"><p>https://tools.ietf.org/html/rfc3977<a href="#fnref86" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn87" role="doc-endnote"><p>https://tools.ietf.org/html/rfc4193<a href="#fnref87" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn88" role="doc-endnote"><p>https://tools.ietf.org/html/rfc4506<a href="#fnref88" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn89" role="doc-endnote"><p>https://tools.ietf.org/rfc/<a href="#fnref89" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


</body><grammarly-desktop-integration data-grammarly-shadow-root="true"></grammarly-desktop-integration></html>